## 概要

### はじめよう
``Linux``:inxx ``Mac``:inxx ``Windows``:inxx

web2pyにはWindowsとMac OS X用のバイナリパッケージが提供されています。Pythonインタプリタが含まれているので、事前のインストールは不要です。また、Windows、Mac、Linux、その他のUnixシステムで動作するソースコードもあります。WindowsとOS Xのバイナリ版には、動作させるのに必要なPythonインタプリタが含まれます。ソースコードパッケージは、Pythonがすでにコンピュータにインストールされていることを前提としています。

web2pyはインストールする必要がありません。始めるには、利用するオペーティングシステム用にダウンロードしたzipファイルを解凍して、適切な``web2py``ファイルを実行します。

Windowsの場合は、次のファイルを実行します：
``
web2py.exe
``:code

OS Xの場合は、次のファイルを実行します：
``
open web2py.app
``:code

UnixおよびLinuxでは、以下のコマンドを入力してソースから実行します：
``
python2.5 web2py.py
``:code

Windows上でソースコードからweb2pyを実行するには、まず [[Mark Hammond's "Python for Windows extensions http://sourceforge.net/projects/pywin32/]] からインストールをして、次のファイルを実行します。
``
python2.5 web2py.py
``:code

web2pyプログラムはさまざまなコマンドラインオプションを受け入れます。これは後ほど説明します。

デフォルトでは、起動時に、起動ウィンドウが表示されます。その後、画面にはGUIウィジェットが表示され、一度限りの管理パスワード、Webサーバーに利用されるネットワークインターフェイスのIPアドレス、リクエストを受けるポート番号を選択するように求められます。デフォルトでは、web2pyは127.0.0.1:8000（ローカルホストのポート8000番）上で動作しますが、任意の取りうるIPアドレスとポートでも動作させることができます。ネットワークインターフェイスのIPアドレスは、コマンドラインを開いたあと、Windowsの場合は``ipconfig``コマンドを、OS XやLinuxの場合は``ifconfig``コマンドを入力する事で確認する事ができます。これ以降、web2pyはローカルホスト（127.0.0.1:8000）上で実行しているものとします。任意のネットワークインターフェイス上にweb2pyを公開して動作させるときは、0.0.0.0:80を使用してください。

[[image @///image/en400.png center 306px]]

管理者のパスワードを指定しない場合は、管理インターフェイスは無効になります。これは管理インターフェイスが公開されてしまう事を防ぐ、セキュリティ上の対策です。

管理者インターフェイス**admin**は、web2pyをApacheとmod_proxyを組み合わせた環境で実行させない限り、ローカルホストからしかアクセスできません。もし管理インターフェイスがプロキシを検出した場合は、セッションクッキーは保護されることとなり、管理インターフェイスのログインは、クライアントとプロキシがHTTPS上で通信しない限り、機能しません。これはセキュリティ対策のためです。クライアントと管理者間のすべての通信は、常にローカルまたは暗号化されている必要があります。そうしないと、攻撃者は中間者攻撃やリプレイ攻撃を行うことができ、サーバ上で任意のコードを実行することが可能になるからです。

管理者用のパスワードが設定されたら、web2pyは次のページからWebブラウザを立ち上げます：
``
http://127.0.0.1:8000/
``:code

デフォルトのブラウザがない場合、Webブラウザを開いて、URLを入力してください。

[[image @///image/en500.png center 480px]]

"administrative interface"をクリックすると、管理インターフェイス用のログインページが表示されます。

[[image @///image/en600.png center 480px]]

管理者パスワードは、起動時に指定したパスワードと同じです。
なお、管理者は1人だけで、したがって、1つの管理パスワードしかありません。セキュリティ上の理由により、web2pyが起動するたびに開発者は毎回新しいパスワードを尋ねられます。ただし、<recycle>オプションを指定するとその限りではありません。これは、web2pyの認証機構とは区別されます。

管理者がweb2pyにログインすると、ブラウザは"site"ページへとリダイレクトされます。

[[image @///image/en700.png center 480px]]

このページではすべてのインストールされているweb2pyアプリケーションが列挙され、管理者はそれらを管理することができます。
``admin``:inxx ``examples``:inxx ``welcome``:inxx ``scaffolding``:inxx
- **admin**アプリケーション。これは現在あなたが利用しているものです。
- **examples**アプリケーション。これはオンラインの対話的なドキュメントと、web2pyの公式サイトのレプリカ（複製）を持っています。
- **welcome**アプリケーション。これは、他のweb2pyアプリケーションのための基本的なテンプレートです。これは、雛形となるアプリケーションとして参照されます。これは、起動時にユーザを迎えるアプリケーションです。

``appliances``:inxx
すぐに利用できるweb2pyアプリケーションは、web2pyの''アプライアンス''として参照されます。多くのフリーで利用可能な``アプライアンス``:citeからダウンロードすることができます。 web2pyのユーザは、オープンソースかクローズドソース（コンパイルされてパックされたもの）のいずれの形式でも、新しいアプライアンスを投稿することが勧められています。

**admin**アプリケーションの''site''ページから、次の操作を行うことができます：
- **install** アプリケーションのインストールは、ページの右下にあるフォームを埋めて行います。アプリケーションの名前を入力し、パッケージ化されたアプリケーションを含むファイルを選択、または、アプリケーションが用意されているURLを指定して、"submit"ボタンをクリックします。
- **uninstall** アプリケーションのアンインストールは対応するボタンをクリックして行います。確認ページが用意されています。
- **create** 新しいアプリケーションの作成は、名前を入力して"create"ボタンをクリックして行います。
- **package** 配布用のアプリケーションのパッケージングは、対応するボタンをクリックして行います。ダウンロードされたアプリケーションは、データベースを含むすべてを保持するtarファイルです。このファイルは untar してはいけません。adminでインストールしたときにweb2pyによって自動的にアンパッケージングされます。
- **clean up** セッションや、エラー、キャッシュファイルなどのアプリケーションの一時ファイルをクリーンアップします。
- **EDIT** アプリケーションを編集します。

-----
**admin**を用いて新規のアプリケーションを作成するときは、"welcome"雛形アプリのクローンから始まります。その中の"models/db.py"は、SQLiteデータベースを作成、接続し、Auth、Crud、Serviceをインスタンス化し、設定します。そこにはまた、"controller/default.py"があり、"index"、"download"、ユーザー管理のための"user"、サービスのための"call"というアクションを提供しています。ここから先、これらのファイルが削除されていることを前提としています。つまり、アプリをスクラッチから作成していきます。
-----

-----
web2pyには**wizard**も付属しています。これについては後の章で説明します。wizardは、web用に準備されたレイアウトやプラグインと高いレベルのモデルの記述に基づいた足場となるコードを生成することができる、もう一つの仕組みです。
-----

### 挨拶しよう
``index``:inxx

ここでは例として、ユーザーに"Hello from MyApp"というメッセージを表示する簡単なWebアプリケーションを作成します。このアプリケーションを"myapp"と呼びます。また、同じユーザがページを何回訪問したかをカウントするカウンタを追加します。

新しいアプリケーションは、**admin**の中の**site**ページの右上にあるフォームに、アプリケーション名を入れることで簡単に作成できます。

[[image @///image/en800.png center 447px]]

[create]ボタンを押すと、アプリケーションは組み込みのwelcomeアプリケーションのコピーとして作成されます。

[[image @///image/en900.png center 480px]]

新しいアプリケーションを実行するには、次のURLを開いてください：
``
http://127.0.0.1:8000/myapp
``:code

これで、welcomeアプリケーションのコピーが作成できました。

アプリケーションを編集するには、新しく作成されたアプリケーションの``design``ボタンをクリックしてください。

**EDIT**ページは、アプリケーションの内部がどのようなものかを示しています。すべてのweb2pyアプリケーションは一定のファイルから構成され、それらのほとんどは次の6つのカテゴリに分類されます：
- **models**: データ表現を記述します。
- **controllers**: アプリケーションのロジックとワークフローを記述します。
- **views**: データの表示方法を記述します。
- **languages**: アプリケーションで表示される内容を、他の言語に翻訳するための方法を記述します。
- **modules**: アプリケーションに属するPythonモジュールです。
- **static files**: 静的画像ファイル、CSSファイル``css-w,css-o,css-school``:cite、JavaScriptファイル``js-w,js-b``:cite、などです。
- **plugins**: 一緒に動作するよう設計されたファイルの集合です。
 
すべてのファイルは、モデル - ビュー - コントローラのデザインパターンに沿ってきちんと構成されます。''edit''ページの各セクションは、アプリケーションフォルダ内のサブフォルダに対応します。

なお、セクションの見出をクリックすると、その中身の表示/非表示を切り替えることができます。同様にstatic filesの下のフォルダ名も、折りたたむことができます。

-------
セクション内の各ファイルは、サブフォルダにある物理的なファイルに対応しています。**管理インターフェイス**からファイルに対して行えるすべての操作（create、edit、delete）は、好みのエディタを使用してシェルから実行することもできます。
-------

アプリケーションは上記以外にもデータベース、セッションファイル、エラーファイルを含みますが、''edit''ページには掲載されません。これらのファイルは管理者ではなく、アプリケーション自身によって作成・編集されるためです。

コントローラは、アプリケーションのロジックやワークフローを含みます。すべてのURLは、コントローラの関数（アクション）のいずれか1つに呼び出しにマッピングされます。"appadmin.py"と"default.py"という2つのデフォルトコントローラが用意されています。**appadmin**は、データベース管理用のインターフェイスを提供しますが、ここでは必要ありません。"default.py"は、編集するべきファイルであり、URLに対応するコントローラが存在しない時にデフォルトで呼び出されます。次のように"index"関数を編集してみましょう：
``
def index():
    return "Hello from MyApp"
``:code

オンラインのエディタは次のような表示になります：

[[image @///image/en1000.png center 480px]]

それを保存し、''edit''ページに戻ってください。そして、indexのリンクをクリックし、新しく作成されたページを表示してください。

次のURLを開くと、
``
http://127.0.0.1:8000/myapp/default/index
``:code

myappアプリケーションのdefaultコントローラにあるindexアクションが呼び出されます。このメソッドは、ブラウザに表示される文字列を返します。下記のように表示されます：

[[image @///image/en1100.png center 480px]]

それでは、"index"関数を次のように編集しましょう：
``
def index():
    return dict(message="Hello from MyApp")
``:code

また、``edit``ページから、"default/index.html"ビュー(アクションに関連付けられたビュー用のファイル)を編集し、すでに存在しているファイルの内容を、全て以下のものに置き換えてください：
``
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
   </body>
</html>
``:code

すると、アクションは``message``が定義された辞書を返すようになります。アクションが辞書を返すとき、web2pyは下記の名前を持つビューを探します。

``[controller]/[function].[extension]``:code

そして、それを実行します。ここでは[extension]は、リクエストされた拡張子です。拡張子が指定されていない場合は、デフォルトは"html"で、ここではそのように想定しています。この場合、ビューは、Pythonのコードを特別な {{ }}タグを用いて埋め込んだHTMLファイルとなります。この例では特に、``{{=message}}``の部分が、そのタグ付きのコードを、アクションから返された``message``の値に置き換えるようにweb2pyに指示します。ただしここで、``message``はweb2pyのキーワードではなく、アクションで定義されたものです。ここまで、web2pyのキーワードは使用されていません。

もしweb2pyがリクエストされたビューを見つけられなかった場合、すべてのアプリケーションで用意されている"generic.html"が使われます。

-------
もし拡張子が"html"以外のもの（たとえば"json"）が指定されて、かつ"[controller]/[function].json"というビューファイルが見つからなかった場合、web2pyは"generic.json"というビューを探します。web2pyでは、generic.html、generic.json、generic.xml、generic.rssというファイルが用意されています。これらの汎用的なビューは、アプリケーションごとに個別に変更することができます。そして新しいビューも簡単に追加できます。
-------

-------
汎用的なビューは、開発用のツールです。リリースする製品では、全てのアクションは固有のビューを持つべきです。実のところ初期設定では、汎用的なビューはlocalhostからのアクセス時のみ有効となっています。
-------

-------
次のようにビューを特定することもできます。 ``response.view = 'default/something.html'``
-------

このトピックに関する詳細は、第10章を読んでください。

"EDIT"ページに戻りindexをクリックすると、次のHTMLページが表示されます：

[[image @///image/en1200.png center 480px]]

デバッグ目的のために、次のコードを追加することができます。

``
{{=response.toolbar()}}
``:code

ビューの中のこのコードは、役に立つ情報を表示します。例えば、リクエスト、レスポンス、セッションに含まれるオブジェクト、そして同じタイミングで発行された全てのDBクエリなどです。

### 数えよう
``session``:inxx
今度は、同じ訪問者がこのページを何回表示したかを数えるカウンタを追加しましょう。

web2pyは、セッションとクッキーを使って自動的かつ透過的に訪問者を追跡します。新しい訪問者が来るたびに、セッションが作成されユニークな"session_id"が割り当てます。セッションはサーバ側に保存されている変数のためのコンテナです。一意のIDがクッキーを介してブラウザに送信されます。訪問者が同じアプリケーションから別のページをリクエストするとき、ブラウザはクッキーを送り戻し、そのクッキーはweb2pyによって取得され、対応するセッションが復元されます。

セッションを使用するには、デフォルトのコントローラを次のように変更します：
``
def index():
    if not session.counter:
        session.counter = 1
    else:
        session.counter += 1
    return dict(message="Hello from MyApp", counter=session.counter)
``:code

``counter``はweb2pyのキーワードではなく、``session``に保存される変数であることに注意してください。ここでは、sessionの中にcounter変数が存在するかチェックするようにweb2pyに求めます。存在しない場合は、それを作成し、1に設定します。存在すれば、counterを1増加させるようにweb2pyに求めます。最後に、ビューにcounterの値を渡します。

同じ機能をコードするためのよりコンパクトな方法を以下に示します：
``
def index():
    session.counter = (session.counter or 0) + 1
    return dict(message="Hello from MyApp", counter=session.counter)
``:code

そして、ビューを変更し、counterの値を表示するための行を追加します：
``
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
      <h2>Number of visits: {{=counter}}</h2>
   </body>
</html>
``:code

このページを再び(そして何回も)訪れると、次のようなHTMLのページが表示されます。

[[image @///image/en1300.png center 480px]]

このcounterは各訪問者と関連づけられ、訪問者がこのページをリロードするたびに増えていきます。異なる訪問者は異なるカウンタを見ることになります。

### 名前を名乗ろう
``form``:inxx ``request.vars``:inxx

ここでは、2つのページ(firstとsecond)を作成します。firstページはフォームを作成し、訪問者の名前を尋ね、secondページへリダイレクトします。secondページは訪問者に名前で挨拶します。

[[yUML diagram @///image/en1400.png center 293px]]

デフォルトのコントローラに、対応するアクションを書きます：
``
def first():
    return dict()

def second():
    return dict()
``:code

次に、firstアクションに対する"default/first.html"ビューを作成し、
以下を入力します：
``
{{extend 'layout.html'}}
What is your name?
<form action="second">
  <input name="visitor_name" />
  <input type="submit" />
</form>
``:code

最後に、secondアクションに対する"default/second.html"ビューを作成します：
``
{{extend 'layout.html'}}
<h1>Hello {{=request.vars.visitor_name}}</h1>
``:code

``layout``:inxx
両方のビューにおいて、web2pyに用意されている基本的な"layout.html"ビューが拡張されています。このレイアウト・ビューは、2つのページのルック＆フィールの一貫性を保ちます。レイアウト・ファイルは主にHTMLコードにより構成されているので、簡単に編集や置き換えができます。

firstページを開いて、あなたの名前を入力してください：

[[image @///image/en1500.png center 480px]]

そして、フォームを送信（submit）してください。すると、挨拶が表示されます：

[[image @///image/en1600.png center 480px]]

### ポストバック（Postbacks）
``redirect``:inxx ``URL``:inxx ``postback``:inxx

先に使用したフォームのサブミットに関するメカニズムはとても一般的なものです。しかし、これはあまり良いプログラミング練習ではありません。すべてのインプットは検証されるべきですが、上記の例では、検証の責任はsecondアクションに負っています。つまり、検証を行うアクションはフォームを生成したアクションと異なります。これは、コードの冗長性を引き起こしがちになります。

フォーム送信のためのより良いパターンは、フォームを生成したのと同じアクションに、今回の例では"first"にフォームを送信（sumbit）することです。"first"アクションは、変数を受け取り、処理し、サーバーサイドに保存し、訪問者を"second"ページにリダイレクトします。リダイレクト先でその変数を取得します。 このメカニズムは、``ポストバック（postback）``と呼ばれます。

[[yUML diagram @///image/en1700.png center 293px]]

デフォルトのコントローラを自己サブミット（self-submission）するように変更してみましょう：
``
def first():
    if request.vars.visitor_name:
        session.visitor_name = request.vars.visitor_name
        redirect(URL('second'))
    return dict()

def second():
    return dict()
``:code

"default/first.html"ビューは次のように変更します：
``
{{extend 'layout.html'}}
What is your name?
<form>
  <input name="visitor_name" />
  <input type="submit" />
</form>
``:code

"default/second.html"ビューは、``request.vars``の代わりに``session``からデータを取得する必要があります：
``
{{extend 'layout.html'}}
<h1>Hello {{=session.visitor_name or "anonymous"}}</h1>
``:code

訪問者から見ると、この自己サブミットは、前の実装と全く同じ挙動をしています。検証（validation）はまだ加えていませんが、検証がfirstアクションで行われるようになることは明白です。

このアプローチはより優れています。なぜなら、訪問者の名前はセッション内に留まるようになり、明示的に渡されなくてもアプリケーションのすべてのアクションとビューからアクセスできるようになるからです。

訪問者の名前が設定される前に"second"アクションが呼び出された場合、画面上には"Hello anonymous"と表示されることに注意してください。これは、``session.visitor_name``が``None``を返すからです。もう一つの方法は、コントローラ(``second``関数内)に次のコードを追加することです：

``
if not request.function=='first' and not session.visitor_name:
    redirect(URL('first'))
``:code

これはコントローラに認証を強制するために使用できる一般的なメカニズムです。ただし、より強力な方法のためには第9章を参照してください。

``FORM``:inxx ``INPUT``:inxx ``requires``:inxx ``IS_NOT_EMPTY``:inxx ``accepts``:inxx

web2pyではもう一歩先に進むことができ、検証を含むフォームをweb2pyに生成させることができます。web2pyはHTMLタグと同じ名前を持つヘルパー(FORM, INPUT, TEXTAREA,  SELECT/OPTION)を提供します。これらを利用して、コントローラとビューのどちらにおいても、フォームを構築することができます。

例として、firstアクションを書き換えるひとつの可能な方法を示します：
``
def first():
    form = FORM(INPUT(_name='visitor_name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
``:code

ここで、FORMタグには2つのINPUTタグが含まれているのが分かります。inputタグの属性は、アンダースコアで始まる名前付きの引数で指定されます。``requires``引数はタグの属性ではありません(アンダースコアで始まってないからです)。これはvisitor_nameの値のためのバリデータ（validator）を設定します。

同じフォームを作成するもっと別の良い方法があります。

``
def first():
    form = SQLFORM.factory(Field('visitor_name', requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
``:code

``form``オブジェクトは、"default/first.html"ビューにそれを埋め込むによって、簡単にHTMLとしてシリアライズすることができます。
``
{{extend 'layout.html'}}
What is your name?
{{=form}}
``:code

``form.process()``メソッドはバリデータを適用して自分自身のフォームに戻ってきます。``form.accepts``変数は、フォームが処理されて検証を通った場合 True に設定されます。自己サブミットしたフォームが検証を通った場合、セッション内に変数が保存され、前と同じようにリダイレクトされます。フォームが検証に通らなかった場合、エラーメッセージがフォームに挿入され、次のようにユーザーに示されます：

[[image @///image/en1800.png center 480px]]

次節では、どのようにフォームがモデルから自動的に生成されるかを示します。

### 画像ブログ
``upload``:inxx

ここでは、別の例として、管理者が画像を投稿して名前を付け、Webサイトの訪問者が画像を表示してコメントを送信できるようなWebアプリケーションを作成します。

前と同様に、**admin**にある**site**ページで``images``という名前の新しいアプリケーションを作成し、``edit``ページへ移ってください：

[[image @///image/en1900.png center 480px]]

まずモデルを作成するところから始めます。モデルは、アプリケーション内の永続的なデータ(アップロードする画像、その名前、コメント)の表現です。初めに、モデルを作成/編集するためのファイルを作成します。余り深く考えず、このファイルは"db.py"とします。以下に示すコードは、db.py内の全ての既存のコードを置き換えることを想定します。モデルとコントローラは、Pythonコードなので``.py``拡張子を持つ必要があります。拡張子が指定されていない場合、web2pyによって追加されます。ビューは``.html``拡張子を代わりに持ちます。主にHTMLコードで構成されるからです。

"db.py"ファイルを、対応する"edit"ボタンをクリックして編集します：

[[image @///image/en2000.png center 480px]]

そして次のように入力してください：

``IS_EMAIL``:inxx ``IS_NOT_EMPTY``:inxx ``IS_IN_DB``:inxx
``
db = DAL("sqlite://storage.sqlite")

db.define_table('image',
   Field('title', unique=True),
   Field('file', 'upload'),
   format = '%(title)s')

db.define_table('comment',
   Field('image_id', db.image),
   Field('author'),
   Field('email'),
   Field('body', 'text'))

db.image.title.requires = IS_NOT_IN_DB(db, db.image.title)
db.comment.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
db.comment.author.requires = IS_NOT_EMPTY()
db.comment.email.requires = IS_EMAIL()
db.comment.body.requires = IS_NOT_EMPTY()

db.comment.image_id.writable = db.comment.image_id.readable = False
``:code

行を一つ一つ分析してみましょう。

1行目はdbと呼ばれるグローバル変数を定義します。``db``はデータベース接続を表します。この場合、"applications/images/databases/storage.db"ファイルに保存されるSQLiteデータベースへの接続です。SQLiteの場合は、データベースが存在しない場合は、新たに作成されます。このファイルの名前は、グローバル変数``db``の名前と同じように、変更することができます。しかし、覚えやすくするために、同じ名前にしておいた方が便利です。

3～5行目は、"image"テーブルを定義しています。``define_table``は、``db``オブジェクトのメソッドです。最初の引数"image"は、定義したテーブルの名前です。他の引数はこのテーブルに属するフィールドです。このテーブルは、"title"というフィールド、"file"というフィールド、主キーとして機能する"id"というフィールドを持ちます("id"は明示的に宣言されません。すべてのテーブルはidフィールドをデフォルトで持つからです)。"title"フィールドは文字列であり、"file"フィールドはupload型です。uploadは、web2pyのデータ抽象化レイヤ(DAL)によって使用される特殊な型で、アップロードされたファイルの名前を保持します。web2pyは、ファイルのアップロード(サイズが大きいとストリーミングを介します)、ファイルの安全なリネーム、ファイルの保存をうまく行うことができます。

テーブルが定義されるとき、web2pyは以下に示すいくつかの可能なアクションのどれかひとつを取ります：
- テーブルが存在しない場合、テーブルが作成されます。
- テーブルが存在するが、その定義に対応していない場合、テーブルは定義に沿ってに変更されます。フィールドが異なる型を持つ場合、web2pyはその内容を変更しようと試みます。
- テーブルが存在し、その定義に対応する場合、web2pyは何もしません。

この挙動は、"マイグレーション（migration）"と呼ばれます。web2pyではマイグレーションは自動的に行われます。しかし``migrate=False``を``define_table``の最後の引数に渡すことによって、テーブル毎にこれを無効にすることができます。

6行目はテーブルに対して文字列書式を定義しています。レコードが文字列としてどのように表現されるのかを決定します。``format``引数には、レコードを受け取り文字列を返す関数を指定することもできます。次に例を示します。

``
format=lambda row: row.title
``:code

8～12行目では、"comment"と呼ばれるテーブルを定義しています。
コメントは、"author"フィールド、"email"フィールド(コメントの作者のメールアドレスを保存します)、"text"型の"body"フィールド(その作者によって送信された実際のコメントを保存するために使用します)、idフィールドを介して``db.image``を指す参照型の"image_id"フィールドを持ちます。

14行目では、``db.image.title``は"image"テーブルの"title"フィールドであることを表します。``requires``属性は、web2pyフォームによって強制されることになる要求/制約を設定することを可能にします。ここでは、"title"は一意であることを要求します：

``IS_NOT_IN_DB(db, db.image.title)``:code

これは、``Field('title', unique=True)``の指定により自動的に設定されているので、任意指定となります。

これらの制約を表現するオブジェクトはバリデータと呼ばれます。複数のバリデータは、リストにおいてグループ化できます。バリデータは表示されている順序で実行されます。
``IS_NOT_IN_DB(a, b)``は特殊なバリデータです。これは、新規レコードに対する``b``フィールドの値が、``a``の中にすでに入っていないかをチェックします。

15行目は、"comment"テーブルの"image_id"フィールドが``db.image.id``に存在することを要求します。データベースに関する限り、"comment"テーブルを定義した時点で、これはすでに宣言されています。
ここではさらに、明示的に、この制約がweb2pyによって強制されることをモデルに知らせています。この制約は、新規のコメントが送信されたとき、フォーム処理のレベルで強制されます。その結果、不正な値は入力フォームからデータベースへ伝搬しません。ここではまた、"image_id"が対応するレコードの"title"、``'%(title)s'``によって表現されるように要求しています。

20行目は、``writable=False``で、"comment"テーブルの"image_id"フィールドがフォームに表示されないように指示しています。さらに、``readable=False``で、読み取り専用フォームでも表示されないようにしています。

15～17行目のバリデータの意味は明らかです。

``format``:inxx
なお、次のバリデータは、

``
db.comment.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
``:code

次のように、imageを表現するフォーマットを指定した場合、(自動的に)無視されます：
``
db.define_table('image', ..., format='%(title)s')
``:code

ここで、フォーマットは文字列、または、レコードを受け取り文字列を返す関数にすることができます。

``appadmin``:inxx
一旦モデルが定義されると、エラーがない場合、web2pyはデータベースを管理するためのアプリケーションの管理インターフェイスを作成します。このインターフェイスには、``edit``ページの"database administration"リンクからから、直接以下のURLからアクセスします。
``
http://127.0.0.1:8000/images/appadmin
``:code

これは、**appadmin**インターフェイスのスクリーンショットです：

[[image @///image/en2100.png center 480px]]

このインターフェイスは、"appadmin.py"というコントローラと対応する"appadmin.html"ビューにおいて実装されています。以降、このインターフェイスを単に``appadmin``と呼びます。これにより、管理者は新規のデータベースレコードを挿入し、既存のレコードを編集、削除し、テーブルを閲覧し、データベースの結合(join)を行うことができるようになります。

**appadmin**に最初にアクセスしたときに、モデルが実行されテーブルが作成されます。web2pyのDALは、選択したデータベース・バックエンド(この例ではSQLite)固有のSQL文にPythonコードを変換します。生成されたSQLは、``edit``ページから"models"の下にある"sql.log"リンクをクリックして、見ることができます。ただし、テーブルが作成されるまでリンクは現れません。

[[image @///image/en2200.png center 480px]]

モデルを編集し、再び**appadmin**にアクセスしようとする場合、web2pyは既存のテーブル修正するSQLを生成します。生成されたSQLは"sql.log"にログとして記録されます。

さて、**appadmin**に戻って、新しい画像レコードを挿入してみましょう：

[[image @///image/en2300.png center 480px]]

web2pyは、``db.image.file``の"upload"フィールドを、ファイルをアップロードするためのフォームに変換します。フォームがサブミットされ、画像がアップロードされるとき、ファイルは、安全な方法で拡張子はそのままにリネームされ、アプリケーションの"uploads"フォルダの下に新しい名前で保存されます。新しい名前は``db.image.file``フィールドに保存されます。この処理は、ディレクトリトラバーサル攻撃を防ぐために設計されています。

なお、各フィールドの型はウィジェット(``widget``)によってレンダリングされています。デフォルトのウィジェットはオーバーライドすることができます。

``appdamin``においてテーブル名をクリックすると、web2pyは現在のテーブルのすべてのレコードの選択を実行します。これは、次のDALクエリで特定されます
``
db.image.id > 0
``:code

その結果は次のようにレンダリングされます。

[[image @///image/en2400.png center 480px]]

SQLクエリを編集し[Submit]ボタンを押して、異なるレコードセットを選択することができます。

単一のレコードを編集、または、削除するには、レコードのid番号をクリックします。

``IS_IN_DB``バリデータのおかげで、"image_id"参照フィールドはドロップダウンのメニューでレンダリングされます。ドロップダウンの項目はキー(``db.image.id``)として格納されますが、バリデータで指定したように、``db.image.title``によって表現されます。

バリデータは強力なオブジェクトです。これは、どのようにフィールドを表現し、フィールドの値をフィルタし、エラーを生成し、フィールドから取り出した値をフォーマットするかを知っています。

次の図は、検証を通らないフォームをサブミットしたときに何が起こるかを示しています：

[[image @///image/en2500.png center 480px]]

**appadmin**によって自動生成されたものと同じフォームは、``SQLFORM``ヘルパーを介してプログラム的に生成し、ユーザのアプリケーションに埋め込むことができます。これらのフォームは、CSSフレンドリで、カスタマイズすることができます。

すべてのアプリケーションには**appadmin**が存在します。したがって、**appadmin**自体、他のアプリケーションに影響を与えずに変更することができます。

ここまで、アプリケーションがデータを保存する方法、**appadmin**を介してどのようにデータベースにアクセスするかを見てきました。**appadmin**へのアクセスは管理者に対して制約されていて、アプリケーションのための本番用のwebインターフェイスとして意図されたものではありません。したがって、このウォークスルーの次のパートがあります。具体的には、次のものを作成します：
- "index"ページ。これは、すべての利用可能な画像をtitleでソートして一覧表示します。そして、それらの画像に詳細ページへのリンクを張ります。
- "show/[id]"ページ。これは、リクエストされた画像を訪問者に提示します。そして、コメントを見たり投稿したりできるようにします。
- "download/[name]"アクション。アップロードした画像をダウンロードするために用いられます。

これはその図式です：

[[yUML diagram @///image/en2600.png center 480px]]

``edit``ページに戻り、"default.py"コントローラを編集し、その内容を次のものと入れ替えてください：

``select``:inxx
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)
``:code

このアクションは、辞書を返します。辞書の項目のキーは、アクションに関連付けられたビューに渡される変数として解釈されます。開発中は、ビューが存在しない場合、アクションは"generic.html"ビューにより表示されます。これは、すべてのweb2pyアプリケーションで用意されています。

indexアクションは、``db.image.title``のよってソートされた、imageテーブルからのすべてのフィールド(``db.image.ALL``)の選択を実行します。選択の結果はレコードを格納する``Rows``オブジェクトです。これを、アクションによってビューへ返される``images``と呼ばれるローカル変数に割り当てます。``images``は、反復可能（iterable）で、その要素は選択された行になります。各行において、カラムは辞書のように、つまり、``images[0]['title']``のように、アクセスできます。また同様に、``images[0].title``のようにもアクセスできます。
``images[0]['title']`` or equivalently as ``images[0].title``.

ビューを記述しない場合、辞書は"views/generic.html"によってレンダリングされます。indexアクションの呼び出しは次のように表示されます：

[[image @///image/en2700.png center 480px]]

まだアクションのビューが作成されていないので、web2pyはレコードをシンプルな表形式で表示しています。

では、indexアクション用のビューを作成します。adminに戻り、"default/index.html"を編集して、その内容を次のように置き換えます：
``
{{extend 'layout.html'}}
<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
``:code

最初に注目する点は、ビューが特別な{{...}}タグを持つ純粋なHTMLということです。{{...}}に埋め込まれたコードは純粋なPythonのコードです。ただし、インデントが無意味になるという注意があります。コードのブロックは、行末にコロン(:)がついた行で始まり、``pass``というキーワードで始まる行で終わります。ブロックの終わりが明らかな場合には、``pass``は不要です。

5～7行目は、imagesの行をループで回し、各行の画像に対し次のように表示します：
``
LI(A(image.title, _href=URL('show', args=image.id))
``:code

これは、``image.title``を含む``<a href="...">...</a>``タグを含んだ``<li>...</li>``タグになります。ハイパーテキスト参照(href属性)の値は次のようになります：
``
URL('show', args=image.id)
``:code

つまり、これは、"show"という関数を呼んでいる現在のリクエストと同じアプリケーションとコントローラの範囲内にあるURLで、かつ、その関数に単一の引数``args=images.id``を渡すようなURLです。
``LI``、``A``などはweb2pyのヘルパーで、対応するHTMLタグをマッピングします。無名引数はシリアライズされるオブジェクトとして解釈され、そのタグのinnerHTMLにて挿入されます。アンダースコアで始まる名前付き引数(例えば``_href``)はそのタグの属性として解釈されます。ただし、アンダースコアは付かない属性です。たとえば、``_href``は``href``属性、``_class``は``class``属性、などになります。

例として、次の文は：
``
{{=LI(A('something', _href=URL('show', args=123))}}
``:code

次のようにレンダリングされます：
``
<li><a href="/images/default/show/123">something</a></li>
``:code

少数のヘルパ(``INPUT``, ``TEXTAREA``, ``OPTION`` and ``SELECT``)はまた、アンダースコアで始まらない特別な名前付き引数(``value``と``requires``)をサポートしています。これらはカスタムフォームを構築するために重要で、後で説明します。

``edit``ページに戻ってください。すると、"default.py exposes index"というものが示されます。"index"をクリックして、新しく作成したページを訪れることができます：
``
http://127.0.0.1:8000/images/default/index
``:code

これは次のように表示されます：

[[image @///image/en2800.png center 480px]]

画像名のリンクをクリックすると、次に遷移します：
``
http://127.0.0.1:8000/images/default/show/1
``:code

これはエラーになります。なぜなら、"default.py"コントローラには"show"というアクションがまだ作成されていないからです。

"default.py"コントローラを編集して、その内容を次のものと置き換えてみましょう：

``SQLFORM``:inxx ``accepts``:inxx ``response.flash``:inxx ``request.args``:inxx
``response.download``:inxx
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)

def show():
    image = db(db.image.id==request.args(0)).select().first()
    db.comment.image_id.default = image.id
    form = SQLFORM(db.comment)
    if form.process().accepted:
        response.flash = 'your comment is posted'
    comments = db(db.comment.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)

def download():
    return response.download(request, db)
``:code

このコントローラは、"show"と"download"の2つのアクションを保持しています。
"show"アクションは、request.argsから解析された``id``を持つ画像と、その画像に関連するすべてのコメントを選択します。そして、すべてを"default/show.html"ビューに渡します。

画像のidは、次のようにして：
``
URL('show', args=image.id)
``:code

"default/index.html"ビューにおいて参照され、"show"アクションにおいて：
``request.args(0)``
からアクセスすることができます。

"download"アクションは、``request.args(0)``にファイル名を要求します。そして、ファイルがあるはずの場所へのパスを構築し、クライアントにそのファイルを返します。ファイルが大きすぎる場合、いかなるメモリのオーバーヘッドも発生しないように、ファイルをストリーミングします。

以下の文（statement）について注意してください：
- 7行目は、指定したフィールドだけを用いて、``db.comment``テーブルに対するフォーム、SQLFORMを作成します。
- 8行目は、参照フィールドの値を設定します。これは入力フォームの一部ではありません。なぜなら、上で指定したフィールドのリストにないからです。
- 9行目は、現在のセッションの中で(セッションは二重送信の防止とナビゲーションの実施のために使われます)、サブミットされたフォーム(サブミットされたフォームの変数は``request.vars``にあります)を処理します。サブミットされたフォームの変数が検証を通った場合、``db.comment``テーブルに新規のコメントが挿入されます。そうでない場合、フォームはエラーメッセージを含むように修正されます(たとえば、作者のメールアドレスが不適当である場合)。これは、すべての9行目で行われます！
- 10行目は、フォームが受理された場合にのみ、データベース・テーブルにレコードが挿入された後に実行されます。``response.flash``は、web2pyの変数で、ビューにおいて表示され、訪問者に何が行われたのかを通知するために使われます。
- 11行目は、現在の画像に関するすべてのコメントを選択します。
-------
（訳注：この節は原文が次の第３版の古いstatementに対応している。あえて第３版のコードをここに併記しておく。）
7.    form = SQLFORM(db.comment)
8.    form.vars.image_id = image.id
9.    if form.accepts(request.vars, session):
10.       response.flash = 'your comment is posted'
11.   comments = db(db.comment.image_id==image.id).select()
-------
-------
"download"アクションは、雛形アプリケーションの"default.py"コントローラにおいてすでに定義されています。
-------

"download"アクションは辞書を返さないので、ビューは必要ありません。一方、"show"アクションはビューを持つべきです。したがって、**admin**に戻って"default/show.html"という新規のビューを作成してください。

この新規のファイルを編集し、その内容を次のものと置き換えてください：
``
{{extend 'layout.html'}}
<h1>Image: {{=image.title}}</h1>
<center>
<img width="200px"
     src="{{=URL('download', args=image.file)}}" />
</center>
{{if len(comments):}}
  <h2>Comments</h2><br /><p>
  {{for comment in comments:}}
    <p>{{=comment.author}} says <i>{{=comment.body}}</i></p>
  {{pass}}</p>
{{else:}}
  <h2>No comments posted yet</h2>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
``:code

このビューは、``<img ... />``タグ内において、"download"アクションを呼び出すことによって**image.file**を表示します。
コメントがある場合は、それらに対してループを回し、一つ一つ表示します。

どのようにすべてが表示されるかを以下に示します：

[[image @///image/en2900.png center 480px]]

訪問者がこのページでコメントを送信すると、コメントがデータベースに保存され、ページの下部に追加されます。

### CRUDを追加しよう

web2pyはまた、フォームをさらに単純化するCRUD(Create/Read/Update/Delete)APIを提供します。CRUDを使用するには、"db.py"ファイルなど、どこかにそれを定義する必要があります：
``
from gluon.tools import Crud
crud = Crud(db)
``:code

-------
これら2つの行は、すでに雛形アプリケーションに含まれています。
-------

``crud``オブジェクトは高レベルのメソッドを提供します。例えば：
``
form = crud.create(table)
``:code

これは、次のプログラミング・パターンを置き換えるために使用することができます：
``
form = SQLFORM(table)
if form.process().accepted:
    session.flash = '...'
    redirect('...')
``:code

前回の"show"アクションを、crudを用いてより改良して書き換えてみます：

``
def show():
    image = db.image(request.args(0)) or redirect(URL('index'))
    db.comment.image_id.default = image.id
    form = crud.create(db.comment,
                       message='your comment is posted',
                       next=URL(args=image.id))
    comments = db(db.comment.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)
``:code

初めに、次のような構文を用いていることに注意してください

``
db.image(request.args(0)) or redirect(...)
``:code

これにより、要求されたレコードが取り出されます。``table(id)``は、レコードが見つからない場合にNoneを返します。したがって、``or redirect(...)``を同じ行に書くようにします。

``crud.create``の``next``引数は、フォームが受理された後にリダイレクトする先のURLです。``message``引数は受理されたときに表示されるものです。CRUDについては第7章でより詳しく説明します。

### 認証を追加しよう

web2pyのロールベースのアクセス制御APIは非常に洗練されています。ただし、ここではshowアクションへのアクセスを認証されたユーザのみに限定する説明だけにし、残りの詳しい説明は第9章に委ねます。

認証されたユーザにのみアクセスを限定するには、3つのステップを完了する必要があります。モデル（たとえば"db.py"）では、以下を追加する必要があります：
``
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables()
``:code

コントローラでは、次の1つのアクションを追加する必要があります：
``
def user():
    return dict(form=auth())
``:code

こうするだけで、ログイン、登録、ログアウトなどが可能になります。デフォルトのレイアウトはまた、対応するページへのオプションを右上隅に表示します。

[[image @///image/en3000.png center 300px]]

こうすることで、制限したい関数を次のようにデコレート（decorate）することができます：
``
@auth.requires_login()
def show():
    image = db.image(request.args(0)) or redirect(URL('index'))
    db.comment.image_id.default = image.id
    form = crud.create(db.comment, next=URL(args=image.id),
                     message='your comment is posted')
    comments = db(db.comment.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)
``:code

次のアドレスへのいかなるアクセスも
``
http://127.0.0.1:8000/images/default/show/[image_id]
``:code

ログインが要求されます。ユーザーがログインしていない場合は、次のアドレスにリダイレクトされます。
``
http://127.0.0.1:8000/images/default/user/login
``:code

[[image @///image/en3100.png center 480px]]

``user``関数はまた、とりわけ次のようなアクションも公開します：
``
http://127.0.0.1:8000/images/default/user/logout
http://127.0.0.1:8000/images/default/user/register
http://127.0.0.1:8000/images/default/user/profile
http://127.0.0.1:8000/images/default/user/change_password
http://127.0.0.1:8000/images/default/user/request_reset_password
http://127.0.0.1:8000/images/default/user/retrieve_username
http://127.0.0.1:8000/images/default/user/retrieve_password
http://127.0.0.1:8000/images/default/user/verify_email
http://127.0.0.1:8000/images/default/user/impersonate
http://127.0.0.1:8000/images/default/user/not_authorized
``:code

このとき、ログインして、コメントを読み、投稿するために、ユーザーは最初に登録する必要があります。

-------
``auth``オブジェクトと``user``関数の両方は雛形アプリケーションですでに定義されています。``auth``オブジェクトは、高度にカスタマイズ可能で、emailによる照合、登録の承認、CAPTHCA、プラグインを介したログインメソッドの変更を行うことができます。
-------

#### グリッドの追加

管理インターフェイスを作成するための``SQLFORM.grid``と``SQLFORM.smartgrid``の二つのガジェットは、作成したアプリケーションをさらに向上させます。

``
@auth.requires_membership('manager')
def manage():
    grid = SQLFORM.smartgrid(db.image)
    return dict(grid=grid)
``:code

関連する"views/default/manage.html"です。

``
{{extend 'layout.html'}}
<h2>Management Interface</h2>
{{=grid}}
``

appadminを使用して"manager"グループを作成し、さらにそのグループにいくつかのユーザーメンバーを作成します。このメンバーは以下のURLにアクセスできます。（訳注：この行の原文にあるnotは誤りと解釈して訳しています。）

``
http://127.0.0.1:8000/images/default/manage
``

ブラウジングや検索もできます。

[[image @///image/en3200.png center 480px]]

画像の追加、更新、削除、そして画像へのコメントが行なえます。

[[image @///image/en3300.png center 480px]]

### レイアウトの設定

"views/layout.html"を編集してデフォルトのレイアウトを設定することができます。しかし、HTMLを編集しなくても設定することができます。実際、"static/base.css"のスタイルシートは、よく文章化されていて、第5章において説明されています。HTMLを編集せずに、色、カラム数、サイズ、枠線、背景を変更することができます。メニュー、タイトル、サブタイトルを編集したい場合は、任意のモデルファイルでそれを行うことができます。雛形のアプリは、"models/menu.py"ファイルにおいて、以下のパラメータのデフォルト値を設定します：

``
response.title = request.application
response.subtitle = T('customize me!')
response.meta.author = 'you'
response.meta.description = 'describe your app'
response.meta.keywords = 'bla bla bla'
response.menu = [ [ 'Index', False, URL('index') ] ]
``:code

### Wiki
``wiki``:inxx ``RSS``:inxx ``Ajax``:inxx ``XMLRPC``:inxx
このセクションでは、wikiをスクラッチから構築します。第13章で説明するplugin_wikiによって提供される拡張機能は使用しません。訪問者は、ページの作成、(タイトルによる)検索、編集を行うことができます。 訪問者は、コメントを(前回のアプリケーションと全く同様に)投稿することができ、また、(ページへ添付する形で)文章も投稿することができ、ページからその文章にリンクを張ることができるようになります。慣例として、ここではWiki構文のためにMarkmin構文を採用します。ここではまた、Ajaxを用いた検索ページ、そのページに対するRSSフィード、XML-RPC``xmlrpc``:citeを介したページ検索用のハンドラ、を実装します。

次の略図は、実装が必要なアクションと、それらの間で構築すべきリンクを列挙しています。

[[yUML diagram @///image/en3400.png center 250px]]

"mywiki"という名の新規の雛形アプリを作成して始めましょう。

モデルはページ(page)、コメント(comment)、文章(document)という3つのテーブルを持つ必要があります。commentとdocumentの両者はpageを参照します。それらはpageに属しているからです。documentは、前回の画像アプリケーションのように、upload型のファイル・フィールドを持ちます。

以下にすべてのモデルを示します：
``
db = DAL('sqlite://storage.sqlite')

from gluon.tools import *
auth = Auth(db)
auth.define_tables()
crud = Crud(db)

db.define_table('page',
    Field('title'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', db.auth_user, default=auth.user_id),
    format='%(title)s')

db.define_table('comment',
    Field('page_id', db.page),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', db.auth_user, default=auth.user_id))

db.define_table('document',
    Field('page_id', db.page),
    Field('name'),
    Field('file', 'upload'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', db.auth_user, default=auth.user_id),
    format='%(name)s')

db.page.title.requires = IS_NOT_IN_DB(db, 'page.title')
db.page.body.requires = IS_NOT_EMPTY()
db.page.created_by.readable = db.page.created_by.writable = False
db.page.created_on.readable = db.page.created_on.writable = False

db.comment.body.requires = IS_NOT_EMPTY()
db.comment.page_id.readable = db.comment.page_id.writable = False
db.comment.created_by.readable = db.comment.created_by.writable = False
db.comment.created_on.readable = db.comment.created_on.writable = False

db.document.name.requires = IS_NOT_IN_DB(db, 'document.name')
db.document.page_id.readable = db.document.page_id.writable = False
db.document.created_by.readable = db.document.created_by.writable = False
db.document.created_on.readable = db.document.created_on.writable = False
``:code

"default.py"コントローラを編集し、以下のアクションを作成してください：
- index: すべてのwikiページを列挙する
- create: 別のwikiページを投稿する
- show: wikiページとそのコメントを表示し、コメントを追加する
- edit: 既存のページを編集する
- documents: ページに添付された文書を管理する
- download: (images（訳注：この章で説明されたサンプル・アプリ）の例のように)文章をダウンロードする
- search: 検索用のボックスを表示し、Ajaxコールバックを介して、訪問者が入力したタイトルに該当するもの全てを返す
- callback: Ajax用のコールバック関数。訪問者の入力に合わせて、検索ページに埋め込まれるHTMLを返す

これは"default.py"コントローラです：
``
def index():
     """ this controller returns a dictionary rendered by the view
         it lists all wiki pages
     >>> index().has_key('pages')
     True
     """
     pages = db().select(db.page.id,db.page.title,orderby=db.page.title)
     return dict(pages=pages)

@auth.requires_login()
def create():
     "creates a new empty wiki page"
     form = crud.create(db.page, next=URL('index'))
     return dict(form=form)

def show():
     "shows a wiki page"
     this_page = db.page(request.args(0)) or redirect(URL('index'))
     db.comment.page_id.default = this_page.id
     form = crud.create(db.comment) if auth.user else None
     pagecomments = db(db.comment.page_id==this_page.id).select()
     return dict(page=this_page, comments=pagecomments, form=form)

@auth.requires_login()
def edit():
     "edit an existing wiki page"
     this_page = db.page(request.args(0)) or redirect(URL('index'))
     form = crud.update(db.page, this_page,
                        next=URL('show',args=request.args))
     return dict(form=form)

@auth.requires_login()
def documents():
     "browser, edit all documents attached to a certain page"
     page = db.page(request.args(0)) or redirect(URL('index'))
     db.document.page_id.default = page.id
     db.document.page_id.writable = False
     grid = SQLFORM.grid(db.document.page_id==page.id,args=[page.id])
     return dict(page=page, grid=grid)

def user():
     return dict(form=auth())

def download():
     "allows downloading of documents"
     return response.download(request, db)

def search():
     "an ajax wiki search page"
     return dict(form=FORM(INPUT(_id='keyword',_name='keyword',
              _onkeyup="ajax('callback', ['keyword'], 'target');")),
              target_div=DIV(_id='target'))

def callback():
     "an ajax callback that returns a <ul> of links to wiki pages"
     query = db.page.title.contains(request.vars.keyword)
     pages = db(query).select(orderby=db.page.title)
     links = [A(p.title, _href=URL('show',args=p.id)) for p in pages]
     return UL(*links)
``:code


2～6行目は、indexアクションのコメントを提供します。コメント内にある4～5行目は、テストコード(doctest)としてpythonによって解釈されます。テストは管理インターフェイスから実行できます。この場合、テストはindexアクションがエラーなしで実行されることを検証します。

18、27、35行目は、``request.args(0)``のidを持つ``page``レコードを取り出そうと試みます。

13、20行目は、それぞれ新規ページ、新規コメントのための作成フォームを定義し処理します。

28行目は、wikiページのための更新フォームを定義し処理します。

38行目は、ブラウザ上でこのページにリンクしているコメントの追加と更新を行なうことを許可する``grid``の作成を行なっています。

51行目はいくつかの魔法が起こっています。"keyword"というINPUTタグの``onkeyup``属性が設定されます。訪問者がキーを放すたびに、``onkeyup``属性内におけるJavaScriptコードが、クライアント側で、実行されます。そのJavaScriptコードは次の通りです：
``
ajax('callback', ['keyword'], 'target');
``:code

``ajax``は、"web2py.js"ファイルに定義されたJavaScript関数です。このファイルはデフォルトの"layout.html"によって組み込まれます。これは3つのパラメタをとります：同期的コールバックを実行するアクションのURL、コールバックに送る変数のIDリスト(["keyword"])、そして、レスポンスが挿入される場所のID("target")です。

検索ボックスに何かを打ち込みキーを放すとすぐに、クライアントはサーバーを呼び出し、'keyword'フィールドの内容を送信します。そして、サーバーが応答したら、そのレスポンスは'target'タグのinnerHTMLとしてページ自身に埋め込まれます。

'target'タグは52行目で定義されるDIVです。これはビューにおいても定義することができます。

これは"default/create.html"ビューのコードです：
``
{{extend 'layout.html'}}
<h1>Create new wiki page</h1>
{{=form}}
``:code

**create**ページを訪れると、次のように表示されます：

[[image @///image/en3500.png center 480px]]

"default/index.html"ビューのコードです：
``
{{extend 'layout.html'}}
<h1>Available wiki pages</h1>
[ {{=A('search', _href=URL('search'))}} ]<br />
<ul>{{for page in pages:}}
     {{=LI(A(page.title, _href=URL('show', args=page.id)))}}
{{pass}}</ul>
[ {{=A('create page', _href=URL('create'))}} ]
``:code

これは、次のページを生成します：

[[image @///image/en3600.png center 480px]]

"default/show.html"ビューのコードです：

``markdown``:inxx ``MARKMIN``:inxx
``
{{extend 'layout.html'}}
<h1>{{=page.title}}</h1>
[ {{=A('edit', _href=URL('edit', args=request.args))}}
| {{=A('documents', _href=URL('documents', args=request.args))}} ]<br />
{{=MARKMIN(page.body)}}
<h2>Comments</h2>
{{for comment in comments:}}
  <p>{{=db.auth_user[comment.created_by].first_name}} on {{=comment.created_on}}
          says <I>{{=comment.body}}</i></p>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
``:code

markimin構文の代わりにmarkdown構文を使用する場合、次のようにします：

``
from gluon.contrib.markdown import WIKI
``:code

そして、``MARKMIN``ヘルパの代わりに``WIKI``を使用してください。
また、markminの構文の代わりに生のHTMLを受け入れるように選択することができます。この場合、次のものを：
``
{{=MARKMIN(page.body)}}
``:code

次のものに置き換えます：
``
{{=XML(page.body)}}
``:code

``sanitize``:inxx
(デフォルトのweb2pyの挙動により、XMLではエスケープされません)

これは次のようにする方がより良いです：
``
{{=XML(page.body, sanitize=True)}}
``:code

``sanitize=True``と設定すると、 "<script>"タグのような安全でないXMLタグをエスケープするようにし、XSSの脆弱性を防ぎます。

これで、indexページからページタイトルをクリックすると、作成したページを見ることができます：

[[image @///image/en3700.png center 480px]]

"default/edit.html"ビューのコードです：
``
{{extend 'layout.html'}}
<h1>Edit wiki page</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
{{=form}}
``:code

これは、作成ページとほぼ同じページを生成します。

次は"default/documents.html"ビューのコードです：
``
{{extend 'layout.html'}}
<h1>Documents for page: {{=page.title}}</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
<h2>Documents</h2>
{{=grid}}
``:code

"show"ページでdocuments（訳注：ページ上部にあるリンクのこと）をクリックすると、ページに添付された文書を管理することができます。

[[image @///image/en3800.png center 480px]]

最後は"default/search.html"ビューのコードです：
``
{{extend 'layout.html'}}
<h1>Search wiki pages</h1>
[ {{=A('listall', _href=URL('index'))}}]<br />
{{=form}}<br />{{=target_div}}
``:code

これは、次のようなAjax検索フォームを生成します：

[[image @///image/en3900.png center 480px]]

たとえば次のURLに訪れることで、コールバックのアクションを直接呼び出すことも可能です：
``
http://127.0.0.1:8000/mywiki/default/callback?keyword=wiki
``:code

このページのソースコードを見ると、コールバックによって返された次のようなHTMLを見ることができます：
``
<ul><li><a href="/mywiki/default/show/4">I made a Wiki</a></li></ul>
``:code

``rss``:inxx
web2pyを用いて保存されたページからRSSフィードを生成することは簡単です。web2pyには``gluon.contrib.rss2``があるからです。単に、次のアクションをdefaultコントローラに追加してください：
``
def news():
    "generates rss feed form the wiki pages"
    reponse.generic_patterns = ['.rss']
    pages = db().select(db.page.ALL, orderby=db.page.title)
    return dict(
       title = 'mywiki rss feed',
       link = 'http://127.0.0.1:8000/mywiki/default/index',
       description = 'mywiki news',
       created_on = request.now,
       items = [
          dict(title = row.title,
               link = URL('show', args=row.id),
               description = MARKMIN(row.body).xml(),
               created_on = row.created_on
               ) for row in pages])
``:code

そして、次のページに訪れると
``
http://127.0.0.1:8000/mywiki/default/news.rss
``:code

フィードが表示されます(フィードリーダによって見た目は異なります)。なお、URLの拡張子が.rssなので、dictは自動的にRSSに変換されています。

[[image @///image/en4000.png center 480px]]

web2pyはまた、サードパーティのフィードを読むためのフィードパーサ（フィード解析）も含んでいます。

``XMLRPC``:inxx
最後に、プログラム的にwikiを検索可能にするXML-RPCハンドラを追加しましょう：
``
service = Service()

@service.xmlrpc
def find_by(keyword):
     "finds pages that contain keyword for XML-RPC"
     return db(db.page.title.contains(keyword).select().as_list()

def call():
    "exposes all registered services, including XML-RPC"
    return service()
``:code

ハンドラのアクションは、このリストで指定された関数を(XML-RPCを介して)単純に公開しています。ここでは、``find_by``です。``find_by``はアクションではありません(引数があるためです)。この関数は、``.select()``でデータベースに問い合わせ、``.response``でレコードをリストとして取り出し、そのリストを返します。

ここに、どのように外部のPythonプラグラムからXML-RPCハンドラにアクセスするかの例を示します。
``
>>> import xmlrpclib
>>> server = xmlrpclib.ServerProxy(
    'http://127.0.0.1:8000/mywiki/default/call/xmlrpc')
>>> for item in server.find_by('wiki'):
        print item['created_on'], item['title']
``:code

ハンドラは、XML-RPCを理解する多くのプログラミング言語(C、C++、C#、Javaなど)からアクセスすることができます。

#### ``date``、``datetime`` そして ``time`` の書式

``date``、``datetime`` そして ``time``のフィールドの型のそれぞれに、三つの異なる表現があります。
- データベースでの表現
- web2py内部での表現
- フォームやテーブルで使われる文字列表現

データベースの表現は、内部の問題であり、コードには影響しません。web2pyの内部では、それぞれ``datetime.date``、``datetime.datetime``そして``datetime.time``というオブジェクトの表現で保存されています。そして次のように操作することができます。

``
for page in db(db.page).select():
    print page.title, page.day, page.month, page.year
``

フォームの中で日付が文字列に変換される場合、次のISOの表現に従って変換されます。
``
%Y-%m-%d %H:%M:%S
``

この表現は国際化が行なわれていますが、この表現を別のものに変更するためにadminの翻訳ページを使用することもできます。

``
%m/%b/%Y %H:%M:%S
``

------
デフォルトでは、web2pyはアプリケーションが既に英語で書かれていると想定しているため、英語は翻訳されません。英語用の国際化の機能を有効にしたい場合には、（adminを使用して）翻訳ファイルを作成する必要があります。そして、アプリケーションが現在の言語が英語以外であることを、次のように宣言する必要があります。
``
T.current_languages = ['null']
``
------

### **admin**の追加情報
``admin``:inxx

管理インターフェイスはさらなる機能を提供します。ここではそれを簡単に見ていきます。

#### ''サイト''
``site``:inxx

このページはインストールされたすべてのアプリケーションを列挙します。下部には2つのフォームがあります。

1つ目のフォームでは、名前を指定して新しいアプリケーションを作成することができます。

``Instant Press``:inxx
2つ目のフォームでは、ローカルファイルまたはリモートURLから、既存のアプリケーションをアップロードすることができます。アプリケーションをアップロードする場合は、その名前を指定する必要があります。元の名前と同じにすることができますが、同じである必要はありません。これにより、同じアプリケーションの複数のコピーをインストールすることができます。たとえば、Martin Muloneによって作られたInstant Press CMSを次のURLからアップロードすることができます：

``
http://code.google.com/p/instant-press/
``:code

------
web2pyのファイルは``.w2p``ファイルにパッケージングされます。これはgzip圧縮されたファイルをtarでまとめたです。web2pyでは、ブラウザでダウンロード時にファイルが解凍されるのを防ぐため、拡張子``.tgz``の代わりに拡張子``.w2p``を使います。これらは、``tar zxvf [ファイル名]``として、手動で解凍することができます。ただし、その必要は全くありません。
------

[[image @///image/en4100.png center 444px]]

アップロードに成功すると、 web2pyはアップロードしたファイルのMD5チェックサムを表示します。これにより、ファイルがアップロード中に破損していないことを確認することができます。InstantPressの名前がインストールされたアプリケーションのリストに表示されます。

adminにあるInstantPressの名前をクリックすると、起動して稼働します。

[[image @///image/en4200.png center 480px]]

Instant Pressに関するより詳しい情報は、以下のURLで読むことができます。
``
http://code.google.com/p/instant-press/
``

各アプリケーションにおいて、''site''ページは次のことを可能にします：
- アプリケーションのアンインストール
- ''about''ページ(下で説明します)への遷移
- ''edit''ページ(下で説明します)への遷移
- ''errors''ページ(下で説明します)への遷移
- 一時ファイル(セッション、エラー、cache.diskファイル)のクリーンアップ。
- すべてのパック。これは、アプリケーションの完全なコピーを保持するtarファイルを返します。アプリケーションをパックする前に、一時ファイルをクリーンアップするべきです。
- アプリケーションのコンパイル。エラーがない場合は、このオプションはすべてのコントローラ、ビュー、モデルをバイトコードとしてコンパイルします。ビューは木のように他のビューの中で拡張や組み込みができるため、バイトコンパイルする前に、すべてのコントローラに対するビューの木構造は1つのファイルに折りたたまれます。この実質的な効果としてバイトコンパイルされたアプリケーションは、テンプレートの解析や文字列の置換が実行時に行われなくなるため、より高速に動作します。
- コンパイル結果のパック。このオプションは、バイトコードでコンパイルしたアプリケーションにのみ提示されます。これは、クローズドソースとしてソースコードを含まない状態でアプリケーションをパックできるようにします。ただし、Pythonは(他のプログラミング言語と同様に)技術的には逆コンパイルすることができます。そのためコンパイル結果では、ソースコードの完全な保護は行えません。しかし、逆コンパイルは難しく、違法行為です。
- コンパイル結果の削除。これは単に、アプリケーションからバイトコードでコンパイルされた、モデル、ビュー、コントローラを削除します。アプリケーションがソースコードとともにパックされているか、ローカルで動くようになっている場合、バイトコードでコンパイルされたファイルを削除することはなんら弊害はなく、アプリケーションは動作し続けます。アプリケーションがコンパイル結果をパックしたファイルからインストールされた場合は、安全ではありません。元に戻すためのソースコードがないためで、アプリケーションはもはや動作しなくなります。

``admin.py``:inxx

-------
web2pyのadminサイトのページで利用できるすべての機能はまた、gluon/admin.pyモジュールで定義されているAPIを介してプログラム的にアクセスできます。単にPythonのシェルを開いて、このモジュールをインポートしてください。
-------

#### ''about''
``about``:inxx ``license``:inxx

``about``タブから、アプリケーションの説明とライセンス条項を編集することができます。これらは、それぞれに、applicationフォルダにあるABOUTとLICENCEファイルに書き込まれます。

[[image @///image/en4300.png center 480px]]

これらのファイルに対して``MARKMIN``か``gluon.contrib.markdown.WIKI``の構文を使用することができます。これは参照に説明されているとおりです``markdown2``:cite 。

#### ''edit''
``EDIT``:inxx
本章では、すでに''edit''ページを使用しています。ここでは、''edit''ページのさらなる数個の機能に注目します。
- 任意のファイル名をクリックすると、構文が強調表示された状態でファイルの内容を見ることができます。
- editをクリックすると、Webインタフェースを介してファイルを編集することができます。
- deleteをクリックすると、ファイルを(完全に)削除することができます。
- testをクリックすると、web2pyはテストを走らせます。テストはPythonのdoctestを使って書かれます。そして、各関数は自分自身のテストを持ちます。
- Webインターフェースを介して、言語ファイルを追加し、全ての文字列を見いだすためにアプリをスキャンし、翻訳文字列を編集することができます。
- 静的ファイルがフォルダとサブフォルダで構成されている場合、フォルダ階層はフォルダ名をクリックして切り替えることができます。

下の画像はwelcomeアプリケーションのテストページの出力を示しています。

[[image @///image/en4400.png center 480px]]

下の画像はwelcomeアプリケーションのlanguagesタブを示しています。

[[image @///image/en4500.png center 480px]]

下の画像は、どのように言語ファイルを編集するかを示しています。この場合、welcomeアプリケーションに対する"it"(イタリア)語のファイルです。

[[image @///image/en4600.png center 480px]]

##### ''shell''

''edit''のコントローラタブの下にある"shell"リンクをクリックすると、web2pyはWebベースのPythonのシェルを開き、現在のアプリケーションに対するモデルを実行します。これにより対話的にアプリケーションを実行することができます。

[[image @///image/en4700.png center 480px]]

##### ''crontab''

''edit''のコントローラタブの下にはまた、"crontab"のリンクがあります。このリンクをクリックすると、web2pyのcrontabファイルを編集することができます。これはunixのcrontabと同じ構文に従いますが、unixには依存していません。実際、この機能はweb2pyだけを必要とし、Windows上でも動作します。これにより、スケジュールされた時間にバックグラウンドで起動する必要のあるアクションを登録することができます。
詳細は、次章を参照してください。

#### ''errors''
``errors``:inxx
web2pyをプログラムするときは、ミスを犯すことやバグを取り込むことは避けられません。web2pyは2つの方法で支援します。1)すべての関数に対して、''edit''ページからブラウザで実行できるテストを作成することができます。2)エラーが明示されるとき、チケットが訪問者に発行され、エラーがログとして記録されます。

以下のように、故意に画像アプリケーションにエラーを挿入します：
``
def index():
    images = db().select(db.image.ALL,orderby=db.image.title)
    1/0
    return dict(images=images)
``:code

indexアクションにアクセスすると、次のようなチケットが表示されます：

[[image @///image/en4800.png center 480px]]

管理者だけがこのチケットにアクセスすることができます：

[[image @///image/en4900.png center 480px]]

チケットは、トレースバック、および、問題の原因となったファイルの内容、そして最終的なシステムの状態（変数、リクエスト、セッションなど）を示します。エラーがビューの中で発生した場合は、web2pyはビューをHTMLからPythonコードに変換して表示します。これにより、簡単にファイルの論理構造を確認することができます。

デフォルトでは、チケットはトレースバックファイルシステムとグループに格納されています。管理インターフェイスでは、集計ビュー（発生のトレースと番号のタイプ）と詳細ビュー（すべてのチケットは、チケットIDにより一覧表示されます）を提供しています。管理者は、2つのビューを切り替えることができます。

なお、**admin**は、すべての場所で、構文がハイライトされたコードを表示します(たとえば、エラーレポートでは、web2pyのキーワードはオレンジ色で表示されます)。web2pyのキーワードをクリックすると、キーワードに関するドキュメントページにリダイレクトされます。

アクションにある1/0というバグを修正し、そのバグをindexビューの中に埋め込んでみます：
``
{{extend 'layout.html'}}

<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{1/0}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
``:code

すると、次のようなチケットを得ます：

[[image @///image/en5000.png center 480px]]

ここで、web2pyはビューをHTMLからPythonファイルに変換します。チケットに記述されるエラーは、元のビューファイルではなく、生成されたPythonコードを参照することに注意してください。

[[image @///image/en5100.png center 480px]]

最初は混乱するかもしれません。しかし、実践的にはこれはデバッグを容易にします。なぜなら、Pythonのインデントがビューに埋め込まれた論理構造を強調するからです。

コードは、同じページの下部に表示されます。

すべてのチケットは、各アプリケーションの''error''ページにおいてadminの下に列挙されます：

[[image @///image/en5200.png center 480px]]

#### ''Mercurial''
``Mercurial``:inxx

ソースコードから実行していて、Mercurialのバージョン・コントロールのライブラリをインストールしている場合：
``
easy_install mercurial
``:code

管理インターフェースは"mercurial"というメニュー項目を追加で表示します。これは、自動的にアプリケーションに対するローカルのMercurialリポジトリを作成します。そのページにある"commit"ボタンを押すと、現在のアプリケーションがコミットされます。Mercurialは、コードに対して行った変更に関する情報を作成して格納するために、".hg"という隠しフォルダを、アプリケーションのサブフォルダに作成します。すべてのアプリケーションは、独自の".hg"フォルダと".hgignore"ファイル（無視するファイルをMercurialに伝えるファイル）があります。

Mercurialのウェブインタフェースを使用すると、前回のコミットやdiffファイルを閲覧することができます。 しかし、より強力な機能を持つシェルまたはGUIベースのMercurialのクライアントを使って、直接Mercurialを使用することを推奨します。たとえば、リモート·ソース·リポジトリを使用してアプリを同期できるようになります。

[[images @///image/en5300.png center 480px]]

Mercurialについては、以下のURLでより詳しい情報を読むことができます。
``
http://mercurial.selenic.com/
``

#### 管理ウィザード（実験的）

**admin**インターフェースでは、新しいアプリケーションを作成できるようにウィザードが含まれています。
下の画像に示すように、"sites"ページからウィザードにアクセスできます。

[[image @///image/en5400.png center 480px]]

ウィザードは、新しいアプリケーションの作成に必要な一連の手順を示します。

- アプリケーション名の選択
- アプリケーションの構成と、必要なプラグインの選択
- 必要なモデルのビルド（各モデルのCRUDを行なうページが作成される）
- MARKMIN構文を使用して、ページのビューの編集を許可する

下の画像は、プロセスの2番目のステップを示しています。

[[image @///image/en5500.png center 480px]]

（``web2py.com/layouts``から）レイアウトプラグインの選択を行なうためのドロップダウン、（``web2py.com/plugins``から）その他のプラグインを複数選択するためのドロップダウン、そしてJanrain用の"ドメイン：キー（domain:key）"をどこに配置するかを指定する"ログイン設定（login config）"フィールドが用意されています。

他のステップは、ほぼ自明です。

このウィザードはよく機能していますが、二つの理由から''実験的な機能''となっています。

- ウィザードで作成したアプリケーションを手動で変更した場合、その後はウィザードで編集することができません。
- ウィザードのインターフェイスは、より多くの機能をサポートし、簡単にビジュアルな開発が行えるように、今後も変更されます。

いずれにしてもウィザードは、高速プロトタイピングのための便利なツールであり、別のレイアウトとオプションのプラグインを使用した新しいアプリケーションを作成するためのブートストラップとして使用することができます。

#### **admin**の設定

通常は、adminの構成を行う必要はありませんが、いくつかのカスタマイズが可能です。あなたは、adminにログインした後、次のURLを介して管理コンフィギュレーションファイルを編集することができます。

``
http://127.0.0.1:8000/admin/default/edit/admin/models/0.py
``

**admin**自身も編集することができます。実際、**admin**も他と同じく一つのアプリケーションです。

"0.py"は自分自身が文書化されているので、したいことはどこを探せばいいかわかります。しかし、いくつか他に比べて重要なカスタマイズが存在します。

``
GAE_APPCFG = os.path.abspath(os.path.join('/usr/local/bin/appcfg.py'))
``

これは、Google App EngineのSDKに付属する"appcfg.py"ファイルの場所を指している必要があります。SDKを使用している場合は、正しい値に設定パラメータを変更する必要があるかもしれません。正しく設定されていると、管理者インタフェースからGAEにデプロイすることができます。

``DEMO_MODE``:inxx

web2py管理者をデモモードで動かすことができます。
``
DEMO_MODE = True
FILTER_APPS = ['welcome']
``
フィルタアプリケーションに記載されているアプリだけがアクセスできるようになり、それらは読み取り専用モードでのみアクセスできるようになります。

``MULTI_USER_MODE``:inxx
``virtual laboratory``:inxx

あなたが教師であり、（バーチャルラボのような場所で）学生に対して教師側の管理インターフェイスを公開して共有できるようにする場合は、次のようにして行うことができます。
``
MULTI_USER_MODE = True
``

この場合、学生はログインする必要がありかつ学生自身の管理者インターフェイスにしかアクセスできませんが、教師は全ての学生の管理インターフェイスにアクセスすることができます。

このメカニズムは、まだすべてのユーザーが信頼されていると仮定している点に注意してください。 adminの下に作成されたすべてのアプリケーションは、同じファイルシステム上に同じ資格情報で実行されます。他の学生が作成したデータやソースにアクセスできるアプリケーションを作成することもできます。

### **appadmin**の追加情報

``appadmin``:inxx

**appadmin**は一般に公開されることを意図されていません。これはデータベースへのアクセスを簡単に行えるようして開発者を支援するために設計されています。これには2つのファイルしか含まれていません：1つは"appadmin.py"コントローラで、もう1つはそのコントローラのすべてのアクションから利用される"appadmin.html"ビューです。

**appadmin**コントローラは比較的小さく、読むことが可能です。ここでは、データベースのインターフェイス定義の例を提示しています。

**appadmin**はどのデータベースが利用可能なのか、どのテーブルが各データベースに存在しているかを示します。レコードを挿入することができ、また、各テーブルのレコードを個別に列挙することができます。**appadmin**は一度に100レコードを出力するようにページングします。

一旦、レコードのセットが選択されると、ページのヘッダが変化して、選択されたレコードを更新または削除することができるようになります。

レコードを更新するには、Query文字列フィールドにSQL文を入力します：
``
title = 'test'
``:code

ここで、文字列の値はシングルクォートで囲む必要があります。複数のフィールドはカンマで区切ることができます。

レコードを削除するには、対応するチェックボックスをクリックして、本当に行うか確認します。

**appadmin**はまた、SQLのFILTERが2つ以上のテーブルを含むSQLの条件を持つ場合、結合(join)を実行することができます。たとえば、次の例を試してください：
``
db.image.id == db.comment.image_id
``:code

web2pyは、これをDALに向かって渡します。DALはそのクエリが2つのテーブルをリンクしていることを理解します。したがって、両者のテーブルは内部結合(INNER JOIN)によって選択されます。これはその出力です：

[[image @///image/en5600.png center 480px]]

idフィールドの番号をクリックすると、対応するidを持つレコードに対する編集ページが得られます。

参照フィールドの数字をクリックすると、その参照されたレコードに対する編集ページが得られます。

結合(join)によって選択された行を更新または削除することはできません。なぜなら、それらは複数のテーブルからのレコードを含み、対象が曖昧になるからです。

そのデータベース管理機能に加え、**appadmin**は、アプリケーションの``キャッシュ``(場所は``/yourapp/appadmin/ccache``)の内容の詳細を表示することができます。同様に、現在の``リクエスト``、``レスポンス``そして``セッション``オブジェクト(場所は``/yourapp/appadmin/state``)の内容も表示できます。

------
**appadmin**は``response.menu``を自分自身のメニューに置き換えます。そこでは次のリンクが提供されます。**admin**の中にあるアプリケーションごとの**edit**ページ、**db**（データベース管理）ページ、**state**ページ、**cache**ページです。もし、アプリケーションのレイアウトで``response.menu``を使ったメニューの生成を行なわない場合、**appadmin**メニューは表示されません。この場合は、appadmin.htmlを修正して、メニューを表示するために``{{=MENU(response.menu)}}``を追加することができます。
------

##### 第3版 - 翻訳: 細田謙二 レビュー: 中垣健志
##### 第4版 - 翻訳: 中垣健志　レビュー: Mitsuhiro Tsuda
