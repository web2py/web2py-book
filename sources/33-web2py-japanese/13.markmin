## デプロイレシピ

本番環境にweb2pyをデプロイするには、いくつかの方法があります。詳細は、ホストによって提供されているサーバーの構成とサービスに依存します。

この章では次の点を考えてみます：
- 本番環境（Apache、Lighttpd、Cherokee）
- セキュリティ
- スケーラビリティ
- Google App Engine プラットフォーム（GAE``gae``:cite）へのデプロイ

``Apache``:inxx ``CGI``:inxx ``mod_python``:inxx ``mod_wsgi``:inxx ``mod_proxy``:inxx
``WSGI``:inxx

web2pyにはSSL``ssl``:citeが有効なRocket wsgiserver``rocket``:citeというwebサーバーがあります。これは高速なwebサーバーですが、キャパシティ設定に制限があります。これによりweb2pyを、Apache``apache``:cite 、 Lighttpd``lighttpd``:cite 、 Cherokee``cherokee``:cite でデプロイするのが最適です。これらのサーバーは無償のオープンソースで、カスタマイズでき、トランザクションの多い本番環境での信頼性が証明されています。静的なファイルを直接表示したり、HTTPSを処理したり、動的なコンテンツでweb2pyにコントロールを渡すことができます。

数年前までwebサーバーとwebアプリケーション間で通信に使う、標準的なインターフェースはCommon Gateway Interface (CGI)``cgi``:citeでした。CGIの一番の問題は、HTTPリクエストのたびに新しいプロセスを作成することです。もしwebアプリケーションがインタプリタ言語で書かれている場合は、CGIスクリプトによって実行されたHTTPリクエストが新しいインタプリタ・インスタンスを作成します。これは処理が遅く、本番環境では避けるべきです。さらに、CGIは簡単な処理結果だけを扱えます。例えばファイルストリーミングを扱うことはできません。

web2pyはCGIへのインターフェースに、``cgihandler.py``ファイルを提供しています。

この問題に対する一つの解決策として、Apcheのmod_pythonモジュールを使う方法があります。mod_pythonプロジェクトはApache Software Foundationにおける、正式な開発は既に中止されていますが、今だに一般的な方法なのでここで説明することにします。mod_pythonはApacheが起動するとPythonのインタプリタのインスタンスを開始し、Pythonを毎回再起動せずに自身のスレッドでそれぞれのHTTPリクエストを処理します。mod_pythonはwebサーバーとwebアプリケーション間の通信に、独自のインターフェイスを使うので最適ではないですが、CGIよりは優れた解決策です。mod_pythonではホストされている全てのアプリケーションが、同じuser_id/group_idで実行されるので、セキュリィティ上の問題があります。

web2pyはmod_pythonへのインターフェースに、``modpythonhandler.py``ファイルを提供しています。

近年Pythonコミュニティは、webサーバーとwebアプリケーションを通信する、Pythonで書かれた新しい標準インターフェイスを開発する方向に進みました。それはWeb Server Gateway Interface (WSGI)``wsgi-w, wsgi-o``:citeと呼ばれています。web2pyはWSGI上で構築されており、WSGIが使用できない時には、別のインターフェイスを使用するためのハンドラを提供しています。

ApacheはGraham Dumpletonが開発した、mod_wsgi``modwsgi``:citeモジュール経由でWSGIをサポートします。

web2pyはWSGIへのインターフェースに、``wsgihandler.py``ファイルを提供しています。

一部のwebホスティングサービスは、mod_wsgiをサポートしていません。この場合はApaacheをproxyとして使用し、入ってくる全てのリクエストをweb2py組み込みのwebサーバー（例えばlocalhost:8000などで動作）に転送する必要があります。

mod_wsgiとmod_proxyどちらの場合でも、Apacheは静的なファイルとSSL暗号化を直接処理するように設定でき、web2pyの負荷を軽減します。

Lighttpd webサーバーはWSGIインターフェースをサポートしませんが、CGIを改良したFastCGI``fastcgi``:citeインターフェイスをサポートします。FastCGIの主な目的は、webサーバーとCGIプログラム間のインターフェイスに関係するオーバーヘッドを削減することで、サーバーが一度により多くのHTTPリクエストを処理できるようになることです。

Lighttpd webサイトによると、"LighttpdはYouTubeやWikipediaといった、有名なWeb2.0サイトで使用されています。その高速なIOインフラストラクチャによって、同じハードウェアーを使った他のwebサーバーと比べても、数倍高いパフォーマンスを実現しています"。FastCGIを利用したLighttpdは実際、mod_wsgiを利用したApacheよりも高速です。

web2pyはFastCGIへのインターフェースに、``fcgihandler.py``ファイルを提供しています。

web2pyにはGoogle App Engine (GAE)へのインターフェースである、``gaehandler.py``もあります。GAEでは、webアプリケーションは"クラウド"で動作します。これはフレームワークが、ハードウェアの詳細から、完全に抽象化されていることを意味します。全てのリクエストを処理するのに必要な分だけ、webアプリケーションは自動で複製されます。ここで言う複製とは、単一のサーバー上で複数のスレッドというだけではなく、複数サーバー間でのマルチプロセスという意味です。GAEはファイルシステムへの書き込みを禁止し、全ての永続的なデータは Google BigTable か memcache に保存することで、このスケーラビリティのレベルを実現しています。

GAE以外のプラットフォームでは拡張性は懸念事項であり、web2pyアプリケーションでの調整が必要になる場合があります。拡張性を実現する最も一般的な方法は、ロードバランサ（簡単なラウンドロビン方式やそれぞれのサーバーからハートビートをフィードバックとして受け取るような高度な方式)の後方で、複数のwebサーバーを動作させることです。

複数のwebサーバーがあったとしても、データベースサーバーは常に一つだけです。デフォルトのweb2pyは、セッション、エラーチケット、アップロードファイル、キャッシュをファイルシステムに保存します。このためデフォルトの構成では、それらのフォルダは共有フォルダである必要があります：

[[image @///image/en9100.png center 300px]]

この章の残りの部分で、この標準のアプローチを改善するいくつかのレシピを考えます。次のようなことを含みます：
- セッションをデータベースやキャッシュに保存します。もしくは全く保存しません。
- チケットをローカルのファイルシステムに保存した後に、バッチでデータベースに移動します。
- cache.ramとcache.diskの代わりに、memcachedを利用します。
- アップロードしたファイルは、共有フォルダの代わりにデータベースに保存します。

最初の三つのレシピには従うことを推奨しますが、一方で四つ目は、サイズの小さなファイルではメリットがありますが、大きなファイルで逆効果になる可能性があります。

#### ``anyserver.py``

``anyserver``:inxx ``bjoern``:inxx ``cgi``:inxx ``cherrypy``:inxx ``diesel``:inxx ``eventlet``:inxx ``fapws``:inxx ``flup``:inxx ``gevent``:inxx ``gunicorn``:inxx ``mongrel2``:inxx ``paste``:inxx `` ``tornado``:inxx ``twisted``:inxx ``wsgiref

web2pyには、次のポピュラーなサーバーへのWSGIインターフェイスを実装した、``anyserver.py``ファイルがあります: bjoern, cgi, cherrypy, diesel, eventlet,
fapws, flup, gevent, gunicorn, mongrel2, paste,
rocket, tornado,  twisted, wsgiref

これらのサーバーのいずれかを使えます。例えばTornadoの場合、次のようになります:

``
python anyserver.py -s tornado -i 127.0.0.1 -p 8000 -l -P
``

(``-l``はロギング用、  ``-P``はプロファイラ用です。）
全てのコマンドラインオプションの情報を知るには"-h"を使ってください:

``
python anyserver.py -h
``:code

### Linux と Unix

#### 本番デプロイへの第一歩

ここでは apache+python+mod_wsgi+web2py+postgresql を、ゼロからインストールする手順を説明します。

Ubuntuの場合：
On Ubuntu:
``
wget http://web2py.googlecode.com/hg/scripts/setup-web2py-ubuntu.sh
chmod +x setup-web2py-ubuntu.sh
sudo ./setup-web2py-ubuntu.sh
``
Fedoraの場合：
On Fedora:
``
wget http://web2py.googlecode.com/hg/scripts/setup-web2py-fedora.sh
chmod +x setup-web2py-fedora.sh
sudo ./setup-web2py-fedora.sh
``
どちらのスクリプトも標準設定で動作しますが、どのLinuxインストールも若干仕様が異なるので、実行する前にこれらのスクリプトのコードを確認しておいてください。Ubuntuについては、ほとんどの設定を以下で説明しています。後述のスケーラビリティの最適化については実施していません。

#### Apacheセットアップ

このセクションでは、Ubuntu 8.04 Server Editionをプラットフォームとして使用します。設定コマンドは他のDebianベースのLinuxディストリ ビューションによく似ていますが、Fedoraベースのシステム(``apt-get``の代わりに``yum``を使う）とは異なります。

初めに次のシェルコマンドを実行し、必要な全てのPythonとApacheのパッケージをインストールします：
``
sudo apt-get update
sudo apt-get -y upgrade
sudo apt-get -y install openssh-server
sudo apt-get -y install python
sudo apt-get -y install python-dev
sudo apt-get -y install apache2
sudo apt-get -y install libapache2-mod-wsgi
sudo apt-get -y install libapache2-mod-proxy-html
``:code

そして、ApacheのSSLモジュール、proxyモジュール、WSGIモジュールを有効にします：
``
sudo ln -s /etc/apache2/mods-available/proxy_http.load \
           /etc/apache2/mods-enabled/proxy_http.load
sudo a2enmod ssl
sudo a2enmod proxy
sudo a2enmod proxy_http
sudo a2enmod wsgi
``:code

SSLフォルダを作成し、SSL証明書をその中に配置します：
``
sudo mkdir /etc/apache2/ssl
``:code

SSL証明書はverisign.comのような認証局から取得する必要がありますが、テスト目的では、``openssl``:citeに従うことで自己署名証明書の生成できます。

そしてwebサーバーを再起動します：
``
sudo /etc/init.d/apache2 restart
``:code

Apache設定ファイル：
``
/etc/apache2/sites-available/default
``:code

Apacheログ：
``
/var/log/apache2/
``:code

#### mod_wsgi

上記のwebサーバーをインストールしたマシンに、web2pyソースをダウンロードして解凍します。

例えば、web2pyを``/users/www-data/``配下にインストールし、www-dataユーザとwww-dataグループに権限を与えます。この手順は次のシェルコマンドで実行できます：
``
cd /users/www-data/
sudo wget http://web2py.com/examples/static/web2py_src.zip
sudo unzip web2py_src.zip
sudo chown -R www-data:www-data /user/www-data/web2py
``:code

web2pyをmod_wsgiでセットアップするには、新しいApache設定ファイルを作成して：
``
/etc/apache2/sites-available/web2py
``:code

次のコードを追加します：
``
<VirtualHost *:80>
  ServerName web2py.example.com
  WSGIDaemonProcess web2py user=www-data group=www-data \
                           display-name=%{GROUP}
  WSGIProcessGroup web2py
  WSGIScriptAlias / /users/www-data/web2py/wsgihandler.py

  <Directory /users/www-data/web2py>
    AllowOverride None
    Order Allow,Deny
    Deny from all
    <Files wsgihandler.py>
      Allow from all
    </Files>
  </Directory>

  AliasMatch ^/([^/]+)/static/(.*) \
           /users/www-data/web2py/applications/$1/static/$2
  <Directory /users/www-data/web2py/applications/*/static/>
    Order Allow,Deny
    Allow from all
  </Directory>

  <Location /admin>
  Deny from all
  </Location>

  <LocationMatch ^/([^/]+)/appadmin>
  Deny from all
  </LocationMatch>

  CustomLog /private/var/log/apache2/access.log common
  ErrorLog /private/var/log/apache2/error.log
</VirtualHost>
``:code

Apacheを再起動すると、全てのリクエストはRocket wsgiserverを経由しないで、web2pyに渡されます。

説明すると：
``
WSGIDaemonProcess web2py user=www-data group=www-data
                         display-name=%{GROUP}
``:code

上のコードは、"web2py.example.com"に関連するデーモンプロセスグループを定義しています。
バーチャルホスト内にこれを定義することで、バーチャルホストはWSGIProcessGroupを使用してアクセスできます。これは同じサーバー名のポートが違うバーチャルホストも含みます。
"user"と"group"オプションには、web2pyをセットアップしたディレクトリへの書き込み権限があるユーザをセットするべきです。
Apacheを実行するデフォルトユーザに、web2pyインストレーション・ディレクトリへの書き込み権限を設定している場合、"user"と"group"を設定する必要はありません。
"display-name"オプションは、PSコマンドによって表示する実行可能なApache webサーバーのプロセス名の代わりに、"(wsgi-web2py)"のように出力する設定をします。
"processes"や"threads"オプションを指定しないことで、デーモンプロセスグループはプロセス内で１５個のスレッドを実行する単一のプロセスを持ちます。
これは通常のほとんどのサイトで十分過ぎる設定なので、そのまま使用するべきです。
設定を上書きする場合、"wsgi.multiprocess"フラグをチェックする全てのブラウザ内WSGIデバッグツールが無効になるため、"processes=1"は使用しないでください。
これはどの"processes"オプションの使用でも、例え単一プロセスでさえも、フラグをtrueにセットしてしまいます。それらのツールではフラグがfalseにセットされていることが前提になります。
注意：もしアプリケーションコードやサードパーティ性の拡張モジュールがスレッドセーフでない場合は、"processes=5 threads-1"オプションを使用してください。
これは個々のプロセスがシングルスレッドであるデーモンプロセスグループに、五つのプロセスを作成します。
ガベージコレクトを適切に実施できずに、アプリケーションがPythonオブジェクトをリークする場合は、"maximum-requests=1000"を使うことも検討してください。
``
WSGIProcessGroup web2py
``:code

全てのWSGIアプリケーションの実行を、WSGIDaemonProcessディレクティブで設定されたデーモンプロセスグループに委譲します。
``
WSGIScriptAlias / /users/www-data/web2py/wsgihandler.py
``:code

web2pyアプリケーションをマウントします。この場合はwebサイトのrootにマウントされます。
``
<Directory /users/www-data/web2py>
  ...
</Directory>
``:code

ApacheにWSGIスクリプトファイルにアクセスする権限を与えます。
``
<Directory /users/www-data/web2py/applications/*/static/>
  Order Allow,Deny
  Allow from all
</Directory>
``:code

静的ファイルを検索する際に、web2pyをバイパスするようにApacheを設定します。
``
<Location /admin>
  Deny from all
</Location>
``:code

及び、
``
<LocationMatch ^/([^/]+)/appadmin>
  Deny from all
</LocationMatch>
``:code

**admin**と**appadmin**へのパブリックアクセスをブロックします。

通常はWSGIスクリプトがあるディレクトリ全体にアクセスを許可するだけで良いですが、web2pyは管理者パスワードを含む他のソースコードが入っているディレクトリに、WSGIスクリプトを配置します。
技術的にはApacheは、マッピングされたURL経由してディレクトリを通過する全ユーザに対して、全てのファイルを提供する権限を与えます。このため、ディレクトリ全体を公開することは、セキュリティ上の問題を引き起こします。
セキュリティ問題を回避するため、WSGIスクリプトファイルを除くディレクトリのファイルへのアクセスを明示的に拒否し、より安全にするためにユーザーによる.htaccessファイルの上書きを禁止します。

以上をまとめた、コメントの入ったApache wsgi設定ファイルは以下にあります：
``
scripts/web2py-wsgi.conf
``:code

このセクションは、mod_wsgi開発者のGraham Dumpletonの協力を得て作成されました。

#### mod_wsgiとSSL

アプリケーション（例えば**admin**と**appadmin**）で強制的にHTTPSを利用させるには、SSL証明書と秘密鍵を以下に保存し：
``
/etc/apache2/ssl/server.crt
/etc/apache2/ssl/server.key
``:code

Apacheの設定ファイル``web2py.conf``を編集し、次のコードを追加します：
``
<VirtualHost *:443>
  ServerName web2py.example.com
  SSLEngine on
  SSLCertificateFile /etc/apache2/ssl/server.crt
  SSLCertificateKeyFile /etc/apache2/ssl/server.key

  WSGIProcessGroup web2py

  WSGIScriptAlias / /users/www-data/web2py/wsgihandler.py

  <Directory /users/www-data/web2py>
    AllowOverride None
    Order Allow,Deny
    Deny from all
    <Files wsgihandler.py>
      Allow from all
    </Files>
  </Directory>

  AliasMatch ^/([^/]+)/static/(.*) \
        /users/www-data/web2py/applications/$1/static/$2

  <Directory /users/www-data/web2py/applications/*/static/>
    Order Allow,Deny
    Allow from all
  </Directory>

  CustomLog /private/var/log/apache2/access.log common
  ErrorLog /private/var/log/apache2/error.log

</VirtualHost>
``:code

Apacheを再起動すると、次にアクセスできますが：

``
https://www.example.com/admin
https://www.example.com/examples/appadmin
http://www.example.com/examples
``:code

次のものにはアクセスできません：

``
http://www.example.com/admin
http://www.example.com/examples/appadmin
``:code

#### mod_proxy

幾つかのUnix/LinuxディストリビューションはApacheを実行できますが、mod_wsgiをサポートしてないものがあります。この場合の一番簡単な解決策は、Apacheをプロキシとして実行し、静的ファイルのみをApacheに処理させます。

以下は最低限のApacheの設定です：
``
NameVirtualHost *:80
#### deal with requests on port 80
<VirtualHost *:80>
   Alias / /users/www-data/web2py/applications
   ### serve static files directly
   <LocationMatch "^/welcome/static/.*">
    Order Allow, Deny
    Allow from all
   </LocationMatch>
   ### proxy all the other requests
   <Location "/welcome">
     Order deny,allow
     Allow from all
     ProxyRequests off
     ProxyPass http://localhost:8000/welcome
     ProxyPassReverse http://localhost:8000/
     ProxyHTMLURLMap http://127.0.0.1:8000/welcome/ /welcome
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
``:code

上記のスクリプトは、"welcome"アプリケーションだけを公開します。他のアプリケーションを公開したい場合は、対応する<Location>...</Location>に"welcome"アプリケーションと同様の構文を追加する必要があります。

スクリプトはweb2pyサーバーが、ポート8000を使用することを前提にしています。Apacheを再起動する前に、この点を再確認してください：
``
nohup python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000 &
``:code

``-a``オプションでパスワードを指定するか、パスワードの代わりに"<recycle>"パラメータを指定することができます。後者の場合は、前回保存されたパスワードが再利用され、シェル履歴にパスワードが保存されることはありません。

"<ask>"パラメータを使って、パスワードの入力要求させることもできます。

``nohup``コマンドは、シェルを閉じた時にサーバーが落ちないようにします。``nohup``は``nohup.out``に全てのログを出力します。

adminとappadminにHTTPSを強制的に利用させるには、代わりに次のApacheの設定ファイルを使用します：
``
NameVirtualHost *:80
NameVirtualHost *:443
#### deal with requests on port 80
<VirtualHost *:80>
   Alias / /usres/www-data/web2py/applications
   ### admin requires SSL
   <LocationMatch "^/admin">
     SSLRequireSSL
   </LocationMatch>
   ### appadmin requires SSL
   <LocationMatch "^/welcome/appadmin/.*">
     SSLRequireSSL
   </LocationMatch>
   ### serve static files directly
   <LocationMatch "^/welcome/static/.*">
     Order Allow,Deny
     Allow from all
   </LocationMatch>
   ### proxy all the other requests
   <Location "/welcome">
     Order deny,allow
     Allow from all
     ProxyPass http://localhost:8000/welcome
     ProxyPassReverse http://localhost:8000/
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
<VirtualHost *:443>
   SSLEngine On
   SSLCertificateFile /etc/apache2/ssl/server.crt
   SSLCertificateKeyFile /etc/apache2/ssl/server.key
   <Location "/">
     Order deny,allow
     Allow from all
     ProxyPass http://localhost:8000/
     ProxyPassReverse http://localhost:8000/
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
``:code

-------
web2pyを共有ホスト上でmod_proxyを使用し動かす場合、管理画面は無効にしておく必要があります。そうしないと他のユーザに公開されてしまいます。
-------

#### Linuxデーモンとして起動

mod_wsgiを使用する場合を除き、他のLinuxデーモンとして起動/停止/再起動できるようにweb2pyサーバーを設定することで、コンピュータのブート時に自動で起動することができます。

これを設定する方法は、個々のLinux/Unixディストリビューションで固有です。

web2pyフォルダには、この設定のために二つのスクリプトが用意されています：
``
scripts/web2py.ubuntu.sh
scripts/web2py.fedora.sh
``:code

Ubuntuや他のDebianベースのLinuxディストリビューションでは、"web2py.ubunu.sh"を編集し"/usr/lib/web2py"パスをweb2pyインストールパスに置き換え、次のシェルコマンドを実行することでファイルを適切なフォルダへ移動し、スタートアップサービスに登録し起動します：
``
sudo cp scripts/web2py.ubuntu.sh /etc/init.d/web2py
sudo update-rc.d web2py defaults
sudo /etc/init.d/web2py start
``:code

Fedoraや他のFedoraベースのディストリビューションでは、"web2py.fedora.sh"を編集し"/usr/lib/web2py"パスをweb2pyインストールパスに置き換え、次のシェルコマンドを実行することでファルを適切なフォルダに移動し、スタートアップサービスに登録し起動します：
``
sudo cp scripts/web2py.fedora.sh /etc/rc.d/init.d/web2pyd
sudo chkconfig --add web2pyd
sudo service web2py start
``:code

#### Lighttpd
``Lighttpd``:inxx ``FastCGI``:inxx ``fcgihandler``:inxx

次のシェルコマンドで、Ubuntuや他のDebianベースのLinuxディストリビューションに、Lighttpdをインストールできます：
``
apt-get -y install lighttpd
``:code

インストールされたら、``/etc/rc.local``を編集し、fcgi web2pyバックグランドプロセスを作成します
``
cd /var/www/web2py && sudo -u www-data nohup python fcgihandler.py &
``:code

そして、Lighttpd設定ファイルを編集する必要があります。
``
/etc/lighttpd/lighttpd.conf
``:code

上記のプロセスで作成されたソケットを見つけることができます。設定ファイルに以下のように記述します：
``
server.modules              = (
        "mod_access",
        "mod_alias",
        "mod_compress",
        "mod_rewrite",
        "mod_fastcgi",
        "mod_redirect",
        "mod_accesslog",
        "mod_status",
)

server.port = 80
server.bind = "0.0.0.0"
server.event-handler = "freebsd-kqueue"
server.error-handler-404 = "/test.fcgi"
server.document-root = "/users/www-data/web2py/"
server.errorlog      = "/tmp/error.log"

fastcgi.server = (
  "/handler_web2py.fcgi" => (
      "handler_web2py" => ( #name for logs
         "check-local" => "disable",
         "socket" => "/tmp/fcgi.sock"
      )
   ),
)

$HTTP["host"] = "(^|\.)example\.com$" {
 server.document-root="/var/www/web2py"
    url.rewrite-once = (
      "^(/.+?/static/.+)$" => "/applications$1",
      "(^|/.*)$" => "/handler_web2py.fcgi$1",
    )
}
``:code

次に構文エラーをチェックします：
``
lighttpd -t -f /etc/lighttpd/lighttpd.conf
``:code

そして次のように、webサーバーを（再）起動します：
``
/etc/init.d/lighttpd restart
``:code

FastCGIは、web2pyをIPソケットで無く、Unixソケットにバインドする点に注意してください：
``
/tmp/fcgi.sock
``:code

これはLighttpdが、HTTP送受信を転送する部分です。UnixソケットはIPソケットより軽量で、それがLighttpd+FastCGI+web2pyが高速に動作する一つの理由です。
Apacheの場合は、静的ファイルディレクトリをLighttpdに直接処理させ、アプリケーションを強制的にHTTPS経由にする設定も可能です。詳細はLighttpdのドキュメントを参照してください。

このセクションの例は、web2pyslicesに投稿されたJohn Heenanの記事から引用しました。

-------
web2pyをFastCGIを使った共有ホストで動かす場合、管理画面は無効にしておく必要があります。そうしないと、他のユーザに公開されてしまいます。
-------

#### mod_pythonを使った共有ホスティング

しばしば、特に共有ホスト環境で、Apche設定ファイルを直接編集する権限がない場合があります。この本を書いている現在、mod_wsgiの登場によってメンテナンスがされていませんが、ほとんどのホストで未だmod_pythonを動かしています。

このような環境でもweb2pyを動かすことができます。ここでは、どのように設定するか例を見せます。

web2pyの中身を"htdocs"フォルダに入れます。

web2pyフォルダに、次の内容の"web2py_modpython.py"を作成します：

``
from mod_python import apache
import modpythonhandler

def handler(req):
    req.subprocess_env['PATH_INFO'] = req.subprocess_env['SCRIPT_URL']
    return modpythonhandler.handler(req)
``:code

次の内容の".htaccess"ファイルを作成/更新します：

``
SetHandler python-program
PythonHandler web2py_modpython
#PythonDebug On
``:code

この例は、Niktarによって提供されました。


#### CherokeeとFastCGI
``Cherokee``:inxx ``FastCGI``:inxx

Cherokeeは高速なwebサーバーで、web2pyのように設定用にAJAXが有効なwebベースの管理画面を提供します。管理画面はPythonで書かれており、ほとんどの変更に対してサーバーの再起動を必要としません。

こちらが、web2pyをCherokeeでセットアップするのに必要な手順です：

Cherokee``cherokee``:citeをダウンロード

tarの展開、ビルド、そしてインストール：

``
tar -xzf cherokee-0.9.4.tar.gz
cd cherokee-0.9.4
./configure --enable-fcgi && make
make install
``:code

"applications"フォルダの作成を確認するために、少なくとも一度はweb2pyを正常に起動します。

次のコードで、"startweb2py.sh"という名前のシェルスクリプトを作成します：

``
#!/bin/bash
cd /var/web2py
python /var/web2py/fcgihandler.py &
``:code

そして、スクリプトに実行権限を与えて実行してください。これはFastCGIハンドラで、web2pyが起動します。

Cherokeeとchroke-adminを起動：

``
sudo nohup cherokee &
sudo nohup cherokee-admin &
``:code

デフォルトでchrokee-adminは、ローカルのポート9090だけを使用します。マシンへ完全な物理的アクセス権があれば問題ではありません。もうしそうでない場合は、次のオプションを利用し、強制的にIPアドレスとポートをバインドできます：
``
-b,  --bind[=IP]
-p,  --port=NUM
``:code

もしくは、SSHポートフォワード（より安全で、推奨される）を使用します：
``
ssh -L 9090:localhost:9090 remotehost
``:code

ブラウザで"http://localhost:9090"を開き、もし全ての設定がＯＫであれば、cherokee-adminが開きます。

cherokee-admin webインターフェイスで、"info sources"をクリックします。"Local Interpreter"を選びます。次のコードを記述して"Add New"をクリックします。

``
Nick: web2py
Connection: /tmp/fcgi.sock
Interpreter: /var/web2py/startweb2py.sh
``:code

最後に次のように、残りステップを実行します：
- "Virtual Servers"をクリックし、更に"Default"をクリックします。
- "Behavior"をクリックし、更にその下の、"default"をクリックします。
- リストボックスから"List and Send"の代わりに、"FastCGI"を選択します。
- 一番下で、"web2py"を"Application Server"として選択します。
- 全てのチェックボックス（Allow-x-sendfileは外すことも可能）をチェックします。もし警告表示がでたら、どれか一つのチェックボックスを無効にしてから有効にします。（そうすることで、アプリケーションサーバーのパラメータを自動で再送信します。バグで上手く行かない時もあります。）
- ブラウザで"http://あなたのサイト"を開くと、"Welcom to web2py"が表示されます。

#### Postgresql

PostgreSQLはフリーでオープンソースのデータベースで、本番環境で使用されています。例えば、.orgドメイン名を保存するデータベースに使用されて、データが何百テラバイトに拡張できることを証明されています。非常に高速で安定したトランザクションサポートを持ち、多くのデータベース保守タスクから管理者を解放するauto-vacuumという機能があります。

Ubuntuや他のDebianベースLinuxディストリビューションでは、PostgreSQLとそのPython APIを間単にインストールできます：
``
sudo apt-get -y install postgresql
sudo apt-get -y install python-psycopg2
``:code

webサーバーとデータベースは異なるマシンで運用したほうが賢明です。この場合、webサーバーを動かしているマシンは安全な内部（物理）ネットワーク、またはSSLトンネルでデータベースサーバーと接続されるべきです。

PostgreSQLの設定ファイルを編集します
``
sudo nano /etc/postgresql/8.4/main/postgresql.conf
``:code

次の二行を記述します
``
...
track_counts = on
...
autovacuum = on   # Enable autovacuum subprocess?  'on'
...
``:code

データベースサーバーを起動します：
``
sudo /etc/init.d/postgresql restart
``:code

PostgreSQLサーバーの再起動時に、どのポートで実行されているか表示されます。データベースサーバーが複数で構成される場合を除き、5432のはずです。

PostgreSQLのログは、次の場所にあります：
``
/var/log/postgresql/
``:code

データベースサーバーが立ち上がって動き出したら、web2pyアプリケーションに必要なユーザとデータベースを作成します：
``
sudo -u postgres createuser -PE -s myuser
postgresql> createdb -O myself -E UTF8 mydb
postgresql> echo 'The following databases have been created:'
postgresql> psql -l
postgresql> psql mydb
``:code

最初のコマンドは新規作成ユーザ``myuser``に、スーパーユーザ・アクセス権限を与えます。そして、パスワードを入力するようプロンプトを表示します。

どのweb2pyアプリケーションでも、以下のコマンドでこのデータベースに接続できます：
``
db = DAL("postgres://myuser:mypassword@localhost:5432/mydb")
``:code

``mypassword``はプロンプト時に入力したパスワードで、5432はデータベースサーバーが実行されているポートです。

通常はアプリケーションごとに一つのデータベースを作成し、同じアプリケーションの複数のインスタンスは同じデータベースに接続します。異なるアプリケーション間で同じデータベースを共有することもできます。

データベースバックアップについては、PostgreSQLドキュメントにある、``pg_dump``と``pg_restore``コマンドを読んでください。

### Windows

#### Apacheとmod_wsgi

WindowsでApacheとmod_wsgiをインストールするには、異なる手順が必要になります。
Python 2.5がインストールされていて、web2pyがソースから実行され、さらに``c:/web2py``にあることを前提に説明します。

最初に、必要なパッケージをダウンロードします：
- ``apache1``:cite から Apache ``apache_2.2.11-win32-x86-openssl-0.9.8i.msi``
- ``modwsgi1``:cite から mod_wsgi

二つ目に、``apache...msi``を実行し、ウィザード画面に従います。サーバー・インフォメーション画面で

[[image @///image/en9200.png center 300px]]

全ての要求項目を入力します：
- **Network Domain**: サーバーの現在のまたは登録予定のDNSドメインを入力します。もしサーバーの正式なDNS名がserver.mydomain.netの場合は、mydomain.netと入力します。
- **ServerName**: サーバーの完全なDNS名です。上記の例で言うと、server.mydomain.netと入力します。完全修飾ドメイン名、もしくはショートカットではないweb2pyインストールのIPアドレスを入力します。詳細は、``apache2``:cite.を参照してください。
- **Administrator's Email Address**: サーバー管理者またはwebマスターのメールアドレスを入力します。このアドレスはデフォルトで、クライアントへのエラーメッセージと共に表示されます。

特に必要がなければ、標準インストールで最後まで続行します

ウィザードはデフォルトで、以下のフォルダにApacheをインストールします：
``
C:/Program Files/Apache Software Foundation/Apache2.2/
``:code

ここからは簡単にするためフォルダを、``Apache2.2``と呼びます。

三つ目に、ダウンロードしたmod_wsgi.soを``Apache2.2/modules``にコピーします
``Apache2.2/modules``

Chris Traversによって書かれ、2007年12月にMicrosoftのOpen Source Software Labで公開されました。

四つ目に、``server.crt``と``server.key``証明書（前のセクションで説明した）を作成し、``Apache2.2/conf``フォルダに設置します。cnfファイルは、``Apache2.2/conf/openssl.cnf``にあることに注意してください。

五つ目に、``Apache2.2/conf/httpd.conf``を編集し、次の行のコメント(#文字)を外します。
``
LoadModule ssl_module modules/mod_ssl.so
``:code

他の全てのLoadModule行の後に、次のコードを追加します。
``
LoadModule wsgi_module modules/mod_wsgi.so
``:code

"Listen 80"の記述を検索し、次の行をその後に追加します
``
Listen 443
``:code

あなたの設定値に従って、ドライブレター、ポート番号、サーバー名を変更し、一番最後に次の行を追加します。
``
NameVirtualHost *:443
<VirtualHost *:443>
  DocumentRoot "C:/web2py/applications"
  ServerName server1

  <Directory "C:/web2py">
    Order allow,deny
    Deny from all
  </Directory>

  <Location "/">
    Order deny,allow
    Allow from all
  </Location>

  <LocationMatch "^(/[\w_]*/static/.*)">
    Order Allow,Deny
    Allow from all
  </LocationMatch>

  WSGIScriptAlias / "C:/web2py/wsgihandler.py"

  SSLEngine On
  SSLCertificateFile conf/server.crt
  SSLCertificateKeyFile conf/server.key

  LogFormat "%h %l %u %t "%r" %>s %b" common
  CustomLog logs/access.log common
</VirtualHost>
``:code

設定を保存し、[Start > Program > Apache HTTP Server 2.2 > Configure Apache Server > Test Configuration] を使って設定を確認します。

もし問題が無ければコマンド画面が開いて閉じます。これで、次のようにApacheを起動できます：

[Start > Program > Apache HTTP Server 2.2 > Control Apache Server > Start]

もっと良いのは、タスクバーモニタを起動します。

``[Start > Program > Apache HTTP Server 2.2 > Control Apache Server]``

これで赤い羽根のようなタスクバーアイコン上の右クリックで、"Open Apache Monitor"を選択し、起動、停止、再起動を必要に応じて実行できます。

このセクションはJonathan Lundellによって作成されました。

#### Windowsサービスとして起動
``Windows service``:inxx

Linuxのデーモンは、Windowsではサービスと呼ばれます。
web2pyサーバーはWindowsサービスとして簡単に、インストール/起動/停止ができます。

web2pyをWindowsサービスとして使用するには、起動パラメータを使用した"options.py"を作成する必要があります：
``
import socket, os
ip = socket.gethostname()
port = 80
password = '<recycle>'
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
ssl_certificate = "
ssl_private_key = "
numthreads = 10
server_name = socket.gethostname()
request_queue_size = 5
timeout = 10
shutdown_timeout = 5
folder = os.getcwd()
``:code

既にモデルとして使用できる、"options_std.py"というファイルがweb2pyフォルダにあるため、"options.py"を一から作成する必要はありません。

"options.py"をweb2pyのインストール・フォルダに作成したら、次のコマンドでweb2pyをサービスとして追加できます：
``
python web2py.py -W install
``:code

そして、次のコマンドで起動/停止できます：
``
python web2py.py -W start
python web2py.py -W stop
``:code

### セッション保護と**admin**
``security``:inxx ``admin``:inxx

HTTPS経由で実行されている場合を除き、**admin**アプリケーションと**appadmin**コントローラを公開することは、とても危険です。そしてパスワードと証明書は、暗号化無しで通信されるべきではありません。これはweb2pyと、他のどのwebアプリケーションにも当てはまります。

アプリケーションで認証が必要な場合は、次のようにセッションクッキーを保護するべきです：
``
session.secure()
``:code

サーバー上で安全な本番環境をセットアップする簡単な方法は、まずweb2pyを停止し、web2pyのインストール・フォルダから全ての``parameters_*.py``ファイルを削除することです。そしてパスワード無しでweb2pyを起動します。これでadminとappadminは完全に無効になります。
``
nohup python web2py --nogui -p 8001 -i 127.0.0.1 -a '' &
``:code

次に、ローカルホストからだけアクセス可能な二つ目のweb2pyインスタンスを起動します：
``
nohup python web2py --nogui -p 8002 -i 127.0.0.1 -a '<ask>' &
``:code

そして、ローカルマシン（管理画面にアクセスしたいマシン）からサーバー（web2pyが実行されている、example.com）へ、SSHトンネルを作成します：
``
ssh -L 8002:127.0.0.1:8002 username@example.com
``:code

これでブラウザ経由の``localhost:8002``で、管理画面へローカルに接続することができます。

トンネルが閉じている（ユーザがログアウト）時は、**admin**へ接続できないので設定は安全になります。

-------
この方法は他のユーザが、web2pyを含むフォルダへの読み取りアクセスを持たない共有ホスト環境では安全です。そうでない時は、ユーザがサーバーから直接セッションクッキーを盗むことが可能です。
-------

### 効率とスケーラビリティ
``scalability``:inxx

web2pyは簡単に、デプロイとセットアップができるように設計されています。これは効率やスケーラビリティに妥協しているという意味ではなく、拡張するには調整が必要な場合があるということです。

このセクションではローカルのロードバランスを提供するNATサーバーの後ろに、複数のweb2pyをインストールする場合を考えてみます。

この場合、幾つかの条件に合致するのであれば、web2pyはそのまま動作します。具体的には、それぞれのweb2pyアプリケーションの全てのインスタンスが、同一のデータベースサーバーにアクセスし、さらに同一のファイルを参照している必要があります。後者の条件は、次のフォルダを共有させることで実現が可能です。
``
applications/myapp/sessions
applications/myapp/errors
applications/myapp/uploads
applications/myapp/cache
``:code

共有フォルダは、ファイルロックをサポートしなければいけません。方法としては ZFS(ZFSはSun Microsystemsに開発されており、推奨する選択肢です）、NFS（ファイルロックを有効にするためにnlockmgrデーモンを実行する必要があるかもしれません）、もしくは、Samba(SMB)です。

web2pyフォルダ全体やアプリケーションフォルダ全体を共有することも可能ですが、ネットワーク帯域使用量が無駄に増加するだけなので良い方法ではありません。

共有する必要があるが、トランザクションの安全性を必要としないリソースを、共有ファイルシステムに移動します。これによってデータベースの負荷を減らすため、上記の設定の説明は、非常に拡張性が高いと考えます（一回一クライアントのみのセッションファイルのアクセス想定、常時必要なキャッシュのグローバルロック、一度のuploadsとerrorsへの書き込み/たくさんのファイルの読み取り）。

理想的には、データベースと共有ストレージは両方ともRAID構成であるべきです。データベースを共有フォルダと同じストレージに保存する間違いをしないでください、新しいボトルネックを作ってしまいます。

ケースバイケースで、追加での最適化実行が必要であり、それについては後述します。具体的には、どのように共有フォルダを一つずつ排除するか、そして代わりに関連データをデータベースに保存する方法を説明します。これは可能ですが、良い解決策とは限りません。それでも行う理由があるかもしれません。そのような理由の一つは、共有フォルダを自由にセットアップできない場合です。

#### 効率のトリック

web2pyアプリケーションコードはリクエストのたびに実行されるので、コードの量を最小限に抑えたい時があります。ここで以下の方法があります：

- 一度だけ``migrate=True``を実行してから、全てのテーブルに``migrate=False``をセットします。
- **admin**を使った、アプリケーションのバイトコードコンパイルします。
- ``cache.ram``をできる限り使用するため、有限なキーセットを使っているか確認します。そうしないと、使用するキャッシュ量は任意に成長します。
- モデル内のコードを最小化します：ここに関数を定義せずそれを必要とするコントローラに定義します。もっといい方法は、モジュールに関数を定義して必要に応じてインポートして使用します。
- たくさんの関数を同じコントローラに設定しないで、たくさんのコントローラにいくつかの関数を定義します。
- セッションを変更しない全てのコントローラや関数で、``session.forget(response)``を実行します。
- web2py cronを使わず、代わりにバックグラウンドプロセスを利用するようにします。web2py cronは大量のPythonインスタンスを起動し過剰にメモリを使用します。

#### データベースでのセッション

セッションフォルダの代わりに、データベースにセッションを保存するようにweb2pyに指示することが可能です。セッションの保存に同じデータベースを使用することになるとしても、それぞれ個別のアプリケーションに対して設定が必要です。

データベース接続を作成
``
db = DAL(...)
``:code

接続を確立する同じモデルファイル内に次のコードを追加するだけで、データベースにセッションを保存することができます：
``
session.connect(request, response, db)
``:code

テーブルがまだ存在しない場合、we2pyは``web2py_session_``''アプリケーション名''という、以下のフィールドを持ったデータベースのテーブルを作成します：
``
Field('locked', 'boolean', default=False),
Field('client_ip'),
Field('created_datetime', 'datetime', default=now),
Field('modified_datetime', 'datetime'),
Field('unique_key'),
Field('session_data', 'text')
``:code

"unique_key"は、クッキー内のセッションを特定するために使用するuuidキーです。
"session_data"はcPickledセッションデータです。

データベースアクセスを最小限にするために、必要がない場合はセッションを保存しないようにするべきです：
``
session.forget()
``:code

この変更により、"sessions"フォルダはアクセスされなくなるので、共有フォルダにする必要は無くなります。

-------
セッションが無効の場合は、``session``を``form.accepts``に渡してはいけません。また、``session.flash``やCRUDも使用できない点に注意してください。
-------

#### HAProxy 高可用性ロードバランサ
``HAProxy``:inxx

複数のweb2pyプロセスを複数のマシンで実行する必要がある場合は、データベースにセッションを保存したり、キャッシュする代わりに、スティッキー・セッションを利用したロードバランサを使用するオプションがあります。

Pound``pound``:citeとHQProxy``haproxy``:citeは、スティッキー・セッションを提供する、二つのHTTPロードバランサとリバースプロキシです。ここでは商用VPSホスティングで、より一般的な後者について説明します。

スティッキー・セッションは一度セッションクッキーが発行されたら、ロードバランサはセッションに関連付けられたクライアントからのリクエストを、常に同じサーバーにルーティングします。こうすることでファイルシステムを共有せずに、ローカルのファイルシステムにセッションを保存することができます。

HAProxyを使うには：

初めに、Ubuntu テストマシンにインストールします：
``
sudo apt-get -y install haproxy
``:code

二つ目に、設定ファイル"/etc/haproxy.cfg"を以下のように編集します：
``
## this config needs haproxy-1.1.28 or haproxy-1.2.1

global
      log 127.0.0.1   local0
      maxconn 1024
      daemon

defaults
      log     global
      mode    http
      option  httplog
      option  httpchk
      option  httpclose
      retries 3
      option redispatch
      contimeout      5000
      clitimeout      50000
      srvtimeout      50000

listen 0.0.0.0:80
      balance url_param WEB2PYSTICKY
      balance roundrobin
      server  L1_1 10.211.55.1:7003  check
      server  L1_2 10.211.55.2:7004  check
      server  L1_3 10.211.55.3:7004  check
      appsession WEB2PYSTICKY len 52 timeout 1h
``:code

``listen``ディレクティブは、どのポートで接続を待つかをHAProxyに指示します。
``server``ディレクティブは、プロキシサーバーがどこにあるかを指示します。
``appsession``ディレクトリは、スティッキー・セッションを作成し``WEB2PYSTICKY``というクッキーをこの目的で使用します。

三つ目に、この設定を有効にし、HAProxyを起動します：
``
/etc/init.d/haproxy restart
``:code

以下のURLに、Poundのセットアップの同様の手順があります

``
http://web2pyslices.com/main/slices/take_slice/33
``:code

#### セッションのクリーンアップ

本番環境では、セッションが速く積み重なることに注意してください。web2pyは次のスクリプトを提供しています：
``
scripts/sessions2trash.py
``:code

バックグラウンドで実行され、定期的に一定期間アクセスされていない全てのセッションを削除します。web2pyは、これらのセッションをクリーンアップするスクリプトを提供します（ファイルベースのセッション及びデータベースのセッションのどちらでも有効です）。

次に典型的な使用例を挙げます：

- 5分毎に期限切れのセッションを消去します：
``
nohup python web2py.py -S app -M -R scripts/sessions2trash.py &
``:code

- 詳細な出力と共に、有効期限に関わらず60分より古いセッションを消去し、終了します。
``
python web2py.py -S app -M -R scripts/sessions2trash.py -A -o -x 3600 -f -v
``:code

- 有効期限に関わらず全てのセッションを消去し、終了します：
``
python web2py.py -S app -M -R scripts/sessions2trash.py -A -o -x 0
``:code

``app``に、対象のアプリケーション名を指定します。

#### データベース上でのファイルアップロード

デフォルトでは、SQLFORMによって処理されたアップロードファイルは、安全に名前変更されフィルシステムの"uploads"フォルダに保存されます。web2pyに対して指示し、フォルダの代わりにデータベースにアップロードファイルを保存させることも可能です。

次のテーブルを考えてみます：

``
db.define_table('dog',
    Field('name')
    Field('image', 'upload'))
``:code

``dog.image``はuploadタイプです。犬の名前と同じレコードにアップロード画像を保存するには、blobフィールドを追加しuploadフィールドにリンクするようにテーブル定義を修正する必要があります：
``
db.define_table('dog',
    Field('name')
    Field('image', 'upload', uploadfield='image_data'),
    Field('image_data', 'blob'))
``:code

ここで"image_data"は、任意につけた新しいblobフィールドの名前です。

3行目は通常通りアップロードされた画像の名前を安全に変更し、変更された新しい名前をimageフィールドに保存し、ファイルシステムに保存する代わりに"image_data"というuploadフィールドにデータを保存します。この全ての処理がSQLFORMによって自動で実行され、他のコードを変更する必要はありません。

この変更で、"uploads"フォルダは必要なくなります。

Google App Engineでは、デフォルトでuploadfieldが自動作成されるので、uploadfieldを定義しなくてもデータベースに保存されます。

#### チケットの収集

デフォルトで、web2pyはチケット（エラー)をローカルのファイルシステムに保存します。一番のエラー原因は、本番環境でのデータベース障害であるため、データベースにチケットを直接保存することは意味がありません。

通常は稀なイベントのため、チケットの保存はボトルネックになりません。このため複数サーバーで構成された本番環境では、共有フォルダに保存するのも適当です。とはいえ管理者だけがチケットを取り出す必要があるので、共有されていないローカルの"エラー"フォルダにチケットを保存し、定期的に収集して削除するのでも大丈夫です。

定期的にローカルのチケットをデータベースに移動する、という方法もあります。

このために、web2pyは次のスクリプトを提供します：
``
scripts/tickets2db.py
``:code

デフォルトでこのスクリプトは**ticket_storage.txt**という、プライベートフォルダに保存されたファイルからdbのuriを取得します。このファイルには次のような、**DAL**インスタンスへ直接渡す文字列を含める必要があります：

``
mysql://username:password@localhost/test
postgres://username:password@localhost/test
...
``:code

これは、スクリプトをそのまま残すことができます：もし複数のアプリケーションがある場合、全アプリケーションへの適切な接続を動的に選択します。もしuriをハードコーディングしたい場合は、''except''行の直後に、db_stringへの2つめの参照を記述してください。
次のコマンドでスクリプトを実行できます：
``
nohup python web2py.py -S myapp -M -R scripts/tickets2db.py &
``:code

myappは対象となるアプリケーション名です。

このスクリプトはバックグラウンドで動作し、5分毎に全てチケットをデータベースに移動し、ローカルチケットを消去します。
adminアプリの上部にある"switch to:db"ボタンをクリックすると、ファイルシステムに保存されている場合と全く同じような機能で、エラーを表示することができます。

この変更で、エラーはデータベースに保存されるので、"errors"フォルダは共有フォルダである必要はありません。

#### Memcache
``memcache``:inxx

web2pyが提供する二つのタイプのキャッシュ: ``cache.ram``と``cache.disk``を説明してきました。
どちらも複数のサーバーによる分散環境で動作しますが、期待通りには動作しません。具体的には、``cache.ram``は、サーバーレベルでのみキャッシュします。このため、役には立ちません。``cache.disk``は、"cache"フォルダーがファイルロックをサポートする共有フォルダの場合を除き、同様にサーバーレベルでキャッシュします。このため、スピードアップでは無く、主なボトルネックになります。

解決策としてはこれらは使わず、代わりにmemacheを使います。web2pyにはmemcache APIが付属しています。

memcacheを使うためには、例えば``0_memcache.py``という新規のモデルファイルを作成し、次のコードを記述（または追記）します：
``
from gluon.contrib.memcache import MemcacheClient
memcache_servers = ['127.0.0.1:11211']
cache.memcache = MemcacheClient(request, memcache_servers)
cache.ram = cache.disk = cache.memcache
``:code

最初の行はmemcacheをインポートします。2行目はmemcache socket(サーバー:ポート)のリストです。3行目はcache.memcacheを定義します。4行目は``cache.ram``と``cache.disk``を、memcacheで再定義します。

Memcacheオブジェクトを指している全く新しいキャッシュオブジェクトを定義するために、それらの1つだけを再定義するために選択することができます。

この変更で、"cache"フォルダはアクセスが無くなるので、共有フォルダである必要はありません。

このコードは、memcacheサーバーがローカルネットワークで動作していることが前提です。サーバーのセットアップ方法は、memcacheドキュメントを参照してください。

#### Memcacheでのセッション

セッションが必要だが、ロードバランサでスティッキー・セッションを使用したくない場合は、memcacheにセッションを保存するオプションがあります：
``
from gluon.contrib.memdb import MEMDB
session.connect(request,response,db=MEMDB(cache.memcache))
``:code

#### Redisによるキャッシング
``redis``:cite
Memcacheの代替としてRedisが使用できます。 ``Redis``:inxx

Redisがインストールされており、localhostの6379ポートで実行されていると仮定すると、次のコードで接続可能です（モデルに記述します）：

``
from gluon.contrib.redis import RedisCache
cache.redis = RedisCache('localhost:6379',db=None, debug=True)
``

'localhost:6379'は接続文字列です。``db``はDALオブジェクトではなく、Redisのデータベース名です。

``cache.ram``と``cache.disk``の代わりに（または一緒に）、``cache.redis``を使用できます。

次のコードでRedisの統計情報を取得できます：

``
cache.redis.stats()
``:code

#### アプリケーションの削除
``removing application``:inxx

本番環境では、デフォルトアプリケーション:**admin**、**examples**、**welcome**をインストールしないほうが良いかもしれません。小さいですが必要のないアプリケーションだからです。

これらのアプリケーションを削除するのは簡単です。applicationsフォルダ下の対象のフォルダを削除するだけです。

#### レプリカデータベースの使用

高いパフォーマンスを必要とする本番環境では、たくさんのレプリカスレーブを持つマスタースレーブ・データベース構成や、恐らく一組のレプリカサーバーがあるかもしれません。
DALは、このような状況を処理し、条件付きリクエストパラメータに応じて異なるサーバーに接続することができます。
それを実現するAPIは、6章で説明済みです。以下はその例です：

``
from random import sample
db = DAL(sample(['mysql://...1','mysql://...2','mysql://...3'], 3))
``:code

この場合、異なるHTTPリクエストがランダムで異なるデータベースによって処理され、それぞれのDBが同じような頻度で使用されます。

シンプルなラウンドロビンを実装することもできます

``
def fail_safe_round_robin(*uris):
     i = cache.ram('round-robin', lambda: 0, None)
     uris = uris[i:]+uris[:i] # rotate the list of uris
     cache.ram('round-robin', lambda: (i+1)%len(uris), 0)
     return uris
db = DAL(fail_safe_round_robin('mysql://...1','mysql://...2','mysql://...3'))
``:code

これは、リクエストに割り当てられたデータベースサーバーの接続に失敗した場合は、DALは順番に次のサーバーに接続を試みるという意味で、フェイルセーフです。

リクエストされたアクションやコントローラによって、異なるデータベースに接続することも可能です。マスタースレーブ・データベース構成で、あるアクションは読み取り専用で、いくらかの人物は読み取り/書き込みを両方します。前者はスレーブDBサーバーに安全に接続でき、後者はマスターに接続されるべきです。これは以下のように記述できます：

``
if request.function in read_only_actions:
   db = DAL(sample(['mysql://...1','mysql://...2','mysql://...3'], 3))
if request.action in read_only_actions:
   db = DAL(shuffle(['mysql://...1','mysql://...2','mysql://...3']))
else:
   db = DAL(sample(['mysql://...3','mysql://...4','mysql://...5'], 3))
``:code

1、2、3はスレーブで、3、4、5はマスターです。

### Google App Engineでのデプロイ
``Google App Engine``:inxx

DALコードを含めて、Google App Engine(GAE)``gae``:citeで、web2pyを動かすことは可能です。

GAEは2つのバージョンのPythonをサポートします：2.5（デフォルト）と2.7（ベータ）です。web2pyは、デフォルトでは2.5を採用していますが両方サポートします（デフォルトは将来変更される可能であります）。"app.yaml"ファイルに、詳細な設定が書かれていますので参照ください。

GAEは、Google SQLデータベース（MySQLと互換）とGoogle NoSQL（"Datastore"と呼ばれています）の両方をサポートします。

web2pyはどちらもサポートしています。もしGoogle SQLデータベースを使用する場合は、6章の指示に従ってください。このセクションでは、Google Datastoreを使用すると仮定しています。

GAEプラットフォームは、通常のホスティング環境よりも幾つか良い点があります：

- 簡単にデプロイができます。Googleは内部の構造を完全に抽象化します。
- スケーラビリティがあります。同時アクセスリクエストの数だけ、何度でもアプリケーションを複製します。
- SQLとNoSQLを選択できます（両方可）。

しかし、不利な点もあります：
- ファイルシステムへの読み書きができません。
- Googleの証明書で、appspot.comドメインを使用しないとHTTPSが利用できません。

幾つかDatastoreの仕様で不利な点があります：

- 典型的なトランザクションがありません。
- 複雑なDatastoreクエリがありません。具体的には``JOIN``、``LIKE``、 ``DATE/DATETIME``演算子がありません。
- あるフィールドと同じフィールド以外のサブクエリの、複数の``OR``がありません。

読み取り専用のファイルシステムのため、web2pyはセッション、エラーチケット、キャッシュファイルやアップロードファイルをファイルシステムに保存できません。このようなものはファイルシステムではなく、Datastoreに保存しなければいけません。

ここではGAEの簡単な解説とweb2py特有の問題を説明しました。詳細については公式のGAEドキュメントを参考にしてください。

-----
注意：執筆時点ではGAEはPython 2.5しかサポートしていません。それ以外のバージョンでは問題が発生します。また、web2pyはバイナリではなく、ソースディストリビューションを実行する必要があります。
-----

#### 設定

注意すべき3つの設定ファイルがあります：
``
web2py/app.yaml
web2py/queue.yaml
web2py/index.yaml
``:code

``app.yaml``と``queue.yaml``の設定案を、テンプレートファイル``app.example.yaml``と``queue.example.yaml``から簡単に作成できます。 ``index.yaml``はGoogleデプロイメントソフトウェアで自動で作成されたものです。

``app.yaml``は次の構造を持っています（...の部分は省略しています）：

``
application: web2py
version: 1
api_version: 1
runtime: python
handlers:
- url: /_ah/stats.*
  ...
- url: /(?P<a>.+?)/static/(?P<b>.+)
  ...
- url: /_ah/admin/.*
  ...
- url: /_ah/queue/default
  ...
- url: .*
  ...
skip_files:
...
``:code

``app.example.yaml``(``app.yaml``にコピーする時）は、web2pyの``welcome``アプリケーションのデプロイ用に設定できますが、``admin``や``example``アプリケーション用ではありません。Google App Engineに登録したアプリケーションidで、``web2py``を置き換える必要があります。

``url: /(.+?)/static/(.+)``は処理速度を上げるため、web2pyロジックを呼び出すことなく、直接アプリの静的ファイルを提供するようGAEに指示します。

``url:.*``は他の全てのリクエストに、``gaehandler.py``を使うようにweb2pyに指示します。

``skip_files:``セッションは、GAEでデプロイする必要がないファイルのための、正規表現のリストです。次の特定の行について説明します：

``
 (applications/(admin|examples)/.*)|
 ((admin|examples|welcome)\.(w2p|tar))|
``:code

アンパックしたwelcomeの雛形アプリケーションを除いて、デフォルトアプリケーションをデプロイしないようにGAEに指示しています。ここに無視するべきアプリケーションをさらに追加することができます。

アプリケーションidとバージョン設定以外には、``app.yaml``を編集する必要はあまりないかもしれません。もっとも、welcomeアプリケーションは除外するかもしれません。

ファイル``queue.yaml``は、GAEタスクキューを設定するのに使用されます。

ファイル``index.yaml``は、GAEのappserver（Google SDKについてくるwebサーバー）で、アプリケーションをローカルで実行する際に自動で作成されます。中身には以下のコードを含みます：

``
indexes:
- kind: person
  properties:
  - name: name
    direction: desc
``:code

この例ではGAEに、"name"フィールドをアルファベットの降順ソートした、"person"というテーブルのindexを作成するように指示します。対応するindexがないと、アプリケーションで検索やソートを行うことができません。

デプロイメントの前には常にappserverを使って、アプリをローカルで動かし全ての機能を確認することが重要です。これはテスト目的だけではなく、"index.yaml"を自動で作成する目的もあります。
時々このファイルを編集し、重複したエントリーなどを削除したりするなど掃除をしたほうがいいでしょう。

#### 実行とデプロイメント

##### Linux

GAE SDKをインストール済みであるとします。執筆時にはGAEはPython 2.5.2で動作します。以下のappserverコマンドで、"web2py"フォルダ中のアプリケーションを実行できます:

``
python2.5 dev_appserver.py ../web2py
``:code

これでappserverが起動します。そして、次のURLでアプリケーションを実行できます：

``
http://127.0.0.1:8080/
``:code

GAEにアプリケーションをアップロードするには、前述したように"app.yaml"を編集し、適切なアプリケーションidをセットしたことを確認した上で、次を実行します：

``
python2.5 appcfg.py update ../web2py
``:code

##### Mac, Windows

MacやWindowsでは、Google App Engineランチャを使用できます。
次のリンクからダウンロードできます。``gae``:cite

[File][Add Existing Application]を選択し、web2pyフォルダのトップレベルのパスをpathにセットし、そしてツールバーにある[Run]ボタンを押します。ローカルで動作確認できたら、ツールバーにある[Deploy]ボタンをクリックするだけでデプロイできます（アカウントを持っているのが前提です）。

[[image @///image/en9300.png center 300px]]

GAE上でのweb2pyのチケット/エラーは、ログにアクセスしオンライン検索できるGAE管理コンソールに、同様のログが表示されます。

[[image @///image/en9400.png center 300px]]


#### ハンドラの設定

``gaehandler.py``はGAE用に提供されているファイルで、いくつかのオプションがあります。以下はデフォルトの値です：

``
LOG_STATS = False
APPSTATS = True
DEBUG = False
``:code

``LOG_STATS``はページ表示にかかった時間をGAEのログに出力します。

``APPSTATS``はプロファイリング統計を提供するGAE appstatsを有効にします。次のURLでアクセスできます:

``
http://localhost:8080/_ah/stats
``:code

``DEBUG``はデバッグモードをセットします。gluon.settings.web2py_runtimeを使って、コードで明示的にチェックしない限り、実際には違いはありません。

#### ファイルシステムの無効

GAEではファイルシステムにアクセスできません。書き込みのためにファイルを開くこともできません。

このためGAEでは、"upload"フィールドが``uploadfiled``属性を持つ持たないにかかわらず、web2pyは自動で全てのアップロードファイルをデータストアに保存します。

セッションとチケットもデータベースに保存する必要があり、以下のように明示しなければいけません：

``
if request.env.web2py_runtime_gae
    db = DAL('gae')
    session.connect(request,response,db)
else:
    db = DAL('sqlite://storage.sqlite')
``:code

上記のコードはGAEで動作しているかをチェックし、BigTableに接続し、そしてweb2pyにセッションとチケットをそこに保存するように指示します。それ以外の場合はsqliteデータベースに接続します。このコードは雛形アプリケーションの"db.py"に、既に存在しています。

#### Memcache

必要であれば、memcacheにセッションを保存することができます：

``
from gluon.contrib.gae_memcache import MemcacheClient
from gluon.contrib.memdb import MEMDB
cache.memcache = MemcacheClient(request)
cache.ram = cache.disk = cache.memcache

db = DAL('gae')
session.connect(request,response,MEMDB(cache.memcache))
``:code

GAEではcache.ramとcache.diskは使用されるべきでありません、そこでcache.memcacheを使用している点に注意してください。

#### Datastoreの問題

マルチエンティティ・トランザクションが無く、リレーショナルデータベースの標準的な関数を使用できない点で、GAEは他のホスティング環境と異なります。これは高い拡張性への代償です。これらの制限を受け入れることができるなら、GAEは非常に優れたプラットフォームです。そうでない場合は、代わりにリレーショナルデータベースを使った、通常のホスティング・プラットフォームを検討したほうが良いでしょう。

もしGAE上でweb2pyアプリケーションが動作しなかったら、前述した制限の一つが原因です。多くの問題は、web2pyクエリからJOINを削除し、非正規化することで解決します。

Google App Engineは``ListPeroperty``や``StringListProperty``といった、特別なフィールドタイプをサポートします。web2pyは以下の古い構文を使うことで、これらのタイプを使用できます：

``
from gluon.dal import gae
db.define_table('product',
    Field('name'),
    Field('tags', type=gae.StringListProperty())
``:code

もしくは、同等の新しい構文：

``
db.define_table('product',
    Field('name'),
    Field('tags', 'list:string')
``:code

どちらの場合も"tags"フィールドは``StringListProperty``タイプで、値はストリングのリストである必要があります。GAEのドキュメントに互換性に関する記載があります。
we2pyがフォームのコンテキストでフィールドをスマートに扱えること、リレーショナルデータベースでも動作すること、これらの理由により二つ目の記述の方が好ましいです。

同様にListProperty(int)にマッピングする``list:integer``と``list:reference``を、web2pyはサポートします。

``list``タイプの詳細は6章で説明されています。

#### GAEとHTTPS

アプリケーションのidが"myapp"の場合、GAEドメインは

``
http://myapp.appspot.com/
``:code

です。これは、HTTPSでアクセスすることもできます

``
https://myapp.appspot.com/
``:code

この場合、Googleによって提供される"appspot.com"の証明書を使用します。

DNSエントリーの登録で、他のドメイン名でアプリを使用できますが、HTTPSは使用できません。執筆時点で、これはGAEの制限です。

### Jython
``Jython``:inxx

web2pyは普段CPython(C言語で実装されたPythonインタプリタ)で稼動しますが、Jython(Java言語で実装されPythonインタプリタ)でも動作します。これはweb2pyをJavaの基盤で稼働できることを意味します。

web2pyはJythonですぐに実行できますが、JythonやzxJDBC(Jythonのデータベースアダプタ)のセットアップで、いくつかの複雑でトリッキーなことがあります。以下はその手順です：
- ``Jython.org``から "jython_installer-2.5.0.jar" (または 2.5.x) をダウンロードします
- それをインストールします：
``
java -jar jython_installer-2.5.0.jar
``:code
- ``jdbcsource``:citeから"zxJDBC.jar"をダウンロードしインストールします
- ``jdbcjar``:citeから"sqlitejdbc-v056.jar"ファイルをダウンロードしインストールします
- zxJDBCとsqlitejdbcをjavaのCLASSPATHに追加します
- web2pyをJythonで起動します

``
/path/to/jython web2py.py
``:code

執筆時点で、Jythonでは``sqlite``と``postgres``のみサポートされています。


##### 第3版 - 翻訳: Omi Chiba　レビュー: 中垣健志
##### 第4版 - 翻訳: Yota Ichino　レビュー: Hitoshi Kato
