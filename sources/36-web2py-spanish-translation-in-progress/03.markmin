## Descripción general

### Inicio

``Linux``:inxx ``Mac``:inxx ``Windows``:inxx

web2py viene con paquetes binarios para Windows y Mac OS X. Estos paquetes incluyen el intérprete de Python para que no necesites tenerlo pre-instalado. También hay una versión de código fuente que corre en Mac, Linux, y otros sistemas Unix. Las versiones binarias de Windows y OS X incluyen el intérprete de Pyhton requerido. El paquete de código fuente asume que Python está ya instalado en la computadora.

web2py no requiere instalación. Para iniciarlo, descomprime el archivo zip descargado para tu sistema operativo específico y ejecuta el archivo ``web2py`` correspondiente.

En Windows, debes ejecutar:

``
web2py.exe
``:code

En OS X:
``
open web2py.app
``:code

En Unix y Linux, corre desde el código fuente tipeando:
``
python2.5 web2py.py
``:code

Para correr web2py sobre Windows desde el código fuente instala previamente [["Python for Windows extensions" de Mark Hammond http://sourceforge.net/projects/pywin32/]], y luego corre:
``
python2.5 web2py.py
``:code


El programa web2py acepta varias opciones de la línea de comandos que se describen más adelante.

Por defecto, al iniciar, web2py muestra una pantalla de inicio y luego un widget de la GUI que pide que elijas una una contraseña temporaria de administrador, la dirección IP de la interfaz de red a utilizar para el servidor web, y un número de puerto desde el cual se servirán las solicitudes. Por defecto, web2py corre su servidor web en 127.0.0.1:8000 (puerto 8000 en localhost), pero puedes correrlo en cualquier dirección IP y puerto disponible. Puedes consultar la dirección IP de tu interfaz de red abriendo una consola y tipeando ``ipconfig`` en Windows o ``ifconfig`` en OS X y Linux. En adelante asumiremos que web2py está corriendo en localhost (127.0.0.1:8000). Utiliza 0.0.0.0:80 para correr web2py públicamente en cualquiera de tus interfaces de red.

[[image @///image/en400.png center 306px]]

Si no especificas una contraseña administrativa, la interfaz administrativa se deshabilita. Esta es una medida de seguridad para evitar que la interfaz admin quede expuesta públicamente.

El acceso a la interfaz administrativa, **admin**, sólo es posible desde localhost a menos que estés corriendo web2py detrás de Apache con mod_proxy. Si **admin** detecta un proxy, la cookie de la sesión se establece como segura y el login de **admin** no funciona a menos que la comunicación entre el cliente y el proxy sea sobre HTTPS; esta es una medida de seguridad. Todas las comunicaciones entre el cliente y **admin** deben siempre ser o locales o cifradas; de lo contrario un atacante podría realizar un ataque tipo "man-in-the-middle" o "replay attack" y ejecutar código arbitrario en el servidor.

Luego de que la contraseña administrativa ha sido creada, web2py inicia automáticamente el navegador con la dirección:
``
http://127.0.0.1:8000/
``:code

Si la computadora no tiene un navegador por defecto, abre un navegador web e ingresa la URL.

[[image @///image/en500.png center 480px]]

Al hacer clic sobre "interfaz administrativa" se abre la página de login de esa interfaz.

[[image @///image/en600.png center 480px]]

La contraseña del administrador es la seleccionada al inicio del programa.
Ten en cuenta que sólo hay un administrador, y por lo tanto sólo una contraseña administrativa. Por razones de seguridad, se pide al desarrollador que ingrese una nueva contraseña cada vez que web2py inicie a menos que se especifique la opción <recycle>. Esto es diferente a cómo se manejan las contraseñas en las aplicaciones de web2py.

Luego de que el administrador se autentica en web2py, el navegador es redirigido a la página "site".

[[image @///image/en700.png center 480px]]

Esta página lista todas las aplicaciones de web2py instaladas y permite su administración.
web2py viene con tres aplicaciones:
``admin``:inxx ``examples``:inxx ``welcome``:inxx ``scaffolding``:inxx
- Una aplicación llamada **admin**, la que estás utilizando en este momento.
- La aplicación **examples**, con la documentación interactiva en línea y una réplica del sitio oficial de web2py.
- Una aplicación llamada **welcome**. Esta es la plantilla básica para cualquier otra aplicación. Se dice que es la aplicación de andamiaje. Esta es también la aplicación que da la bienvenida al usuario al inicio del programa.

``appliances``:inxx
Las aplicaciones de web2py listas para usar son llamadas "appliances" (artefactos). Hay muchas appliances disponibles para descarga gratuita en ``appliances``:cite . Invitamos a los usuarios de web2py a que suban nuevas appliances, tanto de código abierto como de código cerrado (compiladas y empaquetadas).

Desde la página "site" de la aplicación **admin**, puedes realizar las siguientes operaciones:
- **instalar** una aplicación completando el formulario en la parte inferior derecha de la página. Especifica el nombre de la aplicación, selecciona el archivo conteniendo una aplicación empaquetada o la URL donde se ubica la aplicación, y haz clic en "submit".
- **desinstalar** una aplicación haciendo clic en el botón correspondiente. Se muestra una página de confirmación.
- **crear** una nueva aplicación especificando un nombre y haciendo clic en "crear".
- **empaquetar** una aplicación para su distribución haciendo clic en el botón correspondiente. La descarga de la aplicación es un archivo .tar conteniendo todo, incluyendo la base de datos. No deberías descomprimir este archivo; es automáticamente descomprimido por web2py cuando se instala a través de **admin**.
- **limpiar** los archivos temporarios de la aplicación, como sesiones, errores y archivos de caché.
- **EDITAR** la aplicación.

-----
Cuando creas una nueva aplicación utilizando **admin**, esta se instala como un clon de la app de andamiaje "welcome" con un archivo "models/db.py" que crea una base de datos SQLite, conecta a ella, instancia Auth, Crud, y Service, y los configura. Además provee un archivo "controllers/default.py", que expone las acciones "index", "download", "user" para el manejo de usuarios, y "call" para los servicios. En adelante, asumiremos que estos archivos se han eliminado; vamos a crear apps de cero.
-----

-----
web2py también viene con un **asistente**, descripto más adelante en este capítulo, que puede escribir código alternativo de andamiaje automáticamente basado en plantillas y plugins disponibles en la web y basándose en descripciones de nivel alto de los modelos.
-----

### Di hola
``index``:inxx

Aquí, como ejemplo, crearemos una app web simple que muestre el mensaje "Hola desde MiApp" al usuario. Llamaremos a esta aplicación "miapp". Además añadiremos un contador que realice un conteo de cuántas veces el mismo usuario visita la página.

Puedes crear una nueva aplicación con sólo tipear su nombre en el formulario de la parte superior derecha de la página **site** en **admin**.

[[image @///image/en800.png center 447px]]

Luego de que presiones el botón de [crear], la aplicación se genera como copia de la aplicación welcome incorporada.

[[image @///image/en900.png center 480px]]

Para correr la aplicación, visita:
``
http://127.0.0.1:8000/miapp
``:code

Ahora tienes una copia de la aplicación welcome.

Para editar una aplicación, haz clic en el botón ''editar'' para la aplicación recién creada.

La página para **editar** te muestra lo que contiene la aplicación.
Cada aplicación de web2py consiste de ciertos archivos, que en su mayoría caen en las siguientes categorías:
- **modelos**: describen la representación de los datos.
- **controladores**: describen el workflow o flujo de trabajo de la aplicación.
- **vistas**: describen la presentación de los datos.
- **idiomas**: describen como se debe traducir la presentación de la aplicación a otros idiomas.
- **módulos**: módulos de Python que pertenecen a la aplicación.
- **archivos estáticos**: imágenes estáticas, archivos CSS ``css-w,css-o,css-school``:cite , archivos JavaScript ``js-w,js-b``:cite , etc.
- **plugin**: grupos de archivos diseñados para trabajar en conjunto.

Todo está prolíjamente organizado según el patrón de diseño Modelo-Vista-Controlador. Cada sección en la página ''editar'' corresponde a una subcarpeta en la carpeta de la aplicación.

Nótese que los encabezados de sección se contraen o expanden. Los nombres de las carpetas bajo archivos estáticos también tienen esta propiedad.

-------
Cada archivo listado en la sección corresponde a un archivo con una ubicación física en la subcarpeta. Toda operación realizada en un archivo a través de la interfaz **admin** (crear, editar, eliminar) se puede realizar directamente desde la shell utilizando nuestro editor favorito.
-------

La aplicación contiene otros tipos de archivos (bases de datos, archivos de sesiones, archivos de errores, etc.), pero no se listan en la página ''editar'' porque no son creadas o modificadas por el administrador; esos archivos son creados y modificados por la aplicación misma.

Los controladores contienen la lógica y flujo de trabajo de la aplicación. Cada URL se asocia a una llamada a una de las funciones en los controladores (acciones). Hay dos controladores por defecto: "appadmin.py" y "default.py". **appadmin** provee de una interfaz administrativa para la base de datos; por ahora no la usaremos. "default.py es el controlador que debes editar, que es el que se va a llamar por defecto cuando no se especifique el controlador en la URL. Modifica la función "index" de esta forma:
``
def index():
    return "Hola desde MiApp"
``:code

Así es como se ve el editor web:

[[image @///image/en1000.png center 480px]]

Guárdalo y regresa a la página de ''editar''. Haz clic en el link de index para visitar la nueva página creada.

Cuando visitas la URL
``
http://127.0.0.1:8000/myapp/default/index
``:code

se llama a la acción index en el controlador por defecto (default). Este devuelve la cadena que el navegador va a mostrarnos. Debería verse algo como esto:

[[image @///image/en1100.png center 480px]]

Ahora, modifica la función "index" como sigue:
``
def index():
    return dict(mensaje="Hola desde MiApp")
``:code

También desde la página ''editar'', modifica la vista "default/index.html" (el archivo de vista asociado a la acción) y reemplaza completamente los contenidos de ese archivo con lo siguiente:
``
<html>
   <head></head>
   <body>
      <h1>{{=mensaje}}</h1>
   </body>
</html>
``:code

Ahora la acción devuelve un diccionario que define un ``mensaje``. Cuando una acción devuelve un diccionario, web2py busca una vista con el nombre

``[controller]/[function].[extension]``:code

y la ejecuta. Aquí [extension] es la extensión de la solicitud. Si no se especifica la extensión, se toma "html" por defecto, que es la extensión que utilizaremos para este caso. Con estas especificaciones, la vista es un archivo con HTML que incrusta o embebe código Python utilizando etiquetas especiales con {{ }}. En particular, en el ejemplo, el ``{{=mensaje}}`` ordena a web2py que reemplace el código entre etiquetas con el valor de ``message`` devuelto por la acción. Nótese que ``mensaje`` aquí no es una palabra especial (keyword) sino que se definió en la acción. Hasta aquí no hemos utilizado keyword de web2py.

Si web2py no encuentra la vista solicitada, utiliza una vista llamada "generic.html" que viene con cada aplicación.

-------
``Mac Mail``:inxx ``Google Maps``:inxx ``jsonp``:inxx
Si se especifica una extensión que no sea "html" (por ejemplo "json"), y el archivo de la vista "[controlador]/[función].json" no se encuentra, web2py busca la vista genérica "generic.json". web2py viene con generic.html, generic.json, generic.jsonp, generic.xml, generic.rss, generic.ics (para Mac Mail Calendar), generic.map (para incrustar Google Maps), y generic.pdf (basado en fpdf). Estas vistas genéricas se pueden modificar para cada aplicación individualmente, y se pueden agregar vistas adicionales fácilmente.
-------

-------
Las vistas genéricas son herramientas de desarrollo. En producción cada acción debería tener su propia vista. De hecho, por defecto, las vistas genéricas sólo están habilitadas para localhost.
-------

-------
También puedes especificar una vista con ``response.view = 'default/something.html'``
-------

Consulta más detalles sobre este tema en el Capítulo 10.

Si regresas a ''EDITAR'' y haces clic en index, verás la nueva página HTML:

[[image @///image/en1200.png center 480px]]

Con fines de depuración siempre puedes añadir
``
{{=response.toolbar()}}
``:code

al código de la vista y te mostrará algunos datos útiles, incluyendo los objetos request, response y session, y una lista de todas las consultas a la base de datos cronometradas.

### Contemos
``session``:inxx
Ahora vamos a agregar un contador a esta página que llevará la cuenta de cuántas veces el mismo visitante muestra la página.

web2py automática y transparentemente registra a los usuarios utilizando sesiones y cookie. Para cada nuevo visitante, crea una sesión y le asigna un "session_id" único. El session es un contenedor para variables que se almacenan del lado del servidor. La clave única id es enviada al navegador a través de una cookie. Cuando el visitante solicita otra página desde la misma aplicación, el navegador envía la cookie de regreso, es recuperada por web2py, y se reactiva la sesión correspondiente.

Para utilizar el session, modifica el controlador por defecto (default):
``
def index():
    if not session.contador:
        session.contador = 1
    else:
        session.contador += 1
    return dict(mensaje="Hola desde MiApp", contador=session.contador)
``:code

Ten en cuenta que ``contador`` no es una palabra especial de web2py pero sí lo es ``session``. Le pedimos a web2py que revise si existe una variable contador en session y, si no es así, que cree una con un valor inicial de 1. Si el contador ya existe, le pedimos a web2py que lo aumente en una unidad. Finalmente le pasamos el valor del contador a la vista.

Una forma más compacta de declarar la misma función es:
``
def index():
    session.contador = (session.contador or 0) + 1
    return dict(mensaje="Hola desde MiApp", contador=session.contador)
``:code

Ahora modifica la vista para agregar una línea que muestre el valor del contador:
``
<html>
   <head></head>
   <body>
      <h1>{{=mensaje}}</h1>
      <h2>Cantidad de visitas: {{=contador}}</h2>
   </body>
</html>
``:code

Cuando visitas la página index nuevamente (y otra vez), deberías obtener la siguiente página HTML:

[[image @///image/en1300.png center 480px]]

El contador está asociado a cada visitante, y se incrementa cada vez que el visitante vuelve a cargar la página. Cada visitante ve un contador distinto.

### Di mi nombre
``form``:inxx ``request.vars``:inxx

Ahora crea dos páginas (primera y segunda), donde la primera página crea un formulario, le pide el nombre al visitante, y redirige a la segunda página, que crea un mensaje de bienvenida personalizado.

[[yUML diagram @///image/en1400.png center 293px]]

Escribe las acciones correspondientes en el controlador default:
``
def primera():
    return dict()

def segunda():
    return dict()
``:code

Luego crea una vista "default/primera.html" para la primera acción,
e ingresa:
``
{{extend 'layout.html'}}
¿Cuál es tu nombre?
<form action="segunda">
  <input name="nombre_del_visitante" />
  <input type="submit" />
</form>
``:code

Finalmente, crea una vista "default/segunda.html" para la segunda acción:
``
{{extend 'layout.html'}}
<h1>Hello {{=request.vars.nombre_del_visitante}}</h1>
``:code

``layout``:inxx
En ambas vistas hemos extendido el "layout.html" básico que viene con web2py. La vista layout (plantilla general) mantiene la apariencia/estilo entre dos páginas coherente. El archivo de layout se puede modificar y reemplazar fácilmente, ya que principalmente contiene código HTML.

Si ahora visitas la primera página, e ingresa tu nombre:

[[image @///image/en1500.png center 480px]]

y aceptas el formulario, recibirás un mensaje de bienvenida:

[[image @///image/en1600.png center 480px]]

### Postback
``redirect``:inxx ``URL``:inxx ``postback``:inxx

El mecanismo para envío de formularios que hemos utilizado antes es muy común, pero no es una buena práctica de programación. Todos los datos ingresados deberían validarse y, en el ejemplo anterior, la tarea de validación recaería en la segunda acción. De esa forma, la acción que realiza la validación es distinta a la que ha generado el formulario. Esto tiende a la redundancia en el código.

Un patrón más apropiado para el envío de formularios es enviarlos a la misma acción que los generó, en nuestro caso "primera". La acción "primera" debería recibir las variables, procesarlas, almacenarlas del lado del servidor, y redirigir al visitante a la página "segunda", que recupera las variables. Este mecanismo se denomina "postback".

[[yUML diagram @///image/en1700.png center 293px]]

Modifica el controlador default para implementar el auto-envío:
``
def primera():
    if request.vars.nombre_del_visitante:
        session.visitor_name = request.vars.nombre_del_visitante
        redirect(URL('segunda'))
    return dict()

def segunda():
    return dict()
``:code

Y ahora modifica la vista "default/primera.html":
``
{{extend 'layout.html'}}
¿Cuál es tu nombre?
<form>
  <input name="nombre_del_visitante" />
  <input type="submit" />
</form>
``:code

y la vista "default/segunda.html" necesita recuperar la información de ``session`` en lugar de "request.vars":
``
{{extend 'layout.html'}}
<h1>Hola {{=session.nombre_del_visitante or "anónimo"}}</h1>
``:code

Desde el punto de vista del visitante, el auto-envío se comporta exactamente igual que con la implementación anterior. No hemos añadido validación todavía, pero ahora está claro que la validación debería realizarla la primera acción.

Esta estrategia es mejor además porque el nombre del visitante se mantiene en la sesión, y permanece accesible en toda acción o vista en las aplicaciones sin que sea necesario pasarlo explícitamente.

Ten en cuenta que si la acción "segunda" se llamara antes de establecer el nombre del visitante, mostrará "Hola anónimo" porque ``session.nombre_del_visitante`` devuelve ``None``. Como alternativa podríamos haber agregado el siguiente código en el controlador (en la función "segunda"):
``
if not request.function=='primera' and not session.nombre_del_visitante:
    redirect(URL('primera'))
``:code

Este es el mecanismo general que puedes utilizar para un mayor control de la autorización en los controladores, aunque puedes consultar un método más eficiente en el Capítulo 9.

``FORM``:inxx ``INPUT``:inxx ``requires``:inxx ``IS_NOT_EMPTY``:inxx ``accepts``:inxx

Con web2py podemos avanzar aun más y pedirle que genere los formularios por nosotros, incluyendo la validación. web2py provee de ayudantes (FORM, INPUT, TEXTAREA, y SELECT/OPTION) con nombres equivalentes a las etiquetas de HTML. Estos ayudantes pueden utilizarse para crear formularios tanto en el controlador como en la vista.

Por ejemplo, aquí se muestra una posible forma de reescribir la primera acción:
``
def primera():
    form = FORM(INPUT(_name='nombre_del_visitante', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.nombre_del_visitante = form.vars.nombre_del_visitante
        redirect(URL('segunda'))
    return dict(form=form)
``:code

donde decimos que la etiqueta FORM contiene dos etiquetas INPUT. Los atributos de las etiquetas se especifican con pares nombre/argumento (named arguments) que comienzan con subguión ("_"). El argumento ``requires`` no es un atributo de etiqueta (porque no comienza con subguión) pero establece un validador para el valor de nombre_del_visitante.

Aquí tenemos una forma todavía mejor de crear el mismo formulario:

``
def primera():
    form = SQLFORM.factory(Field('nombre_del_visitante', requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        session.nombre_del_visitante = form.vars.nombre_del_visitante
        redirect(URL('segunda'))
    return dict(form=form)
``:code

El objeto ``form`` puede serializarse fácilmente en HTML al incrustarlo en la vista "default/primera.html".
``
{{extend 'layout.html'}}
¿Cuál es tu nombre?
{{=form}}
``:code

El método ``form.process()`` aplica los validadores y devuelve el formulario en sí. La variable ``form.accepted`` se establece como True si el formulario se procesó y pasó la validación. Si el formulario auto-enviado pasa la validación, almacena las variables en la sesión y redirige como antes. Si el formulario no pasa la validación, se insertan mensajes de error en él y se muestran al usuario, como se muestra a continuación:

[[image @///image/en1800.png center 480px]]

En la próxima sección vamos a mostrar como los formularios pueden crearse automáticamente desde el modelo.

### Un blog de imágenes
``upload``:inxx

Aquí, como nuevo ejemplo, queremos crear una aplicación web que permita al administrador publicar imágenes y asignarles un nombre, y que permita a los usuarios del sitio web ver las imágenes rotuladas y enviar comentarios.

Como antes, desde la página **site** en **admin**, crea una nueva aplicación llamada ``imagenes``, y navega hasta la página de "editar":

[[image @///image/en1900.png center 480px]]

Comenzamos creando un modelo, una representación de los datos permamentes en la aplicación (las imágenes a subir, sus nombres y los comentarios). Primero, necesitas crear/modificar un archivo de modelo que, por falta de imaginación,  llamaremos "db.py". Suponemos que el código a continuación reemplazará todo código existente en "db.py". Los modelos y los controladores deben ``.py`` como extensión porque son código fuente de Python. Si la extensión no se provee, web2py la agrega automáticamente. Las vistas en cambio tienen ``.html`` como extensión ya que principalmente contienen código HTML.

Modifica el archivo "db.py" haciendo clic en el botón "editar" correspondiente:

[[image @///image/en2000.png center 480px]]

e ingresa lo siguiente:

``IS_EMAIL``:inxx ``IS_NOT_EMPTY``:inxx ``IS_IN_DB``:inxx
``
db = DAL("sqlite://storage.sqlite")

db.define_table('imagen',
   Field('titulo', unique=True),
   Field('archivo', 'upload'),
   format = '%(titulo)s')

db.define_table('comentario',
   Field('imagen_id', 'reference image'),
   Field('autor'),
   Field('email'),
   Field('cuerpo', 'text'))

db.image.titulo.requires = IS_NOT_IN_DB(db, db.imagen.titulo)
db.comentario.imagen_id.requires = IS_IN_DB(db, db.imagen.id, '%(titulo)s')
db.comentario.autor.requires = IS_NOT_EMPTY()
db.comentario.email.requires = IS_EMAIL()
db.comentario.cuerpo.requires = IS_NOT_EMPTY()

db.comentario.imagen_id.writable = db.comentario.imagen_id.readable = False
``:code

Analicemos esto línea a línea.

La línea 1 define una variable global llamada ``db`` que representa la conexión de la base de datos. En este caso es una conexión a una base de datos SQLite almacenada en el archivo "applications/imagenes/databases/storage.sqlite". Para el caso de SQLite, si la base de datos no existe, se crea una nueva. Puedes cambiar el nombre del archivo, así como también el nombre de la variable global ``db``, pero es conveniente que se les dé el mismo nombre, para que sea más fácil recordarlos.

Las líneas 3-5 definen una tabla "imagen". ``define_table`` es un método del objeto ``db``. El primer argumento "imagen", es el nombre de la tabla que estamos definiendo. Los otros argumentos son los campos que pertenecen a la tabla. Esta tabla tiene un campo denominado "titulo", otro llamado "archivo", y un campo llamado "id" que sirve como clave primaria ("id" no se declara explícitamente porque todas las tablas tienen un campo id por defecto). El campo "titulo" es una cadena, y el campo "archivo" es de tipo "upload". "upload" es un tipo de campo especial usado por la Capa de Abstracción de Datos (DAL) de web2py para almacenar los nombres de los archivos subidos. web2py sabe como subir archivos (por medio de streaming si son grandes), cambiarles el nombre por seguridad, y almacenarlos.

Cuando se define una tabla, web2py realiza una de muchas acciones posibles:
- Si la tabla no existe, la tabla es creada;
- Si la tabla existe y no se corresponde con la definición, la tabla se modifica apropiadamente, y si un campo tiene un tipo distinto, web2py intenta la conversión de sus contenidos.
- Si la tabla existe y se corresponde con la definición, web2py no realiza ninguna acción.

Este comportamiento se llama "migración" (migration). En web2py las migraciones son automáticas, pero se pueden deshabilitar por tabla pasando ``migrate=False`` como último argumento de ``define_table``.

La línea 6 define una cadena de formato para la tabla. Esto determina cómo un registro debería representarse como cadena. Nótese que el argumento ``format`` también puede ser una función que toma un registro y devuelve una cadena. Por ejemplo:
``
format=lambda row: row.titulo
``:code

Las líneas 8-12 definen otra tabla llamada "comentario".
Un comentario tiene un "autor", un "email" (vamos a guardar la dirección de correo electrónico del autor del comentario), un "cuerpo" de tipo "text" (queremos utilizarlo para guardar el comentario en sí publicado por el autor), y un campo "image_id" de tipo reference que apunta a ``db.imagen`` por medio del campo "id".

En la línea 14, ``db.imagen.titulo`` representa el campo "titulo" de la tabla "imagen". El atributo ``requires`` te permite configurar requerimientos/restricciones que se controlarán por medio de los formularios de web2py. Aquí requerimos que "titulo" no se repita:

``IS_NOT_IN_DB(db, db.imagen.titulo)``:code

"Ten en cuenta que esto es opcional porque se configura automáticamente siempre que se especifique ``Field('titulo', unique=True)``".

Los objetos que representan estas restricciones se llaman validadores (validators). Se pueden agrupar múltiples validadores en una lista. Los validadores se ejecutan en el orden en que se especifican.
``IS_NOT_IN_DB(a, b)`` es un validador especial que comprueba que el valor de un campo ``b`` para un nuevo registro no exista previamente en ``a``.


La línea 15 requiere que el campo "imagen_id" de la tabla "comentario" esté en ``db.imagen.id``. En lo que respecta a la base de datos, ya lo habíamos declarado al definir la tabla "comentario".
Ahora estamos diciendo explícitamente al modelo que esta condición debería ser controlada por web2py también en el nivel del procesamiento de los formularios cuando se publica un comentario, para que los datos inválidos no se propaguen desde los formularios de ingreso a la base de datos. Además requerimos que la "imagen_id" se represente por el "titulo", ``'%(titulo)s'``, del registro correspondiente.

La línea 20 indica que el campo "imagen_id" de la tabla "comentario" no debería mostrarse en formularios, ``writable=False`` y tampoco en formularios de sólo-lectura, ``readable=False``.

El significado de los validadores en las líneas 15-17 debería de ser obvio.

``format``:inxx
Ten en cuenta que el validador
``
db.comentario.imagen_id.requires = IS_IN_DB(db, db.imagen.id, '%(titulo)s')
``:code

se puede omitir (y se configuraría automáticamente) si especificáramos un formato para una tabla referenciada:
``
db.define_table('imagen', ..., format='%(titulo)s')
``:code

donde el formato puede ser una cadena o una función que toma un registro y devuelve una cadena.

``appadmin``:inxx

Una vez que el modelo se ha definido, si no hay errores, web2py crea una interfaz de la applicación para administrar la base de datos. Puedes acceder a ella a través del link "administración de la base de datos" en la página "editar" o directamente:
``
http://127.0.0.1:8000/imagenes/appadmin
``:code

Aqu se muestra una captura de la interfaz **appadmin**:

[[image @///image/en2100.png center 480px]]

Esta interfaz se escribe en el controlador llamado "addpadmin.py" y la vista "appadmin.html" correspondiente. En adelante, nos referiremos a esta interfaz como "appadmin.py". Esta interfaz permite al administrador insertar nuevos registros de la base de datos, editar y eliminar registros existentes, examinar las tablas y hacer consultas tipo join en la base de datos.

La primera vez que se accede a **appadmin**, se ejecuta el modelo y se crean las tablas. La DAL de web2py traduce el código Python en comandos SQL específicos del motor de base de datos implementado (en este ejemplo SQLite). Puedes ver el SQL generado desde la página "editar" haciendo clic en el link "sql.log" debajo de "modelos". Ten en cuenta que el link no está disponible si no se crean las tablas.

[[image @///image/en2200.png center 480px]]

Si editas el modelo y accedes a **appadmin** de nuevo, web2py generará SQL para alterar las tablas existentes. El SQL generado se registra en "sql.log".

Regresa a **appadmin** y prueba insertando un nuevo registro:

[[image @///image/en2300.png center 480px]]

web2py ha traducido el campo tipo "upload" ``db.imagen.archivo`` en un formulario para subir el archivo. Cuando el formulario se acepta y se sube una imagen, el archivo se cambia de nombre por seguridad conservando la extensión, se guarda con el nuevo nombre en la carpeta "uploads" de la aplicación, y se almacena el nuevo nombre el campo ``db.imagen.archivo``. Este mecanismo está diseñado para prevenir los ataques de tipo directory traversal.

Ten en cuenta que cada tipo de campo es procesado por un "widget". Los widget por defecto se pueden reemplazar (override).

Cuando haces clic en un nombre de tabla en **appadmin**, web2py realiza un select de todos los registros de la tabla elegida, encontrados por la consulta a la base de datos o query
``
db.imagen.id > 0
``:code

y convierte el resultado (render).

[[image @///image/en2400.png center 480px]]

Puedes seleccionar un set distinto de registros editando la consulta SQL y presionando [Enviar].

Para modificar o eliminar un solo registro, haz clic en su número id.

Por causa del validador ``IS_IN_DB``, el campo de referencia "imagen_id" se convierte en un menú desplegable (drop-down). Los ítem en el menú son claves (``db.imagen.id``), pero se representan con el campo ``db.imagen.titulo``, como se especificó al crear el validador.

Los validadores son objetos muy potentes que saben como representar campos, filtrar sus valores, generar errores, y dar formato a los datos extraídos del campo.

La siguiente figura muestra qué pasa cuando se acepta un formulario que no pasa la validación:

[[image @///image/en2500.png center 480px]]

Los mismos formularios que se generan automáticamente en **appadmin** pueden también generarse en forma programática a través del ayudante ``SQLFORM`` e embebidos en aplicaciones del usuario. Estos formularios son aptos para CSS (CSS-friendly), y se pueden personalizar.

Cada aplicación tiene su propio **appadmin**; por lo tanto, el mismo **appadmin** puede modificarse sin que se afecten otras aplicaciones.

Hasta aquí, la aplicación sabe cómo almacenar la información, y hemos visto cómo acceder a la base de datos a través de **appadmin**. El acceso a **appadmin** está restringido al administrador, y no está pensado como una interfaz web de producción para la aplicación; De ahí la próxima parte de este tutorial paso a paso. Específicamente queremos crear:
- Una página "index" que liste todas las imágenes disponibles ordenadas por título y links a páginas con detalles para las imágenes.
- Una página "mostrar/[id]" que muestre al visitante la imagen solocitada y le permita ver y publicar comentarios.
- Una acción "download/[nombre]" para la descarga de las imágenes subidas.

Esto se muestra esquemáticamente aquí:

[[yUML diagram @///image/en2600.png center 480px]]

Regresa a la página "editar" y modifica el controlador "default.py", reemplazando sus contenidos con lo que sigue:

``select``:inxx
``
def index():
    imagenes = db().select(db.imagen.ALL, orderby=db.imagen.titulo)
    return dict(imagenes=imagenes)
``:code

Esta acción devuelve un diccionario. Las claves de los ítem en el diccionario se interpretan como variables pasadas a la vista asociada a la acción. Durante el desarrollo, si no hay una vista, la acción es convertida (render) por la vista "generic.html" que se provee con cada aplicación de web2py.

La acción de index realiza una consulta select de todos los campos (``db.imagen.ALL``) de la tabla imagen, ordenados por ``db.imagen.titulo``. El resultado del select es un objeto ``Rows`` que contiene los registros. Se asigna a una variable local llamada imagenes devuelta por la acción a la vista. ``imagenes`` es iterable y sus elementos son los registros consultados. Para cada fila (row) las columnas se pueden examinar como diccionarios:
``imagenes[0]['titulo']`` o ``imagenes[0].titulo`` con igual resultado.

Si no escribes una vista, el diccionario es convertido por "views/generic.html" y una llamada a la acción index se vería de esta forma:

[[image @///image/en2700.png center 480px]]

No has creado una vista por esta acción todavía, así que web2py convierte el set de registros en un formulario tabular simple.

Ahora crea una vista para la acción index. Regresa a admin, edita "default/index.html" y reemplaza su contenido con lo que sigue:
``
{{extend 'layout.html'}}
<h1>Imagenes registradas</h1>
<ul>
{{for imagen in imagenes:}}
{{=LI(A(imagen.titulo, _href=URL("mostrar", args=imagen.id)))}}
{{pass}}
</ul>
``:code

Lo primero a tener en cuenta es que una vista es HTML puro con etiquetas {{...}} especiales. El código incrustado en {{...}} es código Python puro con una salvedad: la indentación o espaciado no es relevante. Los bloques de código comienzan con líneas que terminan en dos puntos (:) y terminan en líneas que comienzan con la palabra clave ``pass``. En algunos casos el final de un bloque es obvio teniendo en cuenta el contexto y no es necesario el uso de ``pass``.

Las líneas 5-7 recorren las filas de las imágenes y para cada fila (row) muestran:
``
LI(A(imagen.titulo, _href=URL('mostrar', args=imagen.id))
``:code

Se trata de una etiqueta ``<li>...</li>`` que contiene una etiqueta ``<a href="...">...</a>`` que contiene el campo ``imagen.titulo``. El valor del hipervínculo o hypertext reference (atributo href) es:
``
URL('mostrar', args=imagen.id)
``:code

Es decir, el URL en el ámbito de la misma aplicación y controlador que la solicitud (request) actual que llama a una función llamada "mostrar", pasándole un argumento único ``args=imagen.id`` a esa función.
``LI``, ``A``, etc. son ayudantes de web2py que están asociados a las etiquetas HTML correspondientes. Sus argumentos sin nombre se interpretan como objetos a serializar e insertar en el HTML incluído en la etiqueta. Los argumentos por nombre que comienzan con subguión (por ejemplo ``_href``) son interpretados como atributos de la etiqueta sin el subguión. Por ejemplo ``_href`` es el atributo ``href``, ``_class`` es el atributo ``class``, etc.

Por ejemplo, el siguiente comando:
``
{{=LI(A('algo', _href=URL('mostrar', args=123))}}
``:code

se convierte en:
``
<li><a href="/imagenes/default/mostrar/123">algo</a></li>
``:code

Algunos ayudantes (``INPUT``, ``TEXTAREA``, ``OPTION`` y ``SELECT``) también aceptan algunos atributos especiales que no comienzan con subguión (``value``, y ``requires``). Estos parámetros son importantes para la creación de formularios y se tratarán más adelante.

Vuelve a la página "editar". Ahora nos indica que "default.py" expone "index". Haciendo clic en "index", puedes visitar la nueva página creada:
``
http://127.0.0.1:8000/imagenes/default/index
``:code

que se ve así:

[[image @///image/en2800.png center 480px]]

Si haces clic en el link del nombre de la imagen, el navegador abre la dirección:
``
http://127.0.0.1:8000/imagenes/default/mostrar/1
``:code

y esto resulta en un error, ya que todavía no has creado una acción llamada "mostrar" en el controlador "default.py".

Editemos el controlador "default.py" y reemplazando su contenido con:

``SQLFORM``:inxx ``accepts``:inxx ``response.flash``:inxx ``request.args``:inxx
``response.download``:inxx
``
def index():
    imagenes = db().select(db.imagen.ALL, orderby=db.imagenes.titulo)
    return dict(images=images)

def mostrar():
    imagen = db(db.imagen.id==request.args(0,cast=int)).select().first()
    db.comentario.imagen_id.default = imagen.id
    form = SQLFORM(db.comentario)
    if form.process().accepted:
        response.flash = 'tu comentario se ha publicado'
    comentarios = db(db.comentario.imagen_id==image.id).select()
    return dict(imagen=imagen, comentarios=comentarios, form=form)

def download():
    return response.download(request, db)
``:code

El controlador contiene dos acciones: "mostrar" y "download".
La acción "mostrar" selecciona la imagen con el ``id`` leído (parse) de request args y todos los comentarios asociados a la imagen. a continuación, "mostrar" pasa todo a la vista "default/mostrar.html".

El id de la imagen en la referencia de:
``
URL('mostrar', args=imagen.id)
``:code

en "default/index.html", se puede consultar como:

``request.args(0,cast=int)``

desde la acción "mostrar". El argumento ``cast=int`` es opcional pero muy importante. Intenta convertir (cast) la cadena pasada en PATH_INFO a un int. En caso de fallar genera la excepción apropiada en lugar de generar un ticket. También se puede hacer una redirección en caso de un fallo al convertir el dato:

``request.args(0,cast=int,otherwise=URL('error'))``

La acción "download" espera un nombre de archivo en ``request.args(0)``, arma la ruta a la ubicación donde se supone que se ha almacenado el archivo, y lo devuelve al cliente. Si el archivo es demasiado grande, lo transfiere por medio de un stream sin sobrecargar la memoria (overhead).

Ten en cuenta los siguientes comandos:
- La línea 7 crea un formulario de inseción SQLFORM para la tabla ``db.comentario`` utilizando sólo los campos especificados.
- La línea 8 configura el valor del campo de referencia, que no es parte del formulario de ingreso de datos porque no está en la lista de campos especificados arriba.
- La línea 9 procesa el formulario enviado (las variables del formulario están en ``request.vars``) en el contexto de la sesión actual (la sesión se usa para prevenir envíos duplicados y para facilitar la navegación). Si las variables del formulario se validan, el nuevo comentario se inserta en la tabla ``db.comment``; de lo contrario el formulario se modifica para incluír los mensajes de error (por ejemplo, si el email del autor no es válido). ¡Todo esto lo hace la línea 9!
- La línea 10 se ejecuta únicamente cuando el formulario se acepta, luego de que el registro se inserte en la base de datos. ``response.flash`` es una variable que se muestra en las vistas y es utilizada para notificar al visitante cuando se detecta un evento en la aplicación.
- La línea 11 selecciona todos los comentarios que refieren o apuntan a la imagen actual.

-------
La acción "download" (descargar) ya está definida en el controlador "default.py" de la aplicación de andamiaje.
-------

La acción "download" no devuelve un diccionario, por lo que no necesita una vista. La acción "mostrar", sin embargo, debería tener una vista, entonces regresa al **admin** y crea una nueva vista llamada "default/mostrar.html"

Modifica este archivo y reemplaza su contenido con lo siguiente:
``
{{extend 'layout.html'}}
<h1>Imagen: {{=imagen.titulo}}</h1>
<center>
<img width="200px"
     src="{{=URL('download', args=imagen.archivo)}}" />
</center>
{{if len(comentarios):}}
  <h2>Comentarios</h2><br /><p>
  {{for comentario in comentarios:}}
    <p>{{=commentario.autor}} dice <i>{{=comentario.cuerpo}}</i></p>
  {{pass}}</p>
{{else:}}
  <h2>Todavía no se han publicado comentarios</h2>
{{pass}}
<h2>Publica un comentario</h2>
{{=form}}
``:code

Esta vista muestra el **imagen.archivo** llamando a la acción "download" dentro de una etiqueta ``<img .../>``.
Si hay comentarios, los recorre en un bucle y muestra cada uno.

Así es como se verá para el visitante:

[[image @///image/en2900.png center 480px]]

Cuando un visitante envía un comentario a través de esta página, el comentario se almacena en la base de datos y se agrega al final de la página.


### Habilitando las ABM (CRUD)

web2py también viene con una API para altas bajas y modificaciones o CRUD (Create/Read/Update/Delete) que simplifica los formularios todavía más. Para usar CRUD necesitamos definirla en alguna parte, por ejemplo en "db.py":
``
from gluon.tools import Crud
crud = Crud(db)
``:code

-------
Esas dos líneas de código ya vienen con la aplicación de andamiaje.
-------

El objeto ``crud`` provee métodos de alto nivel, por ejemplo:
``
form = crud.create(tabla)
``:code

Que se puede utilizar en reemplazo del patrón de programación:
``
form = SQLFORM(tabla)
if form.process().accepted:
    session.flash = '...'
    redirect('...')
``:code

Aquí, reescribimos la acción "mostrar" previa usando crud y agregando algunas mejoras:
``
def mostrar():
    imagen = db.image(request.args(0,cast=int)) or redirect(URL('index'))
    db.comentario.imagen_id.default = imagen.id
    form = crud.create(db.comentario,
                       mensaje='Se ha publicado tu comentario',
		       next=URL(args=imagen.id))
    comentario = db(db.comentario.imagen_id==imagen.id).select()
    return dict(imagen=imagen, comentarios=comentarios, form=form)
``:code

Antes que nada observa que hemos usado la sintaxis
``
db.image(request.args(0,cast=int)) or redirect(...)
``:code

para recuperar el registro requerido. Como ``tabla(id)`` devuelve None si el registro no existe, podemos usar ``or redirect(...)`` en una sóla línea.

El argumento ``next`` de ``crud.create`` es el URL al cual se redirige si se acepta el formulario. El argumento ``mensaje`` es el que se mostrará al aceptar los datos. Puedes leer más acerca de CRUD en el capítulo 7.

### Agregando la Autenticación

La API de web2py para el Control de Acceso Basado en Roles es bastante sofisticado, pero por ahora vamos a limitarnos a restringir el el acceso a la acción mostrar a los usuarios autenticados, dejando una descripción más detallada para el capítulo 9.

Para limitar el acceso a los usuarios autenticados, debemos completar tres pasos. En un modelo, por ejemplo "db.py", debemos añadir:
``
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables()
``:code

En nuestro controlador, tenemos que agregar una acción:
``
def user():
    return dict(form=auth())
``:code

Esto es suficiente para habilitar el login (autenticación), logout (cerrar sesión), etc. La plantilla general del diseño (layout) además mostrará opciones en las que requieran autenticación en la parte superior derecha del navegador.

[[image @///image/en3000.png center 300px]]

Ahora podemos decorar las funciones que queremos restringir, por ejemplo:
``
@auth.requires_login()
def mostrar():
    imagen = db.imagen(request.args(0,cast=int)) or redirect(URL('index'))
    db.comentario.imagen_id.default = imagen.id
    form = crud.create(db.comentario, next=URL(args=imagen.id),
                     mensaje='se ha publicado tu comentario')
    comentarios = db(db.comentario.imagen_id==imagen.id).select()
    return dict(imagen=imagen, comentarios=comentarios, form=form)
``:code

Todo intento de acceder a
``
http://127.0.0.1:8000/images/default/show/[image_id]
``:code

requerirá autenticación. Si el usuario no se autentica (login), será redirigido a
``
http://127.0.0.1:8000/images/default/user/login
``:code

[[image @///image/en3100.png center 480px]]

La función ``user`` además expone, entre otras, las siguientes acciones:
``
http://127.0.0.1:8000/images/default/user/logout
http://127.0.0.1:8000/images/default/user/register
http://127.0.0.1:8000/images/default/user/profile
http://127.0.0.1:8000/images/default/user/change_password
http://127.0.0.1:8000/images/default/user/request_reset_password
http://127.0.0.1:8000/images/default/user/retrieve_username
http://127.0.0.1:8000/images/default/user/retrieve_password
http://127.0.0.1:8000/images/default/user/verify_email
http://127.0.0.1:8000/images/default/user/impersonate
http://127.0.0.1:8000/images/default/user/not_authorized
``:code

Ahora, un usuario nuevo debe registrarse para poder autenticarse, leer y publicar comentarios.

-------
Tanto el objeto ``auth`` como la función ``user`` están definidos por defecto en la aplicación de andamiaje. El objeto ``auth`` es altamente personalizable y puede manejar aspectos como verificación por email, confirmación de registro, CAPTCHA, y métodos alternativos de autenticación por medio de los plugin.
-------

#### Agregando los grid

Podemos añadir mejoras a lo realizado hasta aquí usando los gadget ``SQLFORM.grid`` y ``SQLFORM.smartgrid`` para crear una interfaz de administración para nuestra aplicación:
``
@auth.requires_membership('manager')
def administrar():
    grid = SQLFORM.smartgrid(db.imagen)
    return dict(grid=grid)
``:code

con su "views/default/administrar.html" asociado
``
{{extend 'layout.html'}}
<h2>Interfaz de administración</h2>
{{=grid}}
``

Por medio de appadmin crea un grupo "administrador" y agrega algunos miembros al grupo. Ellos podrán acceder a la interfaz administrativa
``
http://127.0.0.1:8000/images/default/manage
``

con funcionalidad para la navegación y búsqueda:

[[image @///image/en3200.png center 480px]]

y opciones para crear, actualizar y eliminar imágenes y sus comentarios:

[[image @///image/en3300.png center 480px]]

### Configurando la plantilla general del diseño

Puedes configurar la plantilla general por defecto editando "views/layout.html" pero además puedes configurarla sin editar el HTML. De hecho, la plantilla de estilo "static/base.css" está documentada y descripta en detalle en el capítulo 5. Puedes cambiar el color, las columnas, el tamaño, bordes y fondo sin editar el HTML. Si deseas modificar el menú, el título o el sub-título, puedes hacerlo en cualquier archivo del modelo. La aplicación de andamiaje, configura los valores por defecto de estos parámetros en el archivo "models/menu.py":
``
response.title = request.application
response.subtitle = T('customize me!')
response.meta.author = 'tú'
response.meta.description = 'describe tu app'
response.meta.keywords = 'bla bla bla'
response.menu = [ [ 'Inicio', False, URL('index') ] ]
``:code

### Una wiki
``wiki``:inxx ``RSS``:inxx ``Ajax``:inxx ``XMLRPC``:inxx
En esta sección, armamos una wiki, desde cero y sin utilizar la funcionalidad extendida que provee plugin_wiki, que se describe en el capítulo 12. El visitante podrá crear páginas, realizar búsquedas de páginas por título y editarlas. El visitante además podrá publicar comentarios (de la misma forma que en las aplicaciones anteriores), y además publicar documentos (adjuntos con las páginas) y enlazarlos desde las páginas. Como convención, adoptaremos la sintaxis Markmin para la sintaxis de nuestra wiki. Además implementaremos una página de búsqueda con Ajax, una fuente de RSS para las páginas, y un manejador para la búsqueda de páginas a través de XML-RPC``xmlrpc``:cite .

El siguiente diagrama lista las acciones que necesitamos implementar y los enlaces que queremos establecer entre ellos.

[[yUML diagram @///image/en3400.png center 250px]]

Comienza creando una nueva app de andamiaje, con nombre "miwiki".

El modelo debe contener tres tablas: página, comentario, y documento. Tanto comentario como documento hacen referencia a página porque pertenecen a ella. Un documento contiene un campo archivo de tipo upload como en la anterior aplicación de imágenes.

Aquí se muestra el modelo completo:
``
db = DAL('sqlite://storage.sqlite')

from gluon.tools import *
auth = Auth(db)
auth.define_tables()
crud = Crud(db)

db.define_table('pagina',
    Field('titulo'),
    Field('cuerpo', 'text'),
    Field('creada_en', 'datetime', default=request.now),
    Field('creada_por', 'reference auth_user', default=auth.user_id),
    format='%(titulo)s')

db.define_table('comentario',
    Field('pagina_id', 'reference pagina'),
    Field('cuerpo', 'text'),
    Field('creado_en', 'datetime', default=request.now),
    Field('creado_por', 'reference auth_user', default=auth.user_id))

db.define_table('documento',
    Field('pagina_id', 'reference pagina'),
    Field('nombre'),
    Field('archivo', 'upload'),
    Field('creado_en', 'datetime', default=request.now),
    Field('creado_por', 'reference auth_user', default=auth.user_id),
    format='%(name)s')

db.pagina.titulo.requires = IS_NOT_IN_DB(db, 'page.title')
db.pagina.cuerpo.requires = IS_NOT_EMPTY()
db.pagina.creada_por.readable = db.pagina.creada_por.writable = False
db.pagina.creada_en.readable = db.pagina.creada_en.writable = False

db.comentario.cuerpo.requires = IS_NOT_EMPTY()
db.comentario.pagina_id.readable = db.comentario.page_id.writable = False
db.comentario.creado_por.readable = db.comentario.creado_por.writable = False
db.comentario.creado_en.readable = db.comentario.creado_en.writable = False

db.documento.nombre.requires = IS_NOT_IN_DB(db, 'documento.nombre')
db.documento.pagina_id.readable = db.documento.pagina_id.writable = False
db.documento.creado_por.readable = db.documento.creado_por.writable = False
db.documento.creado_en.readable = db.documento.creado_en.writable = False
``:code

Modifica el controlador "defautl.py" y crea las siguientes acciones:
- index: listar todas las páginas wiki
- crear: publicar una página wiki nueva
- mostrar: mostrar una página wiki, listar sus comentarios y agregar comentarios nuevos
- editar: modificar una página existente
- documentos: administrar los documentos adjuntos de una página
- download: descargar un document (como en el ejemplo de las imágenes)
- buscar: mostrar un campo de búsqueda y, a través de una llamada de Ajax, devolver los títulos a medida que el visitante escribe
- callback: una función callback de Ajax. Devuelve el HTML que se embebe en la página de búsqueda mientras el visitante escribe.

Aquí se muestra el controlador "default.py":
``
def index():
     """ Este controlador devuelve un diccionario convertido
     por la vista

     Lista todas las páginas wiki
     index().has_key('pages')
     True
     """
     paginas = db().select(db.pagina.id,db.pagina.titulo,orderby=db.pagina.titulo)
     return dict(paginas=paginas)

@auth.requires_login()
def crear():
     "crea una nueva página wiki en blanco"
     form = crud.create(db.pagina, next=URL('index'))
     return dict(form=form)

def mostrar():
     "muestra una página wiki"
     esta_pagina = db.pagina(request.args(0,cast=int)) or redirect(URL('index'))
     db.comentario.pagina_id.default = esta_pagina.id
     form = crud.create(db.comentario) if auth.user else None
     comentariospagina = db(db.comentario.pagina_id==esta_pagina.id).select()
     return dict(pagina=esta_pagina, comentarios=comentariospagina, form=form)

@auth.requires_login()
def editar():
     "editar una página existente"
     esta_pagina = db.pagina(request.args(0,cast=int)) or redirect(URL('index'))
     form = crud.update(db.pagina, esta_pagina,
                        next=URL('mostrar',args=request.args))
     return dict(form=form)

@auth.requires_login()
def documentos():
     "lista y edita los comentarios asociados a una página determinada"
     pagina= db.pagina(request.args(0,cast=int)) or redirect(URL('index'))
     db.documento.pagina_id.default = pagina.id
     db.documento.pagina_id.writable = False
     grid = SQLFORM.grid(db.documento.pagina_id==pagina.id,args=[pagina.id])
     return dict(pagina=pagina, grid=grid)

def user():
     return dict(form=auth())

def download():
     "permite la descarga de documentos"
     return response.download(request, db)

def buscar():
     "una página de búsqueda de wikis via ajax"
     return dict(form=FORM(INPUT(_id='palabra',_name='palabra',
              _onkeyup="ajax('callback', ['palabra'], 'target');")),
              target_div=DIV(_id='target'))

def callback():
     "un callback de ajax que devuelve un <ul> de links a páginas wiki"
     query = db.pagina.titulo.contains(request.vars.palabra)
     paginas = db(query).select(orderby=db.page.title)
     direcciones = [A(p.titulo, _href=URL('mostrar',args=p.id)) for p in paginas]
     return UL(*links)
``:code

Las líneas 2-6 proveen de un comentario para la acción index. Las líneas 4-5 dentro de los comentarios son interpretadas por Python como código de doctest. Los test se pueden ejecutar a través de la interfaz admin. En este caso el test verifica que la acción index corra sin errores.

Las líneas 18, 27, 35 tratan de recuperar el registro ``pagina`` con el id en ``request.args(0)``.

Las líneas 13, 20 definen y procesan formularios de creación para una nueva página y un nuevo comentario.

La línea 28 define y procesa un formulario de modificación para una página wiki.

La línea 38 crea un objeto ``grid`` que permite al navegador agregar y actualizar los comentarios asociados a una página.

Cierta magia ocurre en la línea 51. Se configura el atributo ``onkeyup`` de la etiqueta "palabra".  Cada vez que el visitante deja de presionar una tecla, el código JavaScript dentro del atributo ``onkeyup`` se ejecuta, del lado del cliente. Este es el código JavaScript:
``
ajax('callback', ['palabra'], 'target');
``:code
``ajax`` es una función JavaScript definida en el archivo "web2py.js" que se incluye por defecto en "layout.html". Toma tres parámetros: el URL de la acción que realiza el callback asincrónico, una lista de los IDs de variables a ser enviadas al callback (["palabra"]), y el ID donde la respuesta se debe insertar ("target").

Tan pronto como escribas algo en el campo de búsqueda y dejes de presionar una tecla, el cliente llama al servidor y envía el contenido del campo "palabra", y, cuando el servidor responde, la respuesta se embebe en la misma página como HTML incluido en la etiqueta de destino ('target').

La etiqueta 'target' es un DIV definido en la línea 52. Podría haberse definido en la vista también.

Aquí se muestra el código para la vista "default/crear.html":
``
{{extend 'layout.html'}}
<h1>Crear una nueva página wiki</h1>
{{=form}}
``:code

Si visitas la página **crear**, verás lo siguiente:

[[image @///image/en3500.png center 480px]]

Aquí se muestra el código para la vista "default/index.html":
``
{{extend 'layout.html'}}
<h1>Páginas wiki disponibles</h1>
[ {{=A('buscar', _href=URL('buscar'))}} ]<br />
<ul>{{for pagina in paginas:}}
     {{=LI(A(pagina.titulo, _href=URL('mostrar', args=pagina.id)))}}
{{pass}}</ul>
[ {{=A('crear página', _href=URL('crear'))}} ]
``:code

Esto crea la siguiente página:

[[image @///image/en3600.png center 480px]]

Aquí se puede ver el código para la vista "default/mostrar.html":

``markdown``:inxx ``MARKMIN``:inxx
``
{{extend 'layout.html'}}
<h1>{{=pagina.titulo}}</h1>
[ {{=A('editar', _href=URL('editar', args=request.args))}}
| {{=A('documentos', _href=URL('documentos', args=request.args))}} ]<br />
{{=MARKMIN(pagina.cuerpo)}}
<h2>Comentarios</h2>
{{for comentario in comentarios:}}
  <p>{{=db.auth_user[comentario.creado_por].first_name}} on {{=comentario.creado_en}}
          dice <I>{{=comentario.cuerpo}}</i></p>
{{pass}}
<h2>Publicar un comentario</h2>
{{=form}}
``:code

Si deseas utilizar la sintaxis markdown en lugar de markmin:
``
from gluon.contrib.markdown import WIKI
``:code

y usa ``WIKI`` en lugar del ayudante ``MARKMIN``.
Alternativamente, puedes elegir aceptar HTML puro en lugar de la sintaxis markmin. En ese caso deberías reemplazar:
``
{{=MARKMIN(pagina.cuerpo)}}
``:code

con:
``
{{=XML(pagina.cuerpo)}}
``:code

``sanitize``:inxx
(para que no se realice "escapado" del XML, que es el comportamiento por defecto de web2py).

Esto es mejor hacerlo con:
``
{{=XML(pagina.cuerpo, sanitize=True)}}
``:code

Al configurar ``sanitize=True``, le dices a web2py que "escape" las etiquetas XML delicadas como "<script>", y que de esa forma se puedan prevenir las vulnerabilidades de tipo XSS.

Ahora si, desde la página index, haces clic en el título de una página, puedes ver la página que has creado:

[[image @///image/en3700.png center 480px]]

Aquí está el código para la vista "default/edit.html":
``
{{extend 'layout.html'}}
<h1>Edición de la página wiki</h1>
[ {{=A('mostrar', _href=URL('mostrar', args=request.args))}} ]<br />
{{=form}}
``:code

Genera una página que se ve prácticamente idéntica a la de crear.

Aquí se muestra el código de la vista "default/documentos.html":
``
{{extend 'layout.html'}}
<h1>Documentos para la página: {{=pagina.titulo}}</h1>
[ {{=A('mostrar', _href=URL('mostrar', args=request.args))}} ]<br />
<h2>Documentos</h2>
{{=grid}}
``:code

Si, desde la página "mostrar", haces clic en documentos, ahora puedes administrar los documentos asociados a la página.

[[image @///image/en3800.png center 480px]]

Por último, aquí está el código para la vista "default/buscar.html":
``
{{extend 'layout.html'}}
<h1>Buscar páginas wiki</h1>
[ {{=A('listar todo', _href=URL('index'))}}]<br />
{{=form}}<br />{{=target_div}}
``:code

que genera el siguiente formulario Ajax de búsqueda:

[[image @///image/en3900.png center 480px]]

Además puedes probar llamando a la acción callback directamente visitando, por ejemplo, el siguiente URL:
``
http://127.0.0.1:8000/miwiki/default/callback?palabra=wiki
``:code

Si ahora examinas el código fuente verás el HTML devuelto por el callback:
``
<ul><li><a href="/miwiki/default/mostrar/4">He creado una wiki</a></li></ul>
``:code

``rss``:inxx
Es fácil generar una fuente de RSS a partir de las páginas almacenadas utilizando web2py porque incluye ``gluon.contrib.rss2``. Sólo debes añadir la siguiente acción al controlador default:
``
def noticias():
    "genera una fuente de rss a partir de las páginas wiki"
    reponse.generic_patterns = ['.rss']
    paginas = db().select(db.pagina.ALL, orderby=db.pagina.titulo)
    return dict(
       titulo = 'fuente rss de miwiki',
       link = 'http://127.0.0.1:8000/miwiki/default/index',
       description = 'noticias de miwiki',
       creada_en = request.now,
       elementos = [
          dict(titulo = row.titulo,
               link = URL('mostrar', args=row.id),
               descripcion = MARKMIN(row.cuerpo).xml(),
               creada_en = row.creada_en
               ) for row in paginas])
``:code

y cuando visitas la página
``
http://127.0.0.1:8000/miwiki/default/news.rss
``:code

verás la fuente (la salida exacta depende del lector de fuentes rss). Observa cómo el dict se convierte automáticamente a RSS, gracias a la extensión en el URL.

[[image @///image/en4000.png center 480px]]

web2py también incluye un intérprete (parser) de fuentes para leer fuentes de terceros.

``XMLRPC``:inxx
Por último, agreguemos un manejador de XML-RPC que permita la búsqueda de wiki en forma programática:
``
service = Service()

@service.xmlrpc
def buscar_por(palabra):
     "busca páginas que contengan la palabra para XML-RPC"
     return db(db.pagina.titulo.contains(palabra)).select().as_list()

def call():
    "expone todos los servicios registrados, incluyendo XML-RPC"
    return service()
``:code

Aquí, la acción de manejo (handler action) simplemente publica (via XML-RPC), las funciones especificadas en la lista. En este caso, ``buscar_por`` no es una acción (porque toma un argumento). Consulta a la base de datos con ``.select()`` y luego extrae los registros en forma de lista con ``.response`` y devuelve la lista.

Aquí hay un ejemplo de cómo se accede al manejador de XML-RPC desde un programa externo en Python.
``
>>> import xmlrpclib
>>> servidor = xmlrpclib.ServerProxy(
    'http://127.0.0.1:8000/mywiki/default/call/xmlrpc')
>>> for item in servidor.buscar_por('wiki'):
        print item['creada_en'], item['title']
``:code

Se puede acceder al manejador desde distintos lenguajes de programación que hablen XML-RPC, incluyendo C, C++, C# y Java.

#### Acerca de los formatos ``date``, ``datetime`` y ``time``

Existen tres distintas representaciones para cada uno de los tipos ``date``, ``datetime`` y ``time``:
- la representación de la base de datos
- la representación interna de web2py
- la representación como cadena en formularios y tablas

La representación de la base de datos es una cuestión interna y no afecta al código. Internamente, en el nivel de web2py, se almacenan como objetos ``datetime.date``, ``datetime.datetime`` y ``datetime.time`` respectivamente y pueden ser manipulados según las clases mencionadas:

``
for pagina in db(db.pagina).select():
    print pagina.title, pagina.day, pagina.month, pagina.year
``

Cuando las fechas se convierten a cadenas en los formularios son convertidas utilizando la representación ISO
``
%Y-%m-%d %H:%M:%S
``

de todas formas esta representación está internacionalizada y puedes usar la página de traducción de la aplicación administrativa para cambiar el formato por uno alternativo. Por ejemplo:
``
%m/%b/%Y %H:%M:%S
``

------
Ten en cuenta que por defecto el idioma Inglés no se traduce porque web2py asume que las aplicaciones ya vienen escritas en Inglés. Si quieres que la internacionalización funcione con el idioma Inglés debes crear el archivo de traducción (utilizando admin) y debes declarar que el lenguaje actual de la aplicación es otro distinto del Inglés, por ejemplo:
``
T.current_languages = ['null']
``
------


### Más sobre **admin**
``admin``:inxx

La interfaz administrativa provee de funcionalidad adicional que se tratará brevemente en esta sección.

#### ''site''
``site``:inxx

Esta página lista todas las aplicaciones instaladas. Hay dos formularios al final.

El primero permite crear una nueva aplicación ingresando el nombre.

``Instant Press``:inxx

El segundo formulario permite subir una aplicación existente tanto desde un archivo en el sistema operativo como desde una URL remota. Cuando subes la aplicación, debes asignarle un nombre. Puedes especificar su nombre original, pero no es obligatorio. Esto permite la instalación de múltiples copias de la misma aplicación. Puedes probar, por ejemplo, subir el CMS Instant Press de Martín Mulone desde:
``
http://code.google.com/p/instant-press/
``:code

------
Las apps de web2py se empaquetan como archivos ``.w2p``, que son archivos tar comprimidos con gzip. web2py utiliza la extensión ``.w2p`` en lugar de ``.tgz`` para evitar que el navegador intente descomprimirlos al descargarlos. Se pueden descomprimir manualmente con ``tar zxvf [filename]`` aunque esto normalmente no es necesario.
------

[[image @///image/en4100.png center 444px]]

Si la subida es exitosa, web2poy muestra la suma de verificación (checksum) del archivo subido. Puedes utilizarla para verificar que el archivo no se dañó durante la subida. El nombre InstantPress aparecerá en la lista de aplicaciones instaladas.

Haz clic en el nombre InstantPress en la página admin para comenzar a utilizarla.

[[image @///image/en4200.png center 480px]]

Puedes leer más acerca de Instant Press en la siguiente URL:
``
http://code.google.com/p/instant-press/
``
En cada aplicación, la página "site" te permite:
- Desinstalar la aplicación
- Ir a la página "acerca de" (ver abajo)
- Ir a la página de "editar" (ver abajo)
- Ir a la página de "errores" (ver abajo)
- Eliminar archivos temporarios (sesiones, errores, y archivos cache.disk)
- Empaquetar todo. Esto devuelve un archivo .tar que contiene una copia completa de la aplicación. Te sugerimos que elimines los archivos temporarios antes de empaquetar una aplicación.
- Compilar la aplicación. Si no hay errores, esta opción generará código bytecode-compiled de todos los módulos, controladores y vistas. Como las vistas pueden extender e incluir a otras vistas en una estructura jerárquica, antes de la compilación, el "árbol" de vistas se condensa en un archivo único. El efecto de este procedimiento es que una aplicación compilada es más rápida, porque se omite la lectura de plantillas (parse) y sustituciones de cadenas durante la ejecución.
- Empaquetar compilados. Esta opción sólo está disponible para aplicaciónes compiladas. Permite empaquetar la aplicación sin el código fuente para su distribución "closed source". Ten en cuenta que Python (como cualquier otro lenguaje de programación) puede ser descompilado en la práctica; por lo tanto la compilación no garantiza la protección del código fuente. Sin embargo, la descompilación puede ser puede ser una tarea difícil e incluso ilegal.
- Eliminar compilados. Simplemente elimina todos los archivos de los modelos, vistas y controladores bytecode-compiled de la aplicación. Si la aplicación se empaquetó con código fuente o se editó localmente, no hay peligro al eliminar los archivos compilados, y la aplicación funcionará de todas formas. Si la aplicación se instaló desde un paquete compilado, entonces la operación no es segura, porque hay un código fuente hacia el cual se puedan revertir los cambios, y la aplicación dejará de funcionar.

``admin.py``:inxx

-------
Todas las funcionalidades disponibles desde el sitio admin de web2py también se pueden utilizar programáticamente a través de la API definida en el módulo `` gluon/admin.py``. Basta con abrir una consola con el intérprete de Python e importar ese módulo.
-------

#### ''Acerca de'
``about``:inxx ``license``:inxx

La sección "acerca de" (about) permite editar la descripción de la aplicación y su licencia. Estas últimas están escritas respectivamente en los archivos ABOUT y LICENSE en la carpeta de la aplicación.

[[image @///image/en4300.png center 480px]]

Se pueden utilizar  las sintaxis ``MARKMIN``, o ``gluon.contrib.markdown.WIKI`` para estos archivos como se describe en ref.``markdown2``:cite .

#### ''editar''
``EDIT``:inxx
Ya has utilizado la página "editar" en otra ocasión en este capítulo. Aquí queremos señalar algunas funcionalidades más de esta página.
- Si haces clic en cualquier nombre de archivo, puedes visualizar sus contenidos con resaltado de código fuente.
- Si haces clic en editar, puedes editar el archivo a través de la interfaz web.
- Si haces clic en eliminar, puedes eliminar el archivo (en forma permanente).
- Si haces clic en test (pruebas), web2py correrá los test. Los test son creados por el desarrollador utilizando doctests, y cada función debería tener sus propios test.
- Puedes agregar archivos de idiomas, buscar en el dominio de la aplicación para detectar todas las cadenas y editar sus traducciones a través de la interfaz web.
- Si los archivos estáticos se organizan en carpetas y subcarpetas, las jerarquías de las carpetas se pueden colapsar o desplegar haciendo clic en el nombre de la carpeta.

La imagen a continuación muestra la salida de la página de test para la aplicación welcome.

[[image @///image/en4400.png center 480px]]

La imagen que sigue muestra la sección de idiomas para la aplicación welcome.

[[image @///image/en4500.png center 480px]]

La siguiente imagen muestra cómo se edita un archivo de idioma, en este caso el idioma "it" (Italiano) para la aplicación welcome.

[[image @///image/en4600.png center 480px]]

##### ''shell'' o consola

Si haces clic en el link "shell" debajo de la sección de controladores en "editar", web2py abrirá una consola de Python para web y ejecutará los modelos para la aplicación actual. Esto te permite comunicarte con la aplicación en forma interactiva.

[[image @///image/en4700.png center 480px]]

##### ''crontab''

También debajo de la sección de controladores en "editar" hay un lik a "crontab". Haciendo clic en este link podrás editar el archivo de crontab de web2py. El crontab de web2py sigue la misma sintaxis que el crontab para unix. En realidad, sólo requiere web2py, y funciona en Windows. Te permite registrar acciones que se tienen que ejecutar en segundo plano en horarios programados.

Para más detalles sobre este tema, consulta el siguiente capítulo.

#### ''errores''
``errors``:inxx
Mientras programes con web2py, inevitablemente cometerás errores e introducirás fallas o bugs. web2py te ayuda en dos formas: 1) te permite crear test para cada función que pueden ejecutarse en el navegador desde la página "editar"; y 2) cuando se produce un error, se devuelve un ticket al visitante y el error se reporta/almacena (log).

Introduce intencionalmente un error en la aplicación de imágenes como se muestra abajo:
``
def index():
    imagenes = db().select(db.imagen.ALL,orderby=db.imagen.titulo)
    1/0
    return dict(imagenes=imagenes)
``:code

Cuando accedas a la acción de index, obtendrás el siguiente ticket:

[[image @///image/en4800.png center 480px]]

Sólo el administrador puede visualizar el detalle del ticket:

[[image @///image/en4900.png center 480px]]

El ticket muestra el traceback (traza o trayectoria del error), y el contenido del archivo que causó el problema, y el estado completo del sistema (variables, objetos request, session, etc.). Si el error se produce en la vista, web2py muestra la vista convertida de HTML a código Python. Esto permite una identificación más fácil de la estructura lógica del archivo.

Por defecto los ticket se almancenan en el sistema de archivos y se agrupan por traceback. La interfaz administrativa provee de vistas con estadística (tipo de traceback y número de repeticiones) y una vista detallada (todos los ticket se listan por id). El administrador puede intercambiar los dos tipos de vistas.

Observa que **admin** siempre muestra código fuente resaltado (por ejemplo en los reportes de errores, las palabras especiales de web2py se muestran en naranja). Si haces clic en una keyword de web2py, eres redirigido a la página con la documentación sobre esa palabra.

Si reparas el bug de división por cero en la acción index e introduces otro en la vista de index:
``
{{extend 'layout.html'}}

<h1>Imágenes registradas</h1>
<ul>
{{for imagen in imagenes:}}
{{1/0}}
{{=LI(A(imagen.titulo, _href=URL("mostrar", args=imagen.id)))}}
{{pass}}
</ul>
``:code

obtienes el siguiente ticket:

[[image @///image/en5000.png center 480px]]

Nótese que web2py ha convertido la vista de HTML a un archivo Python, y el error descripto en el ticket se refiere al código Python generado y NO a la vista original:

[[image @///image/en5100.png center 480px]]

Esto puede resultar confuso al principio, pero en la práctica hace el trabajo de depuración más sencillo, porque la indentación de Python resalta la estructura lógica del código que has embebido en las vistas.

El código se muestra al final de la misma página.

Todos los ticket se listan bajo la aplicación admin en la página "errores" de cada aplicación:

[[image @///image/en5200.png center 480px]]

#### ''Mercurial''
``Mercurial``:inxx

Si estás corriendo web2py desde el código fuente y tienes las librerías de control de versiones Mercurial instaladas:
``
easy_install mercurial
``:code

entonces la interfaz administrativa muestra uno o más ítem de menú llamados "mercurial". Estos automáticamente crean un repositorio local de Mercurial para la aplicación. Presionando el botón "commit" en la página aplicará los cambios a la app. Mercurial crea y almacena información acerca de los cambios que vas haciendo en tu código en una carpeta oculta ".hg" en la subcarpeta de tu app. Cada app tiene su propia carpeta ".hg" y su propio archivo ".hgignore" (que le indica a Mercurial qué archivos ignorar).

La interfaz web de mercurial no te permite navegar por los cambios previos y sus archivos diff pero te recomendamos el uso de Mercurial directamente desde la consola o alguno de los numerosos clientes GUI para Mercurial que son más potentes. Por ejemplo te permiten sincronizar tu aplicación con un repositorio remoto:

[[images @///image/en5300.png center 480px]]

Puedes leer más sobre Mercurial aquí:
``
http://mercurial.selenic.com/
``

#### El asistente de admin (experimental)

La intefaz **admin** incluye un asistente que puede ayudarte en la creación de nuevas aplicaciones.
Puedes acceder al asistente desde la página "sites" como se muestra en la imagen de abajo.

[[image @///image/en5400.png center 480px]]

El asistente te guiará a través de una serie de pasos para la creación de una nueva aplicación:

- Elegir un nombre para la aplicación
- Configurar la aplicación y elegir los plugin necesarios
- Armar los modelos requeridos (creará páginas de ABM/CRUD para cada modelo)
- Te permitirá editar las vistas de esas páginas utilizando la sintaxis MARKMIN

La imagen de abajo muestra la segunda fase del proceso.

[[image @///image/en5500.png center 480px]]

Se puede ver un menú desplegable para la elección de un plugin de plantilla general (desde ``web2py.com/layouts``), un menú de opción múltiple para agregar un conjunto de plugin extra (desde ``web2py.com/plugins``) y un campo "login config" para ingresar una "domain:key" de Janrain.

Las demás fases son un tanto más simples, por lo que obviamos su explicación.

El asistente es eficaz para su objetivo pero es considerado una "funcionalidad experimental" por dos razones:

- Las aplicaciones creadas con el asistente y editadas manualmente ya no pueden ser más modificadas por el asistente.
- La interfaz del asistente cambiará eventualmente para incluír soporte para más características y un desarrollo visual más fácil.

En todo caso el asistente es una herramienta útil para crear prototipos velozmente y puede servir como plantilla (bootstrap) de una aplicación con un diseño alternativo y otro conjunto de plugin.


#### Configurando **admin**

Normalmente no hay necesidad de modificar ninguna configuración en admin aunque son posibles algunas personalizaciones. Luego de autenticarte en admin puedes editar la configuración a través la URL:
``
http://127.0.0.1:8000/admin/default/edit/admin/models/0.py
``
Ten en cuenta cómo **admin** puede utilizarse para auto-modificarse. De hecho **admin** es una app como cualquier otra.

El archivo "0.py" está suficientemente documentado y si lo abres probablemente ya sabes lo que estás buscando. De todas formas hay algunas personalizaciones que son más importantes que otras:

``
GAE_APPCFG = os.path.abspath(os.path.join('/usr/local/bin/appcfg.py'))
``
Esto debería apuntar a la ubicación del archivo "appcfg.py" que viene con el SDK de Google App Engine. Si tienes el SDK quizás quieras cambiar estos parámetros de configuración a los valores correctos. Esto te permitirá desplegar en GAE desde la interfaz de admin.

``DEMO_MODE``:inxx

Además puedes configurar la app admin de web2py en modo demo:
``
DEMO_MODE = True
FILTER_APPS = ['welcome']
``
Y sólo las aplicaciones listadas en filter_apps estarán disponibles y sólo se podrá acceder a ellas en modo de solo-lectura.

``MULTI_USER_MODE``:inxx
``virtual laboratory``:inxx

Si eres docente y quieres exponer la interfaz administrativa a estudiantes para que puedan compartir una interfaz administrativa para sus proyectos (piensa en un laboratorio virtual), lo puedes hacer configurando:
``
MULTI_USER_MODE = True
``

De esa forma los estudiantes deberán autenticarse y sólo podrán acceder a sus propias aplicaciones a través de admin. Tu, como el usuario principal/maestro, tendrás acceso a todas.

Ten en cuenta que este mecanismo de todas formas asume que todos los usuarios son confiables. Todas las aplicaciones creadas bajo admin corren con las mismas credenciales en el mismo sistema de archivos. Es posible para una aplicación creada por un estudiante el acceso a los datos y el código fuente de una app de otro estudiante.


### Más acerca de **appadmin**

``appadmin``:inxx

**appadmin** no está pensada para ser expuesta al público. Está diseñada para ayudarte como forma de fácil acceso a la base de datos. Consiste de sólo dos archivos: un controlador "appadmin.py" y una vista "appadmin.html", que son utilizados por todas las acciones en el controlador.

El controlador de **appadmin** es relativamente pequeño y legible; sirve además como ejemplo para el diseño de una interfaz de acceso a la base de datos.

**appadmin** muestra cuales bases de datos están disponibles y qué tablas existen en cada base de datos. Puedes insertar registros y listar todos los registros para cada tabla individualmente. **appadmin** hace una separación en páginas de la salida por cada 100 registros.

Una vez que se selecciona un set de registros, el encabezado de las páginas cambia, permitiéndote actualizar o eliminar los registros devueltos por la consulta.

Para actualizar los registros, ingresa un criterio SQL en el campo para la cadena de la consulta:
``
title = 'test'
``:code

donde los valores de la cadena deben estar entre comillas simples. Los criterios múltiples se pueden separar con comas.

Para eliminar un registro, haz clic el checkbox para confirmar que estás seguro.

**appadmin** también puede realizar consultas tipo join si el FILTRO de SQL contiene una instrucción condicional de SQL que tenga dos o más tablas. Por ejemplo, prueba con:
``
db.imagen.id == db.comentario.imagen_id
``:code

web2py le pasa el comando a la DAL, que entiende que la consulta asocia dos tablas; así, las dos tablas se consultan con un INNER JOIN. Esta es la salida:

[[image @///image/en5600.png center 480px]]

Si haces clic en el número de un campo id, obtienes una página de edición para el registro correspondiente.

Si haces clic en el número de un campo tipo reference, obtienes una página de edición para el registro de referencia.

No se pueden actualizar o eliminar registros consultados con un join, porque implicaría la modificación de registros de múltiples tablas y podría resultar confuso.

Aparte de sus funciones para administración de la base de datos, **appadmin** además te permite visualizar el detalle de los contenidos del ``cache`` de la aplicación (en ``/tuapp/appadmin/ccache``) así como también los contenidos de los objetos ``request``, ``response``, y ``session`` (en ``/tuapp/appadmin/state``).

------
**appadmin** reemplaza ``response.menu`` con su propio menú, que incluye, para la app actual, accesos a la página **edit** en **admin**, la página **db** (administración de la base de datos), la página **state**, y la página **cache**. Si la plantilla general de tu aplicación no genera un menú usando ``response.menu``, entonces no verás el menú de **appadmin**. En este caso, puedes modificar el archivo appadmin.html y agregar ``{{=MENU(response.menu)}}`` para mostrar el menú.
------
