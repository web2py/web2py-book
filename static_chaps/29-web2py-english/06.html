<h2>The database abstraction layer</h2><div class="inxx">DAL</div><h3>Dependencies</h3><p>web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. A partial list of supported databases is show in the table below. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</p><p>The Gotchas section at the end of this chapter has some more information about specific databases.</p><p>The Windows binary distribution works out of the box with SQLite, MSSQL, Postgresql and MySQL. The Mac binary distribution works out of the box with SQLite. To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</p><div class="inxx">database drivers</div><p>Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of the drivers web2py can use:</p><p><div class="inxx">DAL</div> <div class="inxx">SQLite</div> <div class="inxx">MySQL</div> <div class="inxx">PostgresSQL</div> <div class="inxx">Oracle</div> <div class="inxx">MSSQL</div> <div class="inxx">FireBird</div> <div class="inxx">DB2</div> <div class="inxx">Informix</div> <div class="inxx">Sybase</div> <div class="inxx">Teradata</div> <div class="inxx">MongoDB</div> <div class="inxx">CouchDB</div> <div class="inxx">SAPDB</div> <div class="inxx">Cubrid</div></p><table><tbody><tr class="first"><td>database</td><td>drivers (source)</td></tr><tr class="even"><td>SQLite</td><td>sqlite3 or pysqlite2 or zxJDBC <sup>[<a href="/book/default/reference/29/zxjdbc" target="_blank">zxjdbc</a>]</sup>  (on Jython)</td></tr><tr><td>PostgreSQL</td><td>psycopg2 <sup>[<a href="/book/default/reference/29/psycopg2" target="_blank">psycopg2</a>]</sup>  or pg8000 <sup>[<a href="/book/default/reference/29/pg8000" target="_blank">pg8000</a>]</sup> or zxJDBC <sup>[<a href="/book/default/reference/29/zxjdbc" target="_blank">zxjdbc</a>]</sup>  (on Jython)</td></tr><tr class="even"><td>MySQL</td><td>pymysql <sup>[<a href="/book/default/reference/29/pymysql" target="_blank">pymysql</a>]</sup> or MySQLdb <sup>[<a href="/book/default/reference/29/mysqldb" target="_blank">mysqldb</a>]</sup></td></tr><tr><td>Oracle</td><td>cx_Oracle <sup>[<a href="/book/default/reference/29/cxoracle" target="_blank">cxoracle</a>]</sup></td></tr><tr class="even"><td>MSSQL</td><td>pyodbc <sup>[<a href="/book/default/reference/29/pyodbc" target="_blank">pyodbc</a>]</sup> or pypyodbc<sup>[<a href="/book/default/reference/29/pypyodbc" target="_blank">pypyodbc</a>]</sup></td></tr><tr><td>FireBird</td><td>kinterbasdb <sup>[<a href="/book/default/reference/29/kinterbasdb" target="_blank">kinterbasdb</a>]</sup> or fdb or pyodbc</td></tr><tr class="even"><td>DB2</td><td>pyodbc <sup>[<a href="/book/default/reference/29/pyodbc" target="_blank">pyodbc</a>]</sup></td></tr><tr><td>Informix</td><td>informixdb <sup>[<a href="/book/default/reference/29/informixdb" target="_blank">informixdb</a>]</sup></td></tr><tr class="even"><td>Ingres</td><td>ingresdbi <sup>[<a href="/book/default/reference/29/ingresdbi" target="_blank">ingresdbi</a>]</sup></td></tr><tr><td>Cubrid</td><td>cubriddb <sup>[<a href="/book/default/reference/29/cubridb" target="_blank">cubridb</a>]</sup> <sup>[<a href="/book/default/reference/29/cubridb" target="_blank">cubridb</a>]</sup></td></tr><tr class="even"><td>Sybase</td><td>Sybase <sup>[<a href="/book/default/reference/29/Sybase" target="_blank">Sybase</a>]</sup></td></tr><tr><td>Teradata</td><td>pyodbc <sup>[<a href="/book/default/reference/29/Teradata" target="_blank">Teradata</a>]</sup></td></tr><tr class="even"><td>SAPDB</td><td>sapdb <sup>[<a href="/book/default/reference/29/SAPDB" target="_blank">SAPDB</a>]</sup></td></tr><tr><td>MongoDB</td><td>pymongo <sup>[<a href="/book/default/reference/29/pymongo" target="_blank">pymongo</a>]</sup></td></tr><tr class="even"><td>IMAP</td><td>imaplib <sup>[<a href="/book/default/reference/29/IMAP" target="_blank">IMAP</a>]</sup></td></tr></tbody></table><p><code>sqlite3</code>, <code>pymysql</code>, <code>pg8000</code>, and <code>imaplib</code> ship with web2py. Support of MongoDB is experimental. The IMAP option allows to use DAL to access IMAP.</p><h3>The DAL: A quick tour</h3><p>web2py defines the following classes that make up the DAL:</p><p>The <strong>DAL</strong> object represents a database connection. For example:</p><div class="inxx">sqlite</div><pre><code class="code">db = DAL('sqlite://storage.db')</code></pre><div class="inxx">define_table</div><p><strong>Table</strong> represents a database table.  You do not directly instantiate Table; instead, <code>DAL.define_table</code> instantiates it.</p><pre><code class="code">db.define_table('mytable', Field('myfield'))</code></pre><p>The most important methods of a Table are:</p><div class="inxx">insert</div><div class="inxx">truncate</div><div class="inxx">drop</div><div class="inxx">import_from_csv_file</div><div class="inxx">count</div><p><code>.insert</code>, <code>.truncate</code>, <code>.drop</code>, and <code>.import_from_csv_file</code>.</p><div class="inxx">Field</div><p><strong>Field</strong> represents a database field. It can be instantiated and passed as an argument to <code>DAL.define_table</code>.</p><div class="inxx">Rows</div><p><strong>DAL Rows</strong> <div class="inxx">Row</div>  is the object returned by a database select. It can be thought of as a list of <code>Row</code> rows:</p><pre><code class="code">rows = db(db.mytable.myfield!=None).select()</code></pre><div class="inxx">Row</div><p><strong>Row</strong> contains field values.</p><pre><code class="code">for row in rows:
    print row.myfield</code></pre><div class="inxx">Query</div><p><strong>Query</strong> is an object that represents a SQL "where" clause:</p><pre><code class="code">myquery = (db.mytable.myfield != None) | (db.mytable.myfield &gt; 'A')</code></pre><div class="inxx">Set</div><p><strong>Set</strong> is an object that represents a set of records. Its most important methods are <code>count</code>, <code>select</code>, <code>update</code>, and <code>delete</code>. For example:</p><pre><code class="code">myset = db(myquery)
rows = myset.select()
myset.update(myfield='somevalue')
myset.delete()</code></pre><div class="inxx">Expression</div><p><strong>Expression</strong> is something like an <code>orderby</code> or <code>groupby</code> expression. The Field class is derived from the Expression. Here is an example.</p><pre><code class="code">myorder = db.mytable.myfield.upper() | db.mytable.id
db().select(db.table.ALL, orderby=myorder)</code></pre><h3>Using the DAL "stand-alone"</h3><p>The web2py DAL can be used in a non-web2py environment via</p><pre><code class="code">from gluon import DAL, Field
# also consider: from gluon.validators import *</code></pre><p><span class="anchor" id="markmin_dal_constructor"></span></p><h3>DAL constructor</h3><p>Basic use:</p><pre><code class="code">&gt;&gt;&gt; db = DAL('sqlite://storage.db')</code></pre><p>The database is now connected and the connection is stored in the global variable <code>db</code>.</p><p>At any time you can retrieve the connection string.</p><div class="inxx">_uri</div><pre><code class="code">&gt;&gt;&gt; print db._uri
sqlite://storage.db</code></pre><p>and the database name</p><div class="inxx">_dbname</div><pre><code class="code">&gt;&gt;&gt; print db._dbname
sqlite</code></pre><p>The connection string is called a <code>_uri</code> because it is an instance of a Uniform Resource Identifier.</p><p>The DAL allows multiple connections with the same database or with different databases, even databases of different types. For now, we will assume the presence of a single database since this is the most common situation.</p><h4>DAL signature</h4><pre><code class="code">DAL(
    uri='sqlite://dummy.db',
    pool_size=0,
    folder=None,
    db_codec='UTF-8',
    check_reserved=None,
    migrate=True,
    fake_migrate=False,
    migrate_enabled=True,
    fake_migrate_all=False,
    decode_credentials=False,
    driver_args=None,
    adapter_args=None,
    attempts=5,
    auto_import=False,
    bigint_id=False,
    debug=False,
    lazy_tables=False,
    db_uid=None,
    do_connect=True,
    after_connection=None,
    tables=None,
    ignore_field_case=True,
    entity_quoting=False,
    table_hash=None)</code></pre><p><span class="anchor" id="markmin_connection_strings"></span></p><h4>Connection strings (the uri parameter)</h4><div class="inxx">connection strings</div><p>A connection with the database is established by creating an instance of the DAL object:</p><pre><code class="code">&gt;&gt;&gt; db = DAL('sqlite://storage.db', pool_size=0)</code></pre><p><code>db</code> is not a keyword; it is a local variable that stores the connection object <code>DAL</code>. You are free to give it a different name. The constructor of <code>DAL</code> requires a single argument, the connection string. The connection string is the only web2py code that depends on a specific back-end database. Here are examples of connection strings for specific types of supported back-end databases (in all cases, we assume the database is running from localhost on its default port and is named "test"):</p><code class="index">ndb</code><table><tbody><tr class="first"><td><strong>SQLite</strong></td><td><code>sqlite://storage.db</code></td></tr><tr class="even"><td><strong>MySQL</strong></td><td><code>mysql://username:password@localhost/test</code></td></tr><tr><td><strong>PostgreSQL</strong></td><td><code>postgres://username:password@localhost/test</code></td></tr><tr class="even"><td><strong>MSSQL (legacy)</strong></td><td><code>mssql://username:password@localhost/test</code></td></tr><tr><td><strong>MSSQL (&gt;=2005)</strong></td><td><code>mssql3://username:password@localhost/test</code></td></tr><tr class="even"><td><strong>MSSQL (&gt;=2012)</strong></td><td><code>mssql4://username:password@localhost/test</code></td></tr><tr><td><strong>FireBird</strong></td><td><code>firebird://username:password@localhost/test</code></td></tr><tr class="even"><td><strong>Oracle</strong></td><td><code>oracle://username/password@test</code></td></tr><tr><td><strong>DB2</strong></td><td><code>db2://username:password@test</code></td></tr><tr class="even"><td><strong>Ingres</strong></td><td><code>ingres://username:password@localhost/test</code></td></tr><tr><td><strong>Sybase</strong></td><td><code>sybase://username:password@localhost/test</code></td></tr><tr class="even"><td><strong>Informix</strong></td><td><code>informix://username:password@test</code></td></tr><tr><td><strong>Teradata</strong></td><td><code>teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=test</code></td></tr><tr class="even"><td><strong>Cubrid</strong></td><td><code>cubrid://username:password@localhost/test</code></td></tr><tr><td><strong>SAPDB</strong></td><td><code>sapdb://username:password@localhost/test</code></td></tr><tr class="even"><td><strong>IMAP</strong></td><td><code>imap://user:password@server:port</code></td></tr><tr><td><strong>MongoDB</strong></td><td><code>mongodb://username:password@localhost/test</code></td></tr><tr class="even"><td><strong>Google/SQL</strong></td><td><code>google:sql://project:instance/database</code></td></tr><tr><td><strong>Google/NoSQL</strong></td><td><code>google:datastore</code></td></tr><tr class="even"><td><strong>Google/NoSQL/NDB</strong></td><td><code>google:datastore+ndb</code></td></tr></tbody></table><p>Notice that in SQLite the database consists of a single file. If it does not exist, it is created. This file is locked every time it is accessed. In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and Informix the database "test" must be created outside web2py. Once the connection is established, web2py will create, alter, and drop tables appropriately.</p><p>In the Google/NoSQL case the <code>+ndb</code> option turns on NDB. NDB uses a Memcache buffer to read data that is accessed often. This is completely automatic and done at the datastore level, not at the web2py level.</p><p>It is also possible to set the connection string to <code>None</code>. In this case DAL will not connect to any back-end database, but the API can still be accessed for testing. Examples of this will be discussed in Chapter 7.</p><p>Some times you may need to generate SQL as if you had a connection but without actually connecting to the database. This can be done with</p><pre><code class="code">db = DAL('...', do_connect=False)</code></pre><p>In this case you will be able to call <code>_select</code>, <code>_insert</code>, <code>_update</code>, and <code>_delete</code> to generate SQL but not call <code>select</code>, <code>insert</code>, <code>update</code>, and <code>delete</code>. In most of the cases you can use <code>do_connect=False</code> even without having the required database drivers.</p><p>Notice that by default web2py uses utf8 character encoding for databases. If you work with existing databases that behave differently, you have to change it with the optional parameter <code>db_codec</code> like</p><pre><code class="code">db = DAL('...', db_codec='latin1')</code></pre><p>Otherwise you'll get UnicodeDecodeError tickets.</p><h4>Connection pooling</h4><div class="inxx">connection pooling</div><p>A common argument of the DAL constructor is the <code>pool_size</code>; it defaults to zero.</p><p>As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to recycle a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</p><p>When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of <code>pool_size</code> and the max number of concurrent requests. This means that if <code>pool_size=10</code> but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If <code>pool_size=0</code> then connection pooling is not used.</p><p>Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</p><p>The <code>pool_size</code> parameter is ignored by SQLite and Google App Engine. Connection pooling is ignored for SQLite, since it would not yield any benefit.</p><h4>Connection failures (attempts parameter)</h4><p>If web2py fails to connect to the database it waits 1 seconds and by default tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections. The number of attempts is set via the attempts parameter.</p><h4>Lazy Tables</h4><p>setting <code>lazy_tables = True</code> provides a major performance boost. See below: <a href="#markmin_lazy_tables">lazy tables</a></p><h4>Replicated databases</h4><p>The first argument of <code>DAL(...)</code> can be a list of URIs. In this case web2py tries to connect to each of them. The main purpose for this is to deal with multiple database servers and distribute the workload among them). Here is a typical use case:</p><pre><code class="code">db = DAL(['mysql://...1','mysql://...2','mysql://...3'])</code></pre><p>In this case the DAL tries to connect to the first and, on failure, it will try the second and the third. This can also be used to distribute load in a database master-slave configuration. We will talk more about this in Chapter 13 in the context of scalability.</p><h4>Reserved keywords</h4><div class="inxx">reserved Keywords</div><p><code>check_reserved</code> tells the constructor to check table names and column names against reserved SQL keywords in target back-end databases. <code>check_reserved</code> defaults to None.</p><p>This is a list of strings that contain the database back-end adapter names.</p><p>The adapter name is the same as used in the DAL connection string. So if you want to check against PostgreSQL and MSSQL then your connection string would look as follows:</p><pre><code class="code">db = DAL('sqlite://storage.db',
         check_reserved=['postgres', 'mssql'])</code></pre><p>The DAL will scan the keywords in the same order as of the list.</p><p>There are two extra options "all" and "common". If you specify all, it will check against all known SQL keywords. If you specify common, it will only check against common SQL keywords such as <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, etc.</p><p>For supported back-ends you may also specify if you would like to check against the non-reserved SQL keywords as well. In this case you would append <code>_nonreserved</code> to the name. For example:</p><pre><code class="code">check_reserved=['postgres', 'postgres_nonreserved']</code></pre><p>The following database backends support reserved words checking.</p><table><tbody><tr class="first"><td><strong>PostgreSQL</strong></td><td><code>postgres(_nonreserved)</code></td></tr><tr class="even"><td><strong>MySQL</strong></td><td><code>mysql</code></td></tr><tr><td><strong>FireBird</strong></td><td><code>firebird(_nonreserved)</code></td></tr><tr class="even"><td><strong>MSSQL</strong></td><td><code>mssql</code></td></tr><tr><td><strong>Oracle</strong></td><td><code>oracle</code></td></tr></tbody></table><h4>Database quoting and case settings (entity_quoting, ignore_field)</h4><p>You can also use explicit quoting of SQL entities at DAL level.  It works transparently so you can use the same names in python and in the DB schema.</p><code>ignore_field_case = True</code><code>entity_quoting = True</code><p>Here is an example:</p><pre><code class="code">db = DAL('postgres://...', ...,ignore_field_case=False, entity_quoting=True)

db.define_table('table1', Field('column'), Field('COLUMN'))

print db(db.table1.COLUMN != db.table1.column).select()</code></pre><h4>Other DAL constructor parameters</h4><h5>Database folder location</h5><p><code>folder</code> â€“ where .table files will be created. Automatically set within web2py. Use an explicit path when using DAL outside web2py</p><h5>Default migration settings</h5><p>Migration is detailed below in Tables <a href="#markmin_table_migrations">table migrations</a>. The DAL constructor migration settings are booleans affecting defaults and global behaviour.</p><p><code>migrate = True</code> sets default migrate behavior for all tables</p><p><code>fake_migrate = False</code> sets default fake_migrate behavior for all tables</p><p><code>migrate_enabled = True</code> If set to False disables ALL migrations</p><p><code>fake_migrate_all = False</code> If set to True fake migrates ALL tables</p><h4>Experiment with the web2py shell</h4><p>You can experiment with the DAL API using the web2py shell (-S <a href="../04#markmin_CommandLineOptions">command line option</a>).</p><p>Start by creating a connection. For the sake of example, you can use SQLite. Nothing in this discussion changes when you change the back-end engine.</p><p><span class="anchor" id="markmin_table_constructor"></span></p><h3>Table constructor</h3><p><div class="inxx">define_table</div> <div class="inxx">Field</div></p><h4>define_table signature</h4><p>The signature for define_table:</p><p>Tables are defined in the DAL via <code>define_table</code>:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person', Field('name'),
    id=id,
    rname=None,
    redefine=True
    common_filter,
    fake_migrate,
    fields,
    format,
    migrate,
    on_define,
    plural,
    polymodel,
    primarykey,
    redefine,
    sequence_name,
    singular,
    table_class,
    trigger_name)</code></pre><p>It defines, stores and returns a <code>Table</code> object called "person" containing a field (column) "name". This object can also be accessed via <code>db.person</code>, so you do not need to catch the return value.</p><h4><code>id</code>: Notes about the primary key</h4><p>Do not declare a field called "id", because one is created by web2py anyway. Every table has a field called "id" by default. It is an auto-increment integer field (starting at 1) used for cross-reference and for making every record unique, so "id" is a primary key. (Note: the id counter starting at 1 is back-end specific. For example, this does not apply to the Google App Engine NoSQL.)</p><div class="inxx">named id field</div><p>Optionally you can define a Field of <code>type='id'</code> and web2py will use this field as auto-increment id field. This is not recommended except when accessing legacy database tables which have a primary key under a different name. With some limitation, you can also use different primary keys using the <code>primarykey</code> parameter. <a href="#markmin_primarykey">primarykey</a> is explained shortly below.</p><h4><code>plural</code> and <code>singular</code></h4><p>Smartgrid objects may need to know the singular and plural name of the table. The defaults are smart but these parameters allow you to be specific. See smartgrid for more information.</p><h4><code>redefine</code></h4><p>Tables can be defined only once but you can force web2py to redefine an existing table:</p><pre><code class="code">db.define_table('person', Field('name'))
db.define_table('person', Field('name'), redefine=True)</code></pre><p>The redefinition may trigger a migration if field content is different.</p><p><span class="anchor" id="markmin_record_representation"></span></p><h4><code>format</code>: Record representation</h4><p>It is optional but recommended to specify a format representation for records with the <code>format</code> parameter.</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person', Field('name'), format='%(name)s')</code></pre><p>or</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person', Field('name'), format='%(name)s %(id)s')</code></pre><p>or even more complex ones using a function:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person', Field('name'),
       format=lambda r: r.name or 'anonymous')</code></pre><p>The format attribute will be used for two purposes:</p><ul><li>To represent referenced records in select/option drop-downs.</li><li>To set the <code>db.othertable.person.represent</code> attribute for all fields referencing this table. This means that SQLTABLE will not show references by id but will use the format preferred representation instead.</li></ul><h4><code>rname</code>: Record representation</h4><p><code>rname</code> sets a database backend name for the table. This makes the web2py table name an alias, and <code>rname</code> is the real name used when constructing the query for the backend. To illustrate just one use, <code>rname</code> can be used to provide MSSQL fully qualified table names accessing tables belonging to other databases on the server: <code class="code">rname = 'db1.dbo.table1'</code></p><p><span class="anchor" id="markmin_primarykey"></span></p><h4><code>primarykey</code>: Support for legacy tables</h4><p><code>primarykey</code> helps support legacy tables with existing primary keys, even multi-part. See <a href="#markmin_LegacyDatabases">Legacy Databases</a> below.</p><h4><code>migrate</code>, <code>fake_migrate</code></h4><p><code>migrate</code> sets migration options for the table. See <a href="#markmin_table_migrations">Table Migrations</a> below</p><h4><code>table_class</code></h4><p>If you define your own Table class as a sub-class of gluon.dal.Table, you can provide it here; this allows you to extend and override methods. Example: <code class="code">table_class=MyTable</code></p><h4><code>sequence_name</code></h4><p>(Optional) The name of a custom table sequence (if supported by the database). Can create a SEQUENCE (starting at 1 and incrementing by 1) or use this for legacy tables with custom sequences. Note that when necessary, web2py will create sequences automatically by default (starting at 1).</p><h4><code>trigger_name</code></h4><p>(optional) Relates to <code>sequence_name</code>. Relevant for some backends which do not support auto-increment numeric fields.</p><h4><code>polymodel</code></h4><p>For Google App Engine</p><h4><code>on_define</code></h4><p><code>on_define</code> is a callback triggered when a lazy_table is instantiated, although it is called anyway if the table is not lazy. This allows dynamic changes to the table without losing the advantages of delayed instantiation.</p><p>Example:</p><pre><code class="code"> db = DAL(lazy_tables=True) 
 db.define_table('person',Field('name'),Field('age','integer'), 
    on_define=lambda table: [ 
            table.name.set_attributes(requires=IS_NOT_EMPTY(),default=''), 
            table.age.set_attributes(requires=IS_INT_IN_RANGE(0,120),default=30), </code></pre><p>Note this example shows how to use <code>on_define</code> but it is not actually necessary. The simple <code>requires</code> values could be added to the Field definitions and the table would still be lazy. However, <code>requires</code> which take a Set object as the first argument, such as IS_IN_DB, will make a query like <code class="code">db.sometable.somefield == some_value</code> which would cause <code>sometable</code> to be defined early. This is the situation saved by <code>on_define</code>.</p><p><span class="anchor" id="markmin_lazy_tables"></span></p><h4>Lazy Tables, a major performance boost</h4><div class="inxx">lazy tables</div><p>web2py models are executed before controllers, so all tables are defined at every request. Not all tables are needed to handle each request, so it is possible that some of the time spent defining tables is wasted. Conditional models (<a href="../04#markmin_conditional_models">conditional models, chapter 4</a>) can help, but web2py offers a big performance boost via lazy_tables. This feature means that table creation is deferred until the table is actually referenced. Enabling lazy tables is made when initialising a database via the DAL constructor. It requires setting the <code>DAL(...,lazy_tables=True)</code>  parameter. This is one of the most significant response-time performance boosts in web2py.</p><h4>Adding attributes to fields and tables</h4><p>If you need to add custom attributes to fields, you can simply do this:</p><code class="code">db.table.field.extra = {}</code><p>"extra" is not a keyword ; it's a custom attributes now attached to the field object. You can do it with tables too but they must be preceded by an underscore to avoid naming conflicts with fields:</p><code class="code">db.table._extra = {} </code><p><span class="anchor" id="markmin_field_constructor"></span></p><h3>Field constructor</h3><div class="inxx">Field constructor</div><p>These are the default values of a Field constructor:</p><pre><code class="code">Field(fieldname, type='string', length=None, default=None,
      required=False, requires='&lt;default&gt;',
      ondelete='CASCADE', notnull=False, unique=False,
      uploadfield=True, widget=None, label=None, comment=None,
      writable=True, readable=True, update=None, authorize=None,
      autodelete=False, represent=None, compute=None,
      uploadfolder=None,
      uploadseparate=None,uploadfs=None,
      rname=None)</code></pre><p>Not all of them are relevant for every field. "length" is relevant only for fields of type "string". "uploadfield" and "authorize" are relevant only for fields of type "upload". "ondelete" is relevant only for fields of type "reference" and "upload".</p><ul><li><code>length</code> sets the maximum length of a "string", "password" or "upload" field.  If <code>length</code> is not specified a default value is used but the default value is not guaranteed to be backward compatible. <em>To avoid unwanted migrations on upgrades, we recommend that you always specify the length for string, password and upload fields.</em></li><li><code>default</code> sets the default value for the field. The default value is used when performing an insert if a value is not explicitly specified. It is also used to pre-populate forms built from the table using SQLFORM. Note, rather than being a fixed value, the default can instead be a function (including a lambda function) that returns a value of the appropriate type for the field. In that case, the function is called once for each record inserted, even when multiple records are inserted in a single transaction.</li><li><code>required</code> tells the DAL that no insert should be allowed on this table if a value for this field is not explicitly specified.</li><li><code>requires</code> is a validator or a list of validators. This is not used by the DAL, but it is used by SQLFORM. The default validators for the given types are shown in the next section.</li></ul><blockquote>Notice that <code>requires=...</code> is enforced at the level of forms, <code>required=True</code> is enforced at the level of the DAL (insert), while <code>notnull</code>, <code>unique</code> and <code>ondelete</code> are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</blockquote><ul><li><code>uploadfolder</code> while the default is <code>None</code>, most DB adapters will default to uploading files into os.path.join(request.folder, 'uploads'). MongoAdapter does not seem to be doing so at present.</li><li><code>rname</code> provides the field was a "real name", a name for the field known to the database adapter; when the field is used, it is the rname value which is sent to the database. The web2py name for the field is then effectively an alias.</li></ul><div class="inxx">ondelete</div><ul><li><code>ondelete</code> translates into the "ON DELETE" SQL statement. By default it is set to "CASCADE". This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set <code>ondelete</code> to "NO ACTION" or "SET NULL".</li><li><code>notnull=True</code> translates into the "NOT NULL" SQL statement. It prevents the database from inserting null values for the field.</li><li><code>unique=True</code> translates into the "UNIQUE" SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</li><li><code>uploadfield</code> applies only to fields of type "upload". A field of type "upload" stores the name of a file saved somewhere else, by default on the filesystem under the application "uploads/" folder. If <code>uploadfield</code> is set to True, then the file is stored in a blob field within the same table and the value of <code>uploadfield</code> is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</li><li><code>uploadfolder</code> defaults to the application's "uploads/" folder. If set to a different path, files will uploaded to a different folder.</li></ul><blockquote>For example,
<pre><code class="code">Field(...,uploadfolder=os.path.join(request.folder,'static/temp'))</code></pre>
will upload files to the "web2py/applications/myapp/static/temp" folder.</blockquote><ul><li><code>uploadseparate</code> if set to True will upload files under different subfolders of the <em>uploadfolder</em> folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of <code>uploadseparate</code> from True to False without breaking links to existing uploads. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</li><li><code>uploadfs</code> allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote SFTP storage. This option requires PyFileSystem installed. <code>uploadfs</code> must point to <code>PyFileSystem</code>. <div class="inxx">PyFileSystem</div> <code class="idxx">uploadfs</code></li><li><code>widget</code> must be one of the available widget objects, including custom widgets, for example: <code>SQLFORM.widgets.string.widget</code>. A list of available widgets will be discussed later. Each field type has a default widget.</li><li><code>label</code> is a string (or a helper or something that can be serialized to a string) that contains the label to be used for this field in auto-generated forms.</li><li><code>comment</code>  is a string (or a helper or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</li><li><code>writable</code> declares whether a field is writable in forms.</li><li><code>readable</code> declares whether a field is readable in forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</li><li><code>update</code> contains the default value for this field when the record is updated.</li><li><code>compute</code> is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a <code>dict</code>, and the dict will not include the current value of that, or any other compute field.</li><li><code>authorize</code> can be used to require access control on the corresponding field, for "upload" fields only. It will be discussed more in detail in the context of Authentication and Authorization.</li><li><code>autodelete</code> determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For "upload" fields only. However, records deleted by the database itself due to a CASCADE operation will not trigger web2py's autodelete. The web2py Google group has workaround discussions.</li><li><code>represent</code> can be None or can point to a function that takes a field value and returns an alternate representation for the field value.</li></ul><blockquote>Examples:
<pre><code class="code">db.mytable.name.represent = lambda name,row: name.capitalize()
db.mytable.other_id.represent = lambda id,row: row.myfield
db.mytable.some_uploadfield.represent = lambda value,row:     A('get it', _href=URL('download', args=value))</code></pre></blockquote><p><span class="anchor" id="markmin_field_types"></span></p><h4>Field types</h4><div class="inxx">field types</div><table><tbody><tr class="first"><td><strong>field type</strong></td><td><strong>default field validators</strong></td></tr><tr class="even"><td><code>string</code></td><td><code>IS_LENGTH(length)</code> default length is 512</td></tr><tr><td><code>text</code></td><td><code>IS_LENGTH(65536)</code></td></tr><tr class="even"><td><code>blob</code></td><td><code>None</code></td></tr><tr><td><code>boolean</code></td><td><code>None</code></td></tr><tr class="even"><td><code>integer</code></td><td><code>IS_INT_IN_RANGE(-1e100, 1e100)</code></td></tr><tr><td><code>double</code></td><td><code>IS_FLOAT_IN_RANGE(-1e100, 1e100)</code></td></tr><tr class="even"><td><code>decimal(n,m)</code></td><td><code>IS_DECIMAL_IN_RANGE(-1e100, 1e100)</code></td></tr><tr><td><code>date</code></td><td><code>IS_DATE()</code></td></tr><tr class="even"><td><code>time</code></td><td><code>IS_TIME()</code></td></tr><tr><td><code>datetime</code></td><td><code>IS_DATETIME()</code></td></tr><tr class="even"><td><code>password</code></td><td><code>None</code></td></tr><tr><td><code>upload</code></td><td><code>None</code></td></tr><tr class="even"><td><code>reference &lt;table&gt;</code></td><td><code>IS_IN_DB(db,table.field,format)</code></td></tr><tr><td><code>list:string</code></td><td><code>None</code></td></tr><tr class="even"><td><code>list:integer</code></td><td><code>None</code></td></tr><tr><td><code>list:reference &lt;table&gt;</code></td><td><code>IS_IN_DB(db,table.field,format,multiple=True)</code></td></tr><tr class="even"><td><code>json</code></td><td><code>IS_JSON()</code></td></tr><tr><td><code>bigint</code></td><td><code>None</code></td></tr><tr class="even"><td><code>big-id</code></td><td><code>None</code></td></tr><tr><td><code>big-reference</code></td><td><code>None</code></td></tr></tbody></table><p>Decimal requires and returns values as <code>Decimal</code> objects, as defined in the Python <code>decimal</code> module. SQLite does not handle the <code>decimal</code> type so internally we treat it as a <code>double</code>. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</p><p>The <code>big-id</code> and, <code>big-reference</code> are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a <code>bigint_id</code> argument that when set to <code>True</code> makes the <code>id</code> fields and <code>reference</code> fields <code>big-id</code> and <code>big-reference</code> respectively.</p><p>The <code>list:&lt;type&gt;</code> fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types <code>ListProperty</code> and <code>StringListProperty</code>) and back-port them all the other supported relational databases. On relational databases lists are stored as a <code>text</code> field. The items are separated by a <code>|</code> and each <code>|</code> in string item is escaped as a <code>||</code>. They are discussed in their own section.</p><p>The <code>json</code> field type is pretty much explanatory. It can store any json serializable object. It is designed to work specifically for MongoDB and backported to the other database adapters for portability.</p><div class="inxx">blob</div><p><code>blob</code> fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</p><h4>Run-time field and table modification</h4><p>Most attributes of fields and tables can be modified after they are defined:</p><pre><code>db.define_table('person',Field('name',default=''),format='%(name)s')
db.person._format = '%(name)s/%(id)s'
db.person.name.default = 'anonymous'</code></pre><p>(notice that attributes of tables are usually prefixed by an underscore to avoid conflict with possible field names).</p><p>You can list the tables that have been defined for a given database connection:</p><div class="inxx">tables</div><pre><code class="code">&gt;&gt;&gt; print db.tables
['person']</code></pre><p>You can also list the fields that have been defined for a given table:</p><div class="inxx">fields</div><pre><code class="code">&gt;&gt;&gt; print db.person.fields
['id', 'name']</code></pre><p>You can query for the type of a table:</p><div class="inxx">Table</div><pre><code class="code">&gt;&gt;&gt; print type(db.person)
&lt;class 'gluon.sql.Table'&gt;</code></pre><p>and you can access a table from the DAL connection using:</p><pre><code class="code">&gt;&gt;&gt; print type(db['person'])
&lt;class 'gluon.sql.Table'&gt;</code></pre><p>Similarly you can access fields from their name in multiple equivalent ways:</p><pre><code class="code">&gt;&gt;&gt; print type(db.person.name)
&lt;class 'gluon.sql.Field'&gt;
&gt;&gt;&gt; print type(db.person['name'])
&lt;class 'gluon.sql.Field'&gt;
&gt;&gt;&gt; print type(db['person']['name'])
&lt;class 'gluon.sql.Field'&gt;</code></pre><p>Given a field, you can access the attributes set in its definition:</p><pre><code class="code">&gt;&gt;&gt; print db.person.name.type
string
&gt;&gt;&gt; print db.person.name.unique
False
&gt;&gt;&gt; print db.person.name.notnull
False
&gt;&gt;&gt; print db.person.name.length
32</code></pre><p>including its parent table, tablename, and parent connection:</p><pre><code class="code">&gt;&gt;&gt; db.person.name._table == db.person
True
&gt;&gt;&gt; db.person.name._tablename == 'person'
True
&gt;&gt;&gt; db.person.name._db == db
True</code></pre><p>A field also has methods. Some of them are used to build queries and we will see them later. A special method of the field object is <code>validate</code> and it calls the validators for the field.</p><pre><code>print db.person.name.validate('John')</code></pre><p>which returns a tuple <code>(value, error)</code>. <code>error</code> is <code>None</code> if the input passes validation.</p><p><span class="anchor" id="markmin_table_migrations"></span></p><h3>Migrations</h3><div class="inxx">migrations</div><p><code>define_table</code> checks whether or not the corresponding table exists. If it does not, it generates the SQL to create it and executes the SQL. If the table does exist but differs from the one being defined, it generates the SQL to alter the table and executes it. If a field has changed type but not name, it will try to convert the data (If you do not want this, you need to redefine the table twice, the first time, letting web2py drop the field by removing it, and the second time adding the newly defined field so that web2py can create it.). If the table exists and matches the current definition, it will leave it alone. In all cases it will create the <code>db.person</code> object that represents the table.</p><p>We refer to this behavior as a "migration". web2py logs all migrations and migration attempts in the file "databases/sql.log".</p><p>The first argument of <code>define_table</code> is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional keyword argument called "migrate":</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person', Field('name'), migrate='person.table')</code></pre><p>The value of migrate is the filename (in the "databases" folder for the application) where web2py stores internal migration information for this table. These files are very important and should never be removed while the corresponding tables exist.  In cases where a table has been dropped and the corresponding file still exist, it can be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in <code>define_table</code>. The best practice is to give an explicit name to the migrate table.</p><p>There may not be two tables in the same application with the same migrate filename.</p><p>The DAL class also takes a "migrate" argument, which determines the default value of migrate for calls to <code>define_table</code>. For example,</p><pre><code class="code">&gt;&gt;&gt; db = DAL('sqlite://storage.db', migrate=False)</code></pre><p>will set the default value of migrate to False whenever <code>db.define_table</code> is called without a migrate argument.</p><blockquote>Notice that web2py only migrates new columns, removed columns, and changes in column type (except in sqlite). web2py does not migrate changes in attributes such as changes in the values of <code>default</code>, <code>unique</code>, <code>notnull</code>, and <code>ondelete</code>.</blockquote><p>Migrations can be disabled for all tables at once:</p><pre><code>db = DAL(...,migrate_enabled=False)</code></pre><p>This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</p><h3>Fixing broken migrations</h3><div class="inxx">fake_migrate</div><p>There are two common problems with migrations and there are ways to recover from them.</p><p>One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</p><p>If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</p><p>The solution consists in updating all records of the table and updating the values in the column in question with None.</p><p>The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</p><p>The solution consists of disabling migrations for all tables and enabling fake migrations:</p><pre><code class="code">db.define_table(....,migrate=True,fake_migrate=True)</code></pre><p>This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the <code>fake_migrate=True</code> parameter.</p><p>Before attempting to fix migration problems it is prudent to make a copy of "applications/yourapp/databases/*.table" files.</p><p>Migration problems can also be fixed for all tables at once:</p><pre><code class="code">db = DAL(...,fake_migrate_all=True)</code></pre><p>This also fails if the model describes tables that do not exist in the database, but it can help narrowing down the problem.</p><h3>Migration control summary</h3><p>The logic of the various migration arguments are summarized in this pseudo-code:</p><pre><code class="code">if DAL.migrate_enabled and table.migrate:
   if DAL.fake_migrate_all or table.fake_migrate:
       perform fake migration
   else:
       perform migration</code></pre><h3><code>insert</code></h3><p>Given a table, you can insert records</p><div class="inxx">insert</div><pre><code class="code">&gt;&gt;&gt; db.person.insert(name="Alex")
1
&gt;&gt;&gt; db.person.insert(name="Bob")
2</code></pre><p>Insert returns the unique "id" value of each record inserted.</p><p>You can truncate the table, i.e., delete all records and reset the counter of the id.</p><div class="inxx">truncate</div><pre><code class="code">&gt;&gt;&gt; db.person.truncate()</code></pre><p>Now, if you insert a record again, the counter starts again at 1 (this is back-end specific and does not apply to Google NoSQL):</p><pre><code class="code">&gt;&gt;&gt; db.person.insert(name="Alex")
1</code></pre><p>Notice you can pass parameters to <code>truncate</code>, for example you can tell SQLITE to restart the id counter.</p><pre><code class="code">db.person.truncate('RESTART IDENTITY CASCADE')</code></pre><p>The argument is in raw SQL and therefore engine specific.</p><div class="inxx">bulk_insert</div><p>web2py also provides a bulk_insert method</p><pre><code class="code">&gt;&gt;&gt; db.person.bulk_insert([{'name':'Alex'}, {'name':'John'}, {'name':'Tim'}])
[3,4,5]</code></pre><p>It takes a list of dictionaries of fields to be inserted and performs multiple inserts at once. It returns the IDs of the inserted records. On the supported relational databases there is no advantage in using this function as opposed to looping and performing individual inserts but on Google App Engine NoSQL, there is a major speed advantage.</p><h3><code>commit</code> and <code>rollback</code></h3><p>No create, drop, insert, truncate, delete, or update operation is actually committed until web2py issues the commit command. In models, views and controllers, web2py does this for you, but in modules you are required to do the commit.</p><div class="inxx">commit</div><pre><code class="code">&gt;&gt;&gt; db.commit()</code></pre><p>To check it let's insert a new record:</p><pre><code class="code">&gt;&gt;&gt; db.person.insert(name="Bob")
2</code></pre><p>and roll back, i.e., ignore all operations since the last commit:</p><div class="inxx">rollback</div><pre><code class="code">&gt;&gt;&gt; db.rollback()</code></pre><p>If you now insert again, the counter will again be set to 2, since the previous insert was rolled back.</p><pre><code class="code">&gt;&gt;&gt; db.person.insert(name="Bob")
2</code></pre><p>Code in models, views and controllers is enclosed in web2py code that looks like this:</p><pre><code class="code">try:
     execute models, controller function and view
except:
     rollback all connections
     log the traceback
     send a ticket to the visitor
else:
     commit all connections
     save cookies, sessions and return the page</code></pre><p>So in models, views and controllers there is no need to ever call <code>commit</code>  or <code>rollback</code> explicitly in web2py unless you need more granular control. However, in modules you will need to use <code>commit()</code>.</p><h3>Raw SQL</h3><h4>Timing queries</h4><p>All queries are automatically timed by web2py. The variable <code>db._timings</code> is a list of tuples. Each tuple contains the raw SQL query as passed to the database driver and the time it took to execute in seconds. This variable can be displayed in views using the toolbar:</p><pre><code>{{=response.toolbar()}}</code></pre><h4><code>executesql</code></h4><p>The DAL allows you to explicitly issue SQL statements.</p><div class="inxx">executesql</div><pre><code class="code">&gt;&gt;&gt; print db.executesql('SELECT * FROM person;')
[(1, u'Massimo'), (2, u'Massimo')]</code></pre><p>In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes. <code>executesql</code> takes four optional arguments: <code>placeholders</code>, <code>as_dict</code>, <code>fields</code> and <code>colnames</code>. <code>placeholders</code> is an optional sequence of values to be substituted in or, if supported by the DB driver, a dictionary with keys matching named placeholders in your SQL.</p><p>If <code>as_dict</code> is set to True, the results cursor returned by the DB driver will be converted to a sequence of dictionaries keyed with the db field names.  Results returned with <code>as_dict = True</code> are the same as those returned when applying <strong>.as_list()</strong> to a normal select.</p><pre><code class="code">[{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</code></pre><p>The <code>fields</code> argument is a list of DAL Field objects that match the fields returned from the DB. The Field objects should be part of one or more Table objects defined on the DAL object. The <code>fields</code> list can include one or more DAL Table objects in addition to or instead of including Field objects, or it can be just a single table (not in a list). In that case, the Field objects will be extracted from the table(s).</p><p>Instead of specifying the <code>fields</code> argument, the <code>colnames</code> argument can be specified as a list of field names in tablename.fieldname format. Again, these should represent tables and fields defined on the DAL object.</p><p>It is also possible to specify both <code>fields</code> and the associated <code>colnames</code>. In that case, <code>fields</code> can also include DAL Expression objects in addition to Field objects. For Field objects in "fields", the associated <code>colnames</code> must still be in tablename.fieldname format. For Expression objects in <code>fields</code>, the associated <code>colnames</code> can be any arbitrary labels.</p><p>Notice, the DAL Table objects referred to by <code>fields</code> or <code>colnames</code> can be dummy tables and do not have to represent any real tables in the database. Also, note that the <code>fields</code> and <code>colnames</code> must be in the same order as the fields in the results cursor returned from the DB.</p><h4><code>_lastsql</code></h4><p>Whether SQL was executed manually using executesql or was SQL generated by the DAL, you can always find the SQL code in <code>db._lastsql</code>. This is useful for debugging purposes:</p><div class="inxx">_lastdb</div><pre><code class="code">&gt;&gt;&gt; rows = db().select(db.person.ALL)
&gt;&gt;&gt; print db._lastsql
SELECT person.id, person.name FROM person;</code></pre><blockquote>web2py never generates queries using the "*" operator. web2py is always explicit when selecting fields.</blockquote><h3><code>drop</code></h3><p>Finally, you can drop tables and all data will be lost:</p><div class="inxx">drop</div><pre><code class="code">&gt;&gt;&gt; db.person.drop()</code></pre><p>Note for sqlite: web2py will not re-create the dropped table until you navigate the file system to the databases directory of your app, and delete the file associated with the dropped table.</p><h3>Indexes</h3><p>Currently the DAL API does not provide a command to create indexes on tables, but this can be done using the <code>executesql</code> command. This is because the existence of indexes can make migrations complex, and it is better to deal with them explicitly. Indexes may be needed for those fields that are used in recurrent queries.</p><p>Here is an example of how to <a href="http://www.sqlite.org/lang_createindex.html">create an index using SQL in SQLite</a>:</p><pre><code class="code">&gt;&gt;&gt; db = DAL('sqlite://storage.db')
&gt;&gt;&gt; db.define_table('person', Field('name'))
&gt;&gt;&gt; db.executesql('CREATE INDEX IF NOT EXISTS myidx ON person (name);')</code></pre><p>Other database dialects have very similar syntaxes but may not support the optional "IF NOT EXISTS" directive.</p><p><span class="anchor" id="markmin_LegacyDatabases"></span></p><h3>Legacy databases and keyed tables</h3><p>web2py can connect to legacy databases under some conditions.</p><p>The easiest way is when these conditions are met:</p><ul><li>Each table must have a unique auto-increment integer field called "id"</li><li>Records must be referenced exclusively using the "id" field.</li></ul><p>When accessing an existing table, i.e., a table not created by web2py in the current application, always set <code>migrate=False</code>.</p><p>If the legacy table has an auto-increment integer field but it is not called "id", web2py can still access it but the table definition must contain explicitly as <code>Field('....','id')</code> where ... is the name of the auto-increment integer field.</p><div class="inxx">keyed table</div><p>Finally if the legacy table uses a primary key that is not an auto-increment id field it is possible to use a "keyed table", for example:</p><pre><code class="code">db.define_table('account',
    Field('accnum','integer'),
    Field('acctype'),
    Field('accdesc'),
    primarykey=['accnum','acctype'],
    migrate=False)</code></pre><ul><li><code>primarykey</code> is a list of the field names that make up the primary key.</li><li>All primarykey fields have a <code>NOT NULL</code> set even if not specified.</li><li>Keyed tables can only reference other keyed tables.</li><li>Referencing fields must use the <code>reference tablename.fieldname</code> format.</li><li>The <code>update_record</code> function is not available for Rows of keyed tables.</li></ul><blockquote>Currently keyed tables are only supported for DB2, MS-SQL, Ingres and Informix, but others engines will be added.</blockquote><p>At the time of writing, we cannot guarantee that the <code>primarykey</code> attribute works with every existing legacy table and every supported database backend. For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</p><h3>Distributed transaction</h3><div class="inxx">distributed transactions</div><blockquote>At the time of writing this feature is only supported
by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</blockquote><p>Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</p><pre><code class="code">db_a = DAL('postgres://...')
db_b = DAL('postgres://...')</code></pre><p>In your models or controllers, you can commit them concurrently with:</p><pre><code class="code">DAL.distributed_transaction_commit(db_a, db_b)</code></pre><p>On failure, this function rolls back and raises an <code>Exception</code>.</p><p>In controllers, when one action returns, if you have two distinct connections and you do not call the above function, web2py commits them separately. This means there is a possibility that one of the commits succeeds and one fails. The distributed transaction prevents this from happening.</p><h3>More on uploads</h3><p>Consider the following model:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('myfile',
    Field('image', 'upload', default='path/'))</code></pre><p>In the case of an 'upload' field, the default value can optionally be set to a path (an absolute path or a path relative to the current app folder) and the default image will be set to a copy of the file at the path. A new copy is made for each new record that does not specify an image.</p><p>Normally an insert is handled automatically via a SQLFORM or a crud form (which is a SQLFORM) but occasionally you already have the file on the filesystem and want to upload it programmatically. This can be done in this way:</p><pre><code class="code">&gt;&gt;&gt; stream = open(filename, 'rb')
&gt;&gt;&gt; db.myfile.insert(image=db.myfile.image.store(stream, filename))</code></pre><p>It is also possible to insert a file in a simpler way and have the insert method call store automatically:</p><pre><code class="code">&gt;&gt;&gt; stream = open(filename, 'rb')
&gt;&gt;&gt; db.myfile.insert(image=stream)</code></pre><p>In this case the filename is obtained from the stream object if available.</p><p>The <code>store</code> method of the upload field object takes a file stream and a filename. It uses the filename to determine the extension (type) of the file, creates a new temp name for the file (according to web2py upload mechanism) and loads the file content in this new temp file (under the uploads folder unless specified otherwise). It returns the new temp name, which is then stored in the <code>image</code> field of the <code>db.myfile</code> table.</p><p>Note, if the file is to be stored in an associated blob field rather than the file system, the <code>store()</code> method will not insert the file in the blob field (because <code>store()</code> is called before the insert), so the file must be explicitly inserted into the blob field:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('myfile',
        Field('image', 'upload', uploadfield='image_file'),
        Field('image_file', 'blob'))
&gt;&gt;&gt; stream = open(filename, 'rb')
&gt;&gt;&gt; db.myfile.insert(image=db.myfile.image.store(stream, filename),
        image_file=stream.read())</code></pre><p>The opposite of <code>.store</code> is <code>.retrieve</code>:</p><pre><code>&gt;&gt;&gt; row = db(db.myfile).select().first()
&gt;&gt;&gt; (filename, stream) = db.myfile.image.retrieve(row.image)
&gt;&gt;&gt; import shutil
&gt;&gt;&gt; shutil.copyfileobj(stream,open(filename,'wb'))</code></pre><h3><code>Query</code>, <code>Set</code>, <code>Rows</code></h3><p>Let's consider again the table defined (and dropped) previously and insert three records:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person', Field('name'))
&gt;&gt;&gt; db.person.insert(name="Alex")
1
&gt;&gt;&gt; db.person.insert(name="Bob")
2
&gt;&gt;&gt; db.person.insert(name="Carl")
3</code></pre><p>You can store the table in a variable. For example, with variable <code>person</code>, you could do:</p><div class="inxx">Table</div><pre><code class="code">&gt;&gt;&gt; person = db.person</code></pre><p>You can also store a field in a variable such as <code>name</code>.  For example, you could also do:</p><div class="inxx">Field</div><pre><code class="code">&gt;&gt;&gt; name = person.name</code></pre><p>You can even build a query (using operators like ==, !=, &lt;, &gt;, &lt;=, &gt;=, like, belongs) and store the query in a variable <code>q</code> such as in:</p><div class="inxx">Query</div><pre><code class="code">&gt;&gt;&gt; q = name=='Alex'</code></pre><p>When you call <code>db</code> with a query, you define a set of records. You can store it in a variable <code>s</code> and write:</p><div class="inxx">Set</div><pre><code class="code">&gt;&gt;&gt; s = db(q)</code></pre><p>Notice that no database query has been performed so far. DAL + Query simply define a set of records in this db that match the query. web2py determines from the query which table (or tables) are involved and, in fact, there is no need to specify that.</p><h3><code>select</code></h3><p>Given a Set, <code>s</code>, you can fetch the records with the command <code>select</code>:</p><p><div class="inxx">Rows</div> <div class="inxx">select</div></p><pre><code class="code">&gt;&gt;&gt; rows = s.select()</code></pre><div class="inxx">Row</div><p>It returns an iterable object of class <code>gluon.sql.Rows</code> whose elements are Row objects. <code>gluon.sql.Row</code> objects act like dictionaries, but their elements can also be accessed as attributes, like <code>gluon.storage.Storage</code>.The former differ from the latter because its values are read-only.</p><p>The Rows object allows looping over the result of the select and printing the selected field values for each row:</p><pre><code class="code">&gt;&gt;&gt; for row in rows:
        print row.id, row.name
1 Alex</code></pre><p>You can do all the steps in one statement:</p><pre><code class="code">&gt;&gt;&gt; for row in db(db.person.name=='Alex').select():
        print row.name
Alex</code></pre><div class="inxx">ALL</div><p>The select command can take arguments. All unnamed arguments are interpreted as the names of the fields that you want to fetch. For example, you can be explicit on fetching field "id" and field "name":</p><pre><code class="code">&gt;&gt;&gt; for row in db().select(db.person.id, db.person.name):
        print row.name
Alex
Bob
Carl</code></pre><p>The table attribute ALL allows you to specify all fields:</p><pre><code class="code">&gt;&gt;&gt; for row in db().select(db.person.ALL):
        print row.name
Alex
Bob
Carl</code></pre><p>Notice that there is no query string passed to db. web2py understands that if you want all fields of the table person without additional information then you want all records of the table person.</p><p>An equivalent alternative syntax is the following:</p><pre><code class="code">&gt;&gt;&gt; for row in db(db.person.id &gt; 0).select():
        print row.name
Alex
Bob
Carl</code></pre><p>and web2py understands that if you ask for all records of the table person (id &gt; 0) without additional information, then you want all the fields of table person.</p><p>Given one row</p><pre><code>row = rows[0]</code></pre><p>you can extract its values using multiple equivalent expressions:</p><pre><code>&gt;&gt;&gt; row.name
Alex
&gt;&gt;&gt; row['name']
Alex
&gt;&gt;&gt; row('person.name')
Alex</code></pre><p>The latter syntax is particularly handy when selecting en expression instead of a column. We will show this later.</p><p>You can also do</p><pre><code>rows.compact = False</code></pre><p>to disable the notation</p><pre><code>row[i].name</code></pre><p>and enable, instead, the less compact notation:</p><pre><code>row[i].person.name</code></pre><p>Yes this is unusual and rarely needed.</p><h4>Rendering rows using represent</h4><p>You may wish to rewrite rows returned by select to take advantage of formatting information contained in the represents setting of the fields.</p><pre><code class="code">rows = db(query).select()  
repr_row = rows.render(0)</code></pre><p>If you don't specify an index, you get a generator to iterate over all the rows:</p><pre><code class="code">for row in rows.render():
    print row.myfield</code></pre><p>Can also be applied to slices:</p><pre><code class="code">for row in rows[0:10].render():
    print row.myfield</code></pre><p>If you only want to transform selected fields via their "represent" attribute, you can list them in the "fields" argument:</p><pre><code class="code">repr_row = row.render(0, fields=[db.mytable.myfield])</code></pre><p>Note, it returns a transformed copy of the original Row, so there's no update_record (which you wouldn't want anyway) or delete_record.</p><h4>Shortcuts</h4><div class="inxx">DAL shortcuts</div><p>The DAL supports various code-simplifying shortcuts. In particular:</p><pre><code class="code">myrecord = db.mytable[id]</code></pre><p>returns the record with the given <code>id</code> if it exists. If the <code>id</code> does not exist, it returns <code>None</code>. The above statement is equivalent to</p><pre><code class="code">myrecord = db(db.mytable.id==id).select().first()</code></pre><p>You can delete records by id:</p><pre><code class="code">del db.mytable[id]</code></pre><p>and this is equivalent to</p><pre><code class="code">db(db.mytable.id==id).delete()</code></pre><p>and deletes the record with the given <code>id</code>, if it exists.</p><p>Note: This delete shortcut syntax does not currently work if <a href="#markmin_versioning">versioning</a> is activated</p><p>You can insert records:</p><pre><code class="code">db.mytable[0] = dict(myfield='somevalue')</code></pre><p>It is equivalent to</p><pre><code class="code">db.mytable.insert(myfield='somevalue')</code></pre><p>and it creates a new record with field values specified by the dictionary on the right hand side.</p><p>You can update records:</p><pre><code class="code">db.mytable[id] = dict(myfield='somevalue')</code></pre><p>which is equivalent to</p><pre><code class="code">db(db.mytable.id==id).update(myfield='somevalue')</code></pre><p>and it updates an existing record with field values specified by the dictionary on the right hand side.</p><h4>Fetching a <code>Row</code></h4><p>Yet another convenient syntax is the following:</p><pre><code class="code">record = db.mytable(id)
record = db.mytable(db.mytable.id==id)
record = db.mytable(id,myfield='somevalue')</code></pre><p>Apparently similar to <code>db.mytable[id]</code> the above syntax is more flexible and safer. First of all it checks whether <code>id</code> is an int (or <code>str(id)</code> is an int) and returns <code>None</code> if not (it never raises an exception). It also allows to specify multiple conditions that the record must meet. If they are not met, it also returns <code>None</code>.</p><h4>Recursive <code>select</code>s</h4><div class="inxx">recursive selects</div><p>Consider the previous table person and a new table "thing" referencing a "person":</p><pre><code class="code">&gt;&gt;&gt; db.define_table('thing',
        Field('name'),
        Field('owner_id','reference person'))</code></pre><p>and a simple select from this table:</p><pre><code class="code">&gt;&gt;&gt; things = db(db.thing).select()</code></pre><p>which is equivalent to</p><pre><code class="code">&gt;&gt;&gt; things = db(db.thing._id&gt;0).select()</code></pre><p>where <code>._id</code> is a reference to the primary key of the table. Normally <code>db.thing._id</code> is the same as <code>db.thing.id</code> and we will assume that in most of this book. <div class="inxx">_id</div></p><p>For each Row of things it is possible to fetch not just fields from the selected table (thing) but also from linked tables (recursively):</p><pre><code class="code">&gt;&gt;&gt; for thing in things: print thing.name, thing.owner_id.name</code></pre><p>Here <code>thing.owner_id.name</code> requires one database select for each thing in things and it is therefore inefficient. We suggest using joins whenever possible instead of recursive selects, nevertheless this is convenient and practical when accessing individual records.</p><p>You can also do it backwards, by selecting the things referenced by a person:</p><pre><code class="code">person =  db.person(id)
for thing in person.thing.select(orderby=db.thing.name):
    print person.name, 'owns', thing.name</code></pre><p>In this last expressions <code>person.thing</code> is a shortcut for</p><pre><code class="code">db(db.thing.owner_id==person.id)</code></pre><p>i.e. the Set of <code>thing</code>s referenced by the current <code>person</code>. This syntax breaks down if the referencing table has multiple references to the referenced table. In this case one needs to be more explicit and use a full Query.</p><h4>Serializing <code>Rows</code> in views</h4><p>Given the following action containing a query</p><div class="inxx">SQLTABLE</div><pre><code class="code">def index():
    return dict(rows = db(query).select())</code></pre><p>The result of a select can be displayed in a view with the following syntax:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Records&lt;/h1&gt;
{{=rows}}</code></pre><p>Which is equivalent to:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Records&lt;/h1&gt;
{{=SQLTABLE(rows)}}</code></pre><p><code>SQLTABLE</code> converts the rows into an HTML table with a header containing the column names and one row per record. The rows are marked as alternating class "even" and class "odd". Under the hood, Rows is first converted into a SQLTABLE object (not to be confused with Table) and then serialized. The values extracted from the database are also formatted by the validators associated to the field and then escaped.</p><p>Yet it is possible and sometimes convenient to call SQLTABLE explicitly.</p><p>The SQLTABLE constructor takes the following optional arguments:</p><ul><li><code>linkto</code> lambda function or an action to be used to link reference fields (default to None).</li></ul><p>If you assign it a string with the name of an action, it will generate a link to that function passing it, as args, the name of the table and the id of each record (in this order). Example:</p><pre><code class="code">linkto = 'pointed_function' # generates something like &lt;a href="pointed_function/table_name/id_value"&gt;</code></pre><p>If you want a different link to be generated, you can specify a lambda, wich will receive as parameters, the value of the id, the type of the object (e.g. table), and the name of the object. For example, if you want to receive the args in reverse order:</p><pre><code class="code">linkto = lambda id, type, name: URL(f='pointed_function', args=[id, name])</code></pre><ul><li><code>upload</code> the URL or the download action to allow downloading of uploaded files (default to None)</li><li><code>headers</code> a dictionary mapping field names to their labels to be used as headers (default to <code>{}</code>). It can also be an instruction. Currently we support <code>headers='fieldname:capitalize'</code>.</li><li><code>truncate</code> the number of characters for truncating long values in the table (default is 16)</li><li><code>columns</code> the list of fieldnames to be shown as columns (in tablename.fieldname format). Those not listed are not displayed (defaults to all).</li><li><code>**attributes</code> generic helper attributes to be passed to the most external TABLE object.</li></ul><p>Here is an example:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Records&lt;/h1&gt;
{{=SQLTABLE(rows,
     headers='fieldname:capitalize',
     truncate=100,
     upload=URL('download'))
}}</code></pre><p><div class="inxx">SQLFORM.grid</div> <div class="inxx">SQLFORM.smartgrid</div></p><blockquote><code>SQLTABLE</code> is useful but there are times when one needs more. <code>SQLFORM.grid</code> is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. <code>SQLFORM.smartgrid</code> is a further generalization that allows all of the above but also creates buttons to access referencing records.</blockquote><p>Here is an example of usage of <code>SQLFORM.grid</code>:</p><pre><code class="code">def index():
    return dict(grid=SQLFORM.grid(query))</code></pre><p>and the corresponding view:</p><pre><code>{{extend 'layout.html'}}
{{=grid}}</code></pre><p>For working with multiple rows, <code>SQLFORM.grid</code> and <code>SQLFORM.smartgrid</code> are preferred to <code>SQLTABLE</code> because they are more powerful. Please see chapter 7.</p><p><span class="anchor" id="markmin_orderby"></span> <span class="anchor" id="markmin_limitby"></span> <span class="anchor" id="markmin_distinct"></span></p><h4><code>orderby</code>, <code>groupby</code>, <code>limitby</code>, <code>distinct</code>, <code>having</code>,<code>orderby_on_limitby</code>,<code>left</code>,<code>cache</code></h4><p>The <code>select</code> command takes a number of optional arguments.</p><h5>orderby</h5><p>You can fetch the records sorted by name:</p><p><div class="inxx">orderby</div> <div class="inxx">groupby</div> <div class="inxx">having</div></p><pre><code class="code">&gt;&gt;&gt; for row in db().select(
        db.person.ALL, orderby=db.person.name):
        print row.name
Alex
Bob
Carl</code></pre><p>You can fetch the records sorted by name in reverse order (notice the tilde):</p><pre><code class="code">&gt;&gt;&gt; for row in db().select(
        db.person.ALL, orderby=~db.person.name):
        print row.name
Carl
Bob
Alex</code></pre><p>You can have the fetched records appear in random order:</p><pre><code class="code">&gt;&gt;&gt; for row in db().select(
        db.person.ALL, orderby='&lt;random&gt;'):
        print row.name
Carl
Alex
Bob</code></pre><blockquote>The use of <code>orderby='&lt;random&gt;'</code> is not supported on Google NoSQL.  However, in this situation and likewise in many others where built-ins are insufficient, imports can be used:
<pre><code class="code">import random
rows=db(...).select().sort(lambda row: random.random())</code></pre></blockquote><p>You can sort the records according to multiple fields by concatenating them with a "|":</p><pre><code class="code">&gt;&gt;&gt; for row in db().select(
        db.person.ALL, orderby=db.person.name|db.person.id):
        print row.name
Carl
Bob
Alex</code></pre><h5>groupby, having</h5><p>Using <code>groupby</code> together with <code>orderby</code>, you can group records with the same value for the specified field (this is back-end specific, and is not on the Google NoSQL):</p><pre><code class="code">&gt;&gt;&gt; for row in db().select(
        db.person.ALL,
        orderby=db.person.name, groupby=db.person.name):
        print row.name
Alex
Bob
Carl</code></pre><p>You can use <code>having</code> in conjunction with <code>groupby</code> to group conditionally (only those <code>having</code> the condition are grouped.</p><pre><code>&gt;&gt;&gt; print db(query1).select(db.person.ALL, groupby=db.person.name, having=query2)</code></pre><p>Notice that query1 filters records to be displayed, query2 filters records to be grouped.</p><h5>distinct</h5><div class="inxx">distinct</div><p>With the argument <code>distinct=True</code>, you can specify that you only want to select distinct records. This has the same effect as grouping using all specified fields except that it does not require sorting. When using distinct it is important not to select ALL fields, and in particular not to select the "id" field, else all records will always be distinct.</p><p>Here is an example:</p><pre><code class="code">&gt;&gt;&gt; for row in db().select(db.person.name, distinct=True):
        print row.name
Alex
Bob
Carl</code></pre><p>Notice that <code>distinct</code> can also be an expression for example:</p><pre><code class="code">&gt;&gt;&gt; for row in db().select(db.person.name,distinct=db.person.name):
        print row.name
Alex
Bob
Carl</code></pre><h5>limitby</h5><p>With limitby=(min, max), you can select a subset of the records from offset=min to but not including offset=max (in this case, the first two starting at zero):</p><div class="inxx">limitby</div><pre><code class="code">&gt;&gt;&gt; for row in db().select(db.person.ALL, limitby=(0, 2)):
        print row.name
Alex
Bob</code></pre><h5>orderby_on_limitby</h5><div class="inxx">orderby_on_limitby</div><p>Note that the DAL defaults to implicitly adding an orderby when using a limitby. This ensures the same query returns the same results each time, important for pagination. But it can cause performance problems. use <code>orderby_on_limitby = False</code> to change this (this defaults to True).</p><h5>left</h5><p>Discussed below in the section on joins</p><h5>cache, cacheable</h5><p>An example use which gives much faster selects is:</p><code class="code">rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</code><p>See discussion on 'caching selects', below, to understand what the tradeoffs are.</p><h4>Logical operators</h4><p>Queries can be combined using the binary AND operator "<code>&amp;</code>":</p><p><div class="inxx">and</div> <div class="inxx">or</div> <div class="inxx">not</div></p><pre><code class="code">&gt;&gt;&gt; rows = db((db.person.name=='Alex') &amp; (db.person.id&gt;3)).select()
&gt;&gt;&gt; for row in rows: print row.id, row.name
4 Alex</code></pre><p>and the binary OR operator "<code>|</code>":</p><pre><code class="code">&gt;&gt;&gt; rows = db((db.person.name=='Alex') | (db.person.id&gt;3)).select()
&gt;&gt;&gt; for row in rows: print row.id, row.name
1 Alex</code></pre><p>You can negate a query (or sub-query) with the "<code>!=</code>" binary operator:</p><pre><code class="code">&gt;&gt;&gt; rows = db((db.person.name!='Alex') | (db.person.id&gt;3)).select()
&gt;&gt;&gt; for row in rows: print row.id, row.name
2 Bob
3 Carl</code></pre><p>or by explicit negation with the "<code>~</code>" unary operator:</p><pre><code class="code">&gt;&gt;&gt; rows = db(~(db.person.name=='Alex') | (db.person.id&gt;3)).select()
&gt;&gt;&gt; for row in rows: print row.id, row.name
2 Bob
3 Carl</code></pre><blockquote>Due to Python restrictions in overloading "<code>and</code>" and "<code>or</code>" operators, these cannot be used in forming queries.  The binary operators "<code>&amp;</code>" and "<code>|</code>" must be used instead. Note that these operators (unlike "<code>and</code>" and "<code>or</code>") have higher precedence than comparison operators, so the "extra" parentheses in the above examples are mandatory. Similarly, the unary operator "<code>~</code>" has higher precedence than comparison operators, so <code>~</code>-negated comparisons must also be parenthesized.</blockquote><p>It is also possible to build queries using in-place logical operators:</p><pre><code>&gt;&gt;&gt; query = db.person.name!='Alex'
&gt;&gt;&gt; query &amp;= db.person.id&gt;3
&gt;&gt;&gt; query |= db.person.name=='John'</code></pre><h4><code>count</code>, <code>isempty</code>, <code>delete</code>, <code>update</code></h4><p>You can count records in a set:</p><p><div class="inxx">count</div> <div class="inxx">isempty</div></p><pre><code class="code">&gt;&gt;&gt; print db(db.person.id &gt; 0).count()
3</code></pre><p>Notice that <code>count</code> takes an optional <code>distinct</code> argument which defaults to False, and it works very much like the same argument for <code>select</code>. <code>count</code> has also a <code>cache</code> argument that works very much like the equivalent argument of the <code>select</code> method.</p><p>Sometimes you may need to check if a table is empty. A more efficient way than counting is using the <code>isempty</code> method:</p><pre><code class="code">&gt;&gt;&gt; print db(db.person.id &gt; 0).isempty()
False</code></pre><p>or equivalently:</p><pre><code class="code">&gt;&gt;&gt; print db(db.person).isempty()
False</code></pre><p>You can delete records in a set:</p><div class="inxx">delete</div><pre><code class="code">&gt;&gt;&gt; db(db.person.id &gt; 3).delete()</code></pre><p>And you can update all records in a set by passing named arguments corresponding to the fields that need to be updated:</p><div class="inxx">update</div><pre><code class="code">&gt;&gt;&gt; db(db.person.id &gt; 3).update(name='Ken')</code></pre><h4>Expressions</h4><p>The value assigned an update statement can be an expression. For example consider this model</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person',
        Field('name'),
        Field('visits', 'integer', default=0))
&gt;&gt;&gt; db(db.person.name == 'Massimo').update(
        visits = db.person.visits + 1)</code></pre><p>The values used in queries can also be expressions</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person',
        Field('name'),
        Field('visits', 'integer', default=0),
        Field('clicks', 'integer', default=0))
&gt;&gt;&gt; db(db.person.visits == db.person.clicks + 1).delete()</code></pre><h4><code>case</code> <div class="inxx">case</div></h4><p>An expression can contain a case clause for example:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person',Field('name'))
&gt;&gt;&gt; condition = db.person.name.startswith('M')
&gt;&gt;&gt; yes_or_no = condition.case('Yes','No')
&gt;&gt;&gt; for row in db().select(db.person.name, yes_or_no):
...     print row.person.name,  row(yes_or_no)
Max Yes
John No</code></pre><h4><code>update_record</code></h4><div class="inxx">update_record</div><p>web2py also allows updating a single record that is already in memory using <code>update_record</code></p><pre><code class="code">&gt;&gt;&gt; row = db(db.person.id==2).select().first()
&gt;&gt;&gt; row.update_record(name='Curt')</code></pre><p><code>update_record</code> should not be confused with</p><pre><code class="code">&gt;&gt;&gt; row.update(name='Curt')</code></pre><p>because for a single row, the method <code>update</code> updates the row object but not the database record, as in the case of <code>update_record</code>.</p><p>It is also possible to change the attributes of a row (one at a time) and then call <code>update_record()</code> without arguments to save the changes:</p><pre><code class="code">&gt;&gt;&gt; row = db(db.person.id &gt; 2).select().first()
&gt;&gt;&gt; row.name = 'Curt'
&gt;&gt;&gt; row.update_record() # saves above change</code></pre><p>The <code>update_record</code> method is available only if the table's <code>id</code> field is included in the select, and <code>cacheable</code> is not set to <code>True</code>.</p><h4>Inserting and updating from a dictionary</h4><p>A common issue consists of needing to insert or update records in a table where the name of the table, the field to be updated, and the value for the field are all stored in variables. For example: <code>tablename</code>, <code>fieldname</code>, and <code>value</code>.</p><p>The insert can be done using the following syntax:</p><pre><code class="code">db[tablename].insert(**{fieldname:value})</code></pre><p>The update of record with given id can be done with: <div class="inxx">_id</div></p><pre><code class="code">db(db[tablename]._id==id).update(**{fieldname:value})</code></pre><p>Notice we used <code>table._id</code> instead of <code>table.id</code>. In this way the query works even for tables with a field of type "id" which has a name other than "id".</p><h4><code>first</code> and <code>last</code></h4><p><div class="inxx">first</div> <div class="inxx">last</div></p><p>Given a Rows object containing records:</p><pre><code class="code">&gt;&gt;&gt; rows = db(query).select()
&gt;&gt;&gt; first_row = rows.first()
&gt;&gt;&gt; last_row = rows.last()</code></pre><p>are equivalent to</p><pre><code class="code">&gt;&gt;&gt; first_row = rows[0] if len(rows)&gt;0 else None
&gt;&gt;&gt; last_row = rows[-1] if len(rows)&gt;0 else None</code></pre><h4><code>as_dict</code> and <code>as_list</code></h4><p><div class="inxx">as_list</div> <div class="inxx">as_dict</div></p><p>A Row object can be serialized into a regular dictionary using the <code>as_dict()</code> method and a Rows object can be serialized into a list of dictionaries using the <code>as_list()</code> method. Here are some examples:</p><pre><code class="code">&gt;&gt;&gt; rows = db(query).select()
&gt;&gt;&gt; rows_list = rows.as_list()
&gt;&gt;&gt; first_row_dict = rows.first().as_dict()</code></pre><p>These methods are convenient for passing Rows to generic views and or to store Rows in sessions (since Rows objects themselves cannot be serialized since contain a reference to an open DB connection):</p><pre><code class="code">&gt;&gt;&gt; rows = db(query).select()
&gt;&gt;&gt; session.rows = rows # not allowed!
&gt;&gt;&gt; session.rows = rows.as_list() # allowed!</code></pre><h4>Combining rows</h4><p>Row objects can be combined at the Python level. Here we assume:</p><pre><code>&gt;&gt;&gt; print rows1
person.name
Max
Tim
&gt;&gt;&gt; print rows2
person.name
John
Tim</code></pre><p>You can do an intersection of the records in two set of rows:</p><pre><code class="code">&gt;&gt;&gt; rows3 = rows1 &amp; rows2
&gt;&gt;&gt; print rows3
name
Tim</code></pre><p>You can do a union of the records removing duplicates:</p><pre><code class="code">&gt;&gt;&gt; rows3 = rows1 | rows2
&gt;&gt;&gt; print rows3
name
Max
Tim
John</code></pre><h4><code>find</code>, <code>exclude</code>, <code>sort</code></h4><p><div class="inxx">find</div> <div class="inxx">exclude</div> <div class="inxx">sort</div></p><p>Some times you need to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The <code>find</code>, <code>exclude</code> and <code>sort</code> objects allow you to manipulate a Rows object and generate another one without accessing the database. More specifically:</p><ul><li><code>find</code> returns a new set of Rows filtered by a condition and leaves the original unchanged.</li><li><code>exclude</code> returns a new set of Rows filtered by a condition and removes them from the original Rows.</li><li><code>sort</code> returns a new set of Rows sorted by a condition and leaves the original unchanged.</li></ul><p>All these methods take a single argument, a function that acts on each individual row.</p><p>Here is an example of usage:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person',Field('name'))
&gt;&gt;&gt; db.person.insert(name='John')
&gt;&gt;&gt; db.person.insert(name='Max')
&gt;&gt;&gt; db.person.insert(name='Alex')
&gt;&gt;&gt; rows = db(db.person).select()
&gt;&gt;&gt; for row in rows.find(lambda row: row.name[0]=='M'):
        print row.name
Max
&gt;&gt;&gt; print len(rows)
3
&gt;&gt;&gt; for row in rows.exclude(lambda row: row.name[0]=='M'):
        print row.name
Max
&gt;&gt;&gt; print len(rows)
2
&gt;&gt;&gt; for row in rows.sort(lambda row: row.name):
        print row.name
Alex
John</code></pre><p>They can be combined:</p><pre><code class="code">&gt;&gt;&gt; rows = db(db.person).select()
&gt;&gt;&gt; rows = rows.find(
        lambda row: 'x' in row.name).sort(
            lambda row: row.name)
&gt;&gt;&gt; for row in rows:
        print row.name
Alex
Max</code></pre><p>Sort takes an optional argument <code>reverse=True</code> with the obvious meaning.</p><p>The <code>find</code> method has an optional limitby argument with the same syntax and functionality as the Set select <code>method</code>.</p><h3>Other methods</h3><h4><code>update_or_insert</code></h4><div class="inxx">update_or_insert</div><p>Some times you need to perform an insert only if there is no record with the same values as those being inserted. This can be done with</p><pre><code class="code">db.define_table('person',Field('name'),Field('birthplace'))
db.person.update_or_insert(name='John',birthplace='Chicago')</code></pre><p>The record will be inserted only if there is no other user called John born in Chicago.</p><p>You can specify which values to use as a key to determine if the record exists. For example:</p><pre><code class="code">db.person.update_or_insert(db.person.name=='John',
     name='John',birthplace='Chicago')</code></pre><p>and if there is John his birthplace will be updated else a new record will be created.</p><p>The selection criteria in the example above is a single field. It can also be a query, such as</p><pre><code class="code">db.person.update_or_insert((db.person.name=='John') &amp; (db.person.birthplace=='Chicago'),
     name='John',birthplace='Chicago',pet='Rover')</code></pre><h4><code>validate_and_insert</code>, <code>validate_and_update</code></h4><p><div class="inxx">validate_and_insert</div> <div class="inxx">validate_and_update</div></p><p>The function</p><pre><code class="code">ret = db.mytable.validate_and_insert(field='value')</code></pre><p>works very much like</p><pre><code class="code">id = db.mytable.insert(field='value')</code></pre><p>except that it calls the validators for the fields before performing the insert and bails out if the validation does not pass. If validation does not pass the errors can be found in <code>ret.errors</code>. <code>ret.errors</code> holds a key-value mapping where each key is the field name whose validation failed, and the value of the key is the result from the validation error (much like <code>form.errors</code>). If it passes, the id of the new record is in <code>ret.id</code>. Mind that normally validation is done by the form processing logic so this function is rarely needed.</p><p>Similarly</p><pre><code class="code">ret = db(query).validate_and_update(field='value')</code></pre><p>works very much the same as</p><pre><code class="code">num = db(query).update(field='value')</code></pre><p>except that it calls the validators for the fields before performing the update. Notice that it only works if query involves a single table. The number of updated records can be found in <code>res.updated</code> and errors will be <code>ret.errors</code>.</p><h4><code>smart_query</code> (experimental)</h4><p>There are times when you need to parse a query using natural language such as</p><pre><code>name contain m and age greater than 18</code></pre><p>The DAL provides a method to parse this type of queries:</p><pre><code>search = 'name contain m and age greater than 18'
rows = db.smart_query([db.person],search).select()</code></pre><p>The first argument must be a list of tables or fields that should be allowed in the search. It raises a <code>RuntimeError</code> if the search string is invalid. This functionality can be used to build RESTful interfaces (see chapter 10) and it is used internally by the <code>SQLFORM.grid</code> and <code>SQLFORM.smartgrid</code>.</p><p>In the smartquery search string, a field can be identified by fieldname only and or by tablename.fieldname. Strings may be delimited by double quotes if they contain spaces.</p><h3>Computed fields</h3><div class="inxx">compute</div><p>DAL fields may have a <code>compute</code> attribute. This must be a function (or lambda) that takes a Row object and returns a value for the field. When a new record is modified, including both insertions and updates, if a value for the field is not provided, web2py tries to compute from the other field values using the <code>compute</code> function. Here is an example:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),
        Field('total_price',
            compute=lambda r: r['unit_price']*r['quantity']))
&gt;&gt;&gt; r = db.item.insert(unit_price=1.99, quantity=5)
&gt;&gt;&gt; print r.total_price
9.95</code></pre><p>Notice that the computed value is stored in the db and it is not computed on retrieval, as in the case of virtual fields, described later. Two typical applications of computed fields are:</p><ul><li>in wiki applications, to store the processed input wiki text as HTML, to avoid re-processing on every request</li><li>for searching, to compute normalized values for a field, to be used for searching.</li></ul><p>Computed fields are evaluated in the order in which they are defined in the table definition. A computed field can refer to previously defined computed fields (new after v 2.5.1)</p><h3>Virtual fields</h3><div class="inxx">virtual fields</div><p>Virtual fields are also computed fields (as in the previous subsection) but they differ from those because they are <em>virtual</em> in the sense that they are not stored in the db and they are computed each time records are extracted from the database. They can be used to simplify the user's code without using additional storage but they cannot be used for searching.</p><h4>New style virtual fields</h4><p>web2py provides a new and easier way to define virtual fields and lazy virtual fields. This section is marked experimental because they APIs may still change a little from what is described here.</p><p>Here we will consider the same example as in the previous subsection. In particular we consider the following model:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),</code></pre><p>One can define a <code>total_price</code> virtual field as</p><pre><code class="code">&gt;&gt;&gt; db.item.total_price = Field.Virtual(
    'total_price',
    lambda row: row.item.unit_price*row.item.quantity)</code></pre><p>i.e. by simply defining a new field <code>total_price</code> to be a <code>Field.Virtual</code>. The only argument of the constructor is a function that takes a row and returns the computed values.</p><p>A virtual field defined as the one above is automatically computed for all records when the records are selected:</p><pre><code>&gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</code></pre><p>It is also possible to define method fields which are calculated on-demand, when called. For example:</p><pre><code class="code">&gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0:        row.item.unit_price*row.item.quantity*(1.0-discount/100))</code></pre><p>In this case <code>row.discounted_total</code> is not a value but a function. The function takes the same arguments as the function passed to the <code>Method</code> constructor except for <code>row</code> which is implicit (think of it as <code>self</code> for rows objects).</p><p>The lazy field in the example above allows one to compute the total price for each <code>item</code>:</p><pre><code>&gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total()</code></pre><p>And it also allows to pass an optional <code>discount</code> percentage (15%):</p><pre><code>&gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total(15)</code></pre><p>Virtual and Method fields can also be defined in place when a table is defined:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),
        Field.Virtual('total_price', lambda row: ...),
        Field.Method('discounted_total', lambda row, discount=0.0: ...))</code></pre><blockquote>Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc).  In older versions of web2py they do not appear in the list of <code>db.table.fields</code> and they require a special approach to display in SQLFORM.grid and SQLFORM.smartgrid. See the discussion on grids and virtual fields in the Forms chapter.</blockquote><h4>Old style virtual fields</h4><p>In order to define one or more virtual fields, you can also define a container class, instantiate it and link it to a table or to a select. For example, consider the following table:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),</code></pre><p>One can define a <code>total_price</code> virtual field as</p><pre><code class="code">&gt;&gt;&gt; class MyVirtualFields(object):
        def total_price(self):
            return self.item.unit_price*self.item.quantity
&gt;&gt;&gt; db.item.virtualfields.append(MyVirtualFields())</code></pre><p>Notice that each method of the class that takes a single argument (self) is a new virtual field. <code>self</code> refers to each one row of the select. Field values are referred by full path as in <code>self.item.unit_price</code>. The table is linked to the virtual fields by appending an instance of the class to the table's <code>virtualfields</code> attribute.</p><p>Virtual fields can also access recursive fields as in</p><pre><code class="code">&gt;&gt;&gt; db.define_table('item',
        Field('unit_price','double'))
&gt;&gt;&gt; db.define_table('order_item',
        Field('item','reference item'),
        Field('quantity','integer'))
&gt;&gt;&gt; class MyVirtualFields(object):
        def total_price(self):
            return self.order_item.item.unit_price                 * self.order_item.quantity
&gt;&gt;&gt; db.order_item.virtualfields.append(MyVirtualFields())</code></pre><p>Notice the recursive field access <code>self.order_item.item.unit_price</code> where <code>self</code> is the looping record.</p><p>They can also act on the result of a JOIN</p><pre><code class="code">&gt;&gt;&gt; db.define_table('item',
        Field('unit_price','double'))
&gt;&gt;&gt; db.define_table('order_item',
        Field('item','reference item'),
        Field('quantity','integer'))
&gt;&gt;&gt; rows = db(db.order_item.item==db.item.id).select()
&gt;&gt;&gt; class MyVirtualFields(object):
        def total_price(self):
            return self.item.unit_price                 * self.order_item.quantity
&gt;&gt;&gt; rows.setvirtualfields(order_item=MyVirtualFields())
&gt;&gt;&gt; for row in rows: print row.order_item.total_price</code></pre><p>Notice how in this case the syntax is different. The virtual field accesses both <code>self.item.unit_price</code> and <code>self.order_item.quantity</code> which belong to the join select. The virtual field is attached to the rows of the table using the <code>setvirtualfields</code> method of the rows object. This method takes an arbitrary number of named arguments and can be used to set multiple virtual fields, defined in multiple classes, and attach them to multiple tables:</p><pre><code class="code">&gt;&gt;&gt; class MyVirtualFields1(object):
        def discounted_unit_price(self):
            return self.item.unit_price*0.90
&gt;&gt;&gt; class MyVirtualFields2(object):
        def total_price(self):
            return self.item.unit_price                 * self.order_item.quantity
        def discounted_total_price(self):
            return self.item.discounted_unit_price                 * self.order_item.quantity
&gt;&gt;&gt; rows.setvirtualfields(
        item=MyVirtualFields1(),
        order_item=MyVirtualFields2())
&gt;&gt;&gt; for row in rows:
        print row.order_item.discounted_total_price</code></pre><p>Virtual fields can be <em>lazy</em>; all they need to do is return a function and access it by calling the function:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),
&gt;&gt;&gt; class MyVirtualFields(object):
        def lazy_total_price(self):
            def lazy(self=self):
                return self.item.unit_price                     * self.item.quantity
            return lazy
&gt;&gt;&gt; db.item.virtualfields.append(MyVirtualFields())
&gt;&gt;&gt; for item in db(db.item).select():
        print item.lazy_total_price()</code></pre><p>or shorter using a lambda function:</p><pre><code class="code">&gt;&gt;&gt; class MyVirtualFields(object):
        def lazy_total_price(self):
            return lambda self=self: self.item.unit_price                 * self.item.quantity</code></pre><h3>One to many relation</h3><div class="inxx">one to many</div><p>To illustrate how to implement one to many relations with the web2py DAL, define another table "thing" that refers to the table "person" which we redefine here:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person',
                    Field('name'),
                    format='%(name)s')
&gt;&gt;&gt; db.define_table('thing',
                    Field('name'),
                    Field('owner_id', 'reference person'),
                    format='%(name)s')</code></pre><p>Table "thing" has two fields, the name of the thing and the owner of the thing. The "owner_id" field id a reference field. A reference type can be specified in two equivalent ways:</p><pre><code class="code">Field('owner_id', 'reference person')
Field('owner_id', db.person)</code></pre><p>The latter is always converted to the former. They are equivalent except in the case of lazy tables, self references or other types of cyclic references where the former notation is the only allowed notation.</p><p>When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</p><pre><code class="code">&gt;&gt;&gt; print db.thing.owner_id.type
reference person</code></pre><p>Now, insert three things, two owned by Alex and one by Bob:</p><pre><code class="code">&gt;&gt;&gt; db.thing.insert(name='Boat', owner_id=1)
1
&gt;&gt;&gt; db.thing.insert(name='Chair', owner_id=1)
2
&gt;&gt;&gt; db.thing.insert(name='Shoes', owner_id=2)
3</code></pre><p>You can select as you did for any other table:</p><pre><code class="code">&gt;&gt;&gt; for row in db(db.thing.owner_id==1).select():
        print row.name
Boat
Chair</code></pre><p>Because a thing has a reference to a person, a person can have many things, so a record of table person now acquires a new attribute thing, which is a Set, that defines the things of that person. This allows looping over all persons and fetching their things easily:</p><div class="inxx">referencing</div><pre><code class="code">&gt;&gt;&gt; for person in db().select(db.person.ALL):
        print person.name
        for thing in person.thing.select():
            print '    ', thing.name
Alex
     Boat
     Chair
Bob
     Shoes
Carl</code></pre><h4>Inner joins</h4><p>Another way to achieve a similar result is by using a join, specifically an INNER JOIN. web2py performs joins automatically and transparently when the query links two or more tables as in the following example:</p><p><div class="inxx">Rows</div> <div class="inxx">inner join</div> <div class="inxx">join</div></p><pre><code class="code">&gt;&gt;&gt; rows = db(db.person.id==db.thing.owner_id).select()
&gt;&gt;&gt; for row in rows:
        print row.person.name, 'has', row.thing.name
Alex has Boat
Alex has Chair
Bob has Shoes</code></pre><p>Observe that web2py did a join, so the rows now contain two records, one from each table, linked together. Because the two records may have fields with conflicting names, you need to specify the table when extracting a field value from a row. This means that while before you could do:</p><pre><code class="code">row.name</code></pre><p>and it was obvious whether this was the name of a person or a thing, in the result of a join you have to be more explicit and say:</p><pre><code class="code">row.person.name</code></pre><p>or:</p><pre><code class="code">row.thing.name</code></pre><p>There is an alternative syntax for INNER JOINS:</p><pre><code class="code">&gt;&gt;&gt; rows = db(db.person).select(join=db.thing.on(db.person.id==db.thing.owner_id))
&gt;&gt;&gt; for row in rows:
    print row.person.name, 'has', row.thing.name
Alex has Boat
Alex has Chair
Bob has Shoes</code></pre><p>While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</p><pre><code>&gt;&gt;&gt; db.define_table('thing',
        Field('name'),
        Field('owner_id1','reference person'),
        Field('owner_id2','reference person'))
&gt;&gt;&gt; rows = db(db.person).select(
    join=[db.person.with_alias('owner_id1').on(db.person.id==db.thing.owner_id1).
          db.person.with_alias('owner_id2').on(db.person.id==db.thing.owner_id2)])</code></pre><p>The value of <code>join</code> can be list of <code>db.table.on(...)</code> to join.</p><h4>Left outer join</h4><p>Notice that Carl did not appear in the list above because he has no things. If you intend to select on persons (whether they have things or not) and their things (if they have any), then you need to perform a LEFT OUTER JOIN. This is done using the argument "left" of the select command. Here is an example:</p><p><div class="inxx">Rows</div> <div class="inxx">left outer join</div> <div class="inxx">outer join</div></p><pre><code class="code">&gt;&gt;&gt; rows=db().select(
        db.person.ALL, db.thing.ALL,
        left=db.thing.on(db.person.id==db.thing.owner_id))
&gt;&gt;&gt; for row in rows:
        print row.person.name, 'has', row.thing.name
Alex has Boat
Alex has Chair
Bob has Shoes
Carl has None</code></pre><p>where:</p><pre><code class="code">left = db.thing.on(...)</code></pre><p>does the left join query. Here the argument of <code>db.thing.on</code> is the condition required for the join (the same used above for the inner join). In the case of a left join, it is necessary to be explicit about which fields to select.</p><p>Multiple left joins can be combined by passing a list or tuple of <code>db.mytable.on(...)</code> to the  <code>left</code> attribute.</p><h4>Grouping and counting</h4><p>When doing joins, sometimes you want to group rows according to certain criteria and count them. For example, count the number of things owned by every person. web2py allows this as well. First, you need a count operator. Second, you want to join the person table with the thing table by owner. Third, you want to select all rows (person + thing), group them by person, and count them while grouping:</p><div class="inxx">grouping</div><pre><code class="code">&gt;&gt;&gt; count = db.person.id.count()
&gt;&gt;&gt; for row in db(db.person.id==db.thing.owner_id).select(
        db.person.name, count, groupby=db.person.name):
        print row.person.name, row[count]
Alex 2
Bob 1</code></pre><p>Notice the <code>count</code> operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself. The count method of the Field object has an optional <code>distinct</code> argument. When set to <code>True</code> it specifies that only distinct values of the field in question are to be counted.</p><h3>Many to many</h3><div class="inxx">many-to-many</div><p>In the previous examples, we allowed a thing to have one owner but one person could have many things. What if Boat was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a thing via an ownership relation.</p><p>Here is how to do it:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person',
                    Field('name'))
&gt;&gt;&gt; db.define_table('thing',
                    Field('name'))
&gt;&gt;&gt; db.define_table('ownership',
                    Field('person', 'reference person'),
                    Field('thing', 'reference thing'))</code></pre><p>the existing ownership relationship can now be rewritten as:</p><pre><code class="code">&gt;&gt;&gt; db.ownership.insert(person=1, thing=1) # Alex owns Boat
&gt;&gt;&gt; db.ownership.insert(person=1, thing=2) # Alex owns Chair
&gt;&gt;&gt; db.ownership.insert(person=2, thing=3) # Bob owns Shoes
</code></pre><p>Now you can add the new relation that Curt co-owns Boat:</p><pre><code class="code">&gt;&gt;&gt; db.ownership.insert(person=3, thing=1) # Curt owns Boat too
</code></pre><p>Because you now have a three-way relation between tables, it may be convenient to define a new set on which to perform operations:</p><pre><code class="code">&gt;&gt;&gt; persons_and_things = db(
        (db.person.id==db.ownership.person)         &amp; (db.thing.id==db.ownership.thing))</code></pre><p>Now it is easy to select all persons and their things from the new Set:</p><pre><code class="code">&gt;&gt;&gt; for row in persons_and_things.select():
        print row.person.name, row.thing.name
Alex Boat
Alex Chair
Bob Shoes
Curt Boat</code></pre><p>Similarly, you can search for all things owned by Alex:</p><pre><code class="code">&gt;&gt;&gt; for row in persons_and_things(db.person.name=='Alex').select():
        print row.thing.name
Boat
Chair</code></pre><p>and all owners of Boat:</p><pre><code class="code">&gt;&gt;&gt; for row in persons_and_things(db.thing.name=='Boat').select():
        print row.person.name
Alex
Curt</code></pre><p>A lighter alternative to Many 2 Many relations is tagging. Tagging is discussed in the context of the <code>IS_IN_DB</code> validator. Tagging works even on database backends that do not support JOINs like the Google App Engine NoSQL.</p><h3><code>list:&lt;type&gt;</code> and <code>contains</code></h3><div class="inxx">list:string</div><div class="inxx">list:integer</div><div class="inxx">list:reference</div><div class="inxx">contains</div><div class="inxx">multiple</div><div class="inxx">tags</div><p>web2py provides the following special field types:</p><pre><code class="code">list:string
list:integer
list:reference &lt;table&gt;</code></pre><p>They can contain lists of strings, of integers and of references respectively.</p><p>On Google App Engine NoSQL <code>list:string</code> is mapped into <code>StringListProperty</code>, the other two are mapped into <code>ListProperty(int)</code>. On relational databases they are mapped into text fields which contain the list of items separated by <code>|</code>. For example <code>[1,2,3]</code> is mapped into <code>|1|2|3|</code>.</p><p>For lists of string the items are escaped so that any <code>|</code> in the item is replaced by a <code>||</code>. Anyway this is an internal representation and it is transparent to the user.</p><p>You can use <code>list:string</code>, for example, in the following way:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('product',
        Field('name'),
        Field('colors','list:string'))
&gt;&gt;&gt; db.product.colors.requires=IS_IN_SET(('red','blue','green'))
&gt;&gt;&gt; db.product.insert(name='Toy Car',colors=['red','green'])
&gt;&gt;&gt; products = db(db.product.colors.contains('red')).select()
&gt;&gt;&gt; for item in products:
        print item.name, item.colors
Toy Car ['red', 'green']</code></pre><p><code>list:integer</code> works in the same way but the items must be integers.</p><p>As usual the requirements are enforced at the level of forms, not at the level of <code>insert</code>.</p><blockquote>For <code>list:&lt;type&gt;</code> fields the <code>contains(value)</code> operator maps into a non trivial query that checks for lists containing the <code>value</code>.  The <code>contains</code> operator also works for regular <code>string</code> and <code>text</code> fields and it maps into a <code>LIKE '%value%'</code>.</blockquote><p>The <code>list:reference</code> and the <code>contains(value)</code> operator are particularly useful to de-normalize many-to-many relations. Here is an example:</p><pre><code class="code">&gt;&gt;&gt; db.define_table('tag',Field('name'),format='%(name)s')
&gt;&gt;&gt; db.define_table('product',
        Field('name'),
        Field('tags','list:reference tag'))
&gt;&gt;&gt; a = db.tag.insert(name='red')
&gt;&gt;&gt; b = db.tag.insert(name='green')
&gt;&gt;&gt; c = db.tag.insert(name='blue')
&gt;&gt;&gt; db.product.insert(name='Toy Car',tags=[a, b, c])
&gt;&gt;&gt; products = db(db.product.tags.contains(b)).select()
&gt;&gt;&gt; for item in products:
        print item.name, item.tags
Toy Car [1, 2, 3]
&gt;&gt;&gt; for item in products:
        print item.name, db.product.tags.represent(item.tags)
Toy Car red, green, blue</code></pre><p>Notice that a <code>list:reference tag</code> field get a default constraint</p><pre><code class="code">requires = IS_IN_DB(db,'tag.id',db.tag._format,multiple=True)</code></pre><p>that produces a <code>SELECT/OPTION</code> multiple drop-box in forms.</p><p>Also notice that this field gets a default <code>represent</code> attribute which represents the list of references as a comma-separated list of formatted references. This is used in read forms and <code>SQLTABLE</code>s.</p><blockquote>While <code>list:reference</code> has a default validator and a default representation, <code>list:integer</code> and <code>list:string</code> do not. So these two need an <code>IS_IN_SET</code> or an <code>IS_IN_DB</code> validator if you want to use them in forms.</blockquote><h3>Other operators</h3><p>web2py has other operators that provide an API to access equivalent SQL operators. Let's define another table "log" to store security events, their event_time and severity, where the severity is an integer number.</p><p><div class="inxx">date</div> <div class="inxx">datetime</div> <div class="inxx">time</div></p><pre><code class="code">&gt;&gt;&gt; db.define_table('log', Field('event'),
                           Field('event_time', 'datetime'),
                           Field('severity', 'integer'))</code></pre><p>As before, insert a few events, a "port scan", an "xss injection" and an "unauthorized login". For the sake of the example, you can log events with the same event_time but with different severities (1, 2, and 3 respectively).</p><pre><code class="code">&gt;&gt;&gt; import datetime
&gt;&gt;&gt; now = datetime.datetime.now()
&gt;&gt;&gt; print db.log.insert(
        event='port scan', event_time=now, severity=1)
1
&gt;&gt;&gt; print db.log.insert(
        event='xss injection', event_time=now, severity=2)
2
&gt;&gt;&gt; print db.log.insert(
        event='unauthorized login', event_time=now, severity=3)
3</code></pre><h4><code>like</code>, <code>ilike</code>, <code>regexp</code>, <code>startswith</code>, <code>endswith</code>, <code>contains</code>, <code>upper</code>, <code>lower</code></h4><p><div class="inxx">like</div> <div class="inxx">ilike</div> <div class="inxx">startswith</div> <div class="inxx">endswith</div> <div class="inxx">regexp</div> <div class="inxx">contains</div> <div class="inxx">upper</div> <div class="inxx">lower</div></p><p>Fields have a like operator that you can use to match strings:</p><pre><code class="code">&gt;&gt;&gt; for row in db(db.log.event.like('port%')).select():
        print row.event
port scan</code></pre><p>Here "port%" indicates a string starting with "port". The percent sign character, "%", is a wild-card character that means "any sequence of characters".</p><p>The like operator maps to the LIKE word in ANSI-SQL. LIKE is case-sensitive in most databases, and depends on the collation of the database itself. The <code>like</code> method is hence case-sensitive but it can be made case-insensitive with</p><pre><code class="code">db.mytable.myfield.like('value',case_sensitive=False)</code></pre><p>web2py also provides some shortcuts:</p><pre><code class="code">db.mytable.myfield.startswith('value')
db.mytable.myfield.endswith('value')
db.mytable.myfield.contains('value')</code></pre><p>which are roughly equivalent respectively to</p><pre><code class="code">db.mytable.myfield.like('value%')
db.mytable.myfield.like('%value')
db.mytable.myfield.like('%value%')</code></pre><p>Notice that <code>contains</code> has a special meaning for <code>list:&lt;type&gt;</code> fields and it was discussed in a previous section.</p><p>The <code>contains</code> method can also be passed a list of values and an optional boolean argument <code>all</code> to search for records that contain all values:</p><pre><code>db.mytable.myfield.contains(['value1','value2'], all=True)</code></pre><p>or any value from the list</p><pre><code>db.mytable.myfield.contains(['value1','value2'], all=False)</code></pre><p>There is a also a <code>regexp</code> method that works like the <code>like</code> method but allows regular expression syntax for the look-up expression. It is only supported by PostgreSQL, MySQL, Oracle and SQLite (with different degree of support).</p><p>The <code>upper</code> and <code>lower</code> methods allow you to convert the value of the field to upper or lower case, and you can also combine them with the like operator:</p><p><div class="inxx">upper</div> <div class="inxx">lower</div></p><pre><code class="code">&gt;&gt;&gt; for row in db(db.log.event.upper().like('PORT%')).select():
        print row.event
port scan</code></pre><h4><code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minutes</code>, <code>seconds</code></h4><p><div class="inxx">hour</div> <div class="inxx">minutes</div> <div class="inxx">seconds</div> <div class="inxx">day</div> <div class="inxx">month</div> <div class="inxx">year</div></p><p>The date and datetime fields have day, month and year methods. The datetime and time fields have hour, minutes and seconds methods. Here is an example:</p><pre><code class="code">&gt;&gt;&gt; for row in db(db.log.event_time.year()==2013).select():
        print row.event
port scan
xss injection
unauthorized login</code></pre><h4><code>belongs</code></h4><p>The SQL IN operator is realized via the belongs method which returns true when the field value belongs to the specified set (list or tuples):</p><div class="inxx">belongs</div><pre><code class="code">&gt;&gt;&gt; for row in db(db.log.severity.belongs((1, 2))).select():
        print row.event
port scan
xss injection</code></pre><p>The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a <code>_select</code>, not a <code>select</code>, and only one field has to be selected explicitly, the one that defines the set.</p><div class="inxx">nested select</div><pre><code class="code">&gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)
&gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():
        print row.event
port scan
xss injection
unauthorized login</code></pre><p>In those cases where a nested select is required and the look-up field is a reference we can also use a query as argument. For example:</p><pre><code class="code">db.define_table('person', Field('name'))
db.define_table('thing', Field('name'), Field('owner_id', 'reference thing'))
db(db.thing.owner_id.belongs(db.person.name=='Jonathan')).select()</code></pre><p>In this case it is obvious that the next select only needs the field referenced by the <code>db.thing.owner_id</code> field so we do not need the more verbose <code>_select</code> notation.</p><div class="inxx">nested_select</div><p>A nested select can also be used as insert/update value but in this case the syntax is different:</p><pre><code class="code">lazy = db(db.person.name=='Jonathan').nested_select(db.person.id)
db(db.thing.id==1).update(owner_id = lazy)</code></pre><p>In this case <code>lazy</code> is a nested expression that computes the <code>id</code> of person "Jonathan". The two lines result in one single SQL query.</p><h4><code>sum</code>, <code>avg</code>, <code>min</code>, <code>max</code> and <code>len</code></h4><p><div class="inxx">sum</div> <div class="inxx">avg</div> <div class="inxx">min</div> <div class="inxx">max</div> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</p><pre><code class="code">&gt;&gt;&gt; sum = db.log.severity.sum()
&gt;&gt;&gt; print db().select(sum).first()[sum]
6</code></pre><p>You can also use <code>avg</code>, <code>min</code>, and <code>max</code> to the average, minimum, and maximum value respectively for the selected records. For example:</p><pre><code class="code">&gt;&gt;&gt; max = db.log.severity.max()
&gt;&gt;&gt; print db().select(max).first()[max]
3</code></pre><p><code>.len()</code> computes the length of a string, text or boolean fields.</p><p>Expressions can be combined to form more complex expressions. For example here we are computing the sum of the length of all the severity strings in the logs, increased of one:</p><pre><code class="code">&gt;&gt;&gt; sum = (db.log.severity.len()+1).sum()
&gt;&gt;&gt; print db().select(sum).first()[sum]</code></pre><h4>Substrings</h4><p>One can build an expression to refer to a substring. For example, we can group things whose name starts with the same three characters and select only one from each group:</p><pre><code class="code">db(db.thing).select(distinct = db.thing.name[:3])</code></pre><h4>Default values with <code>coalesce</code> and <code>coalesce_zero</code></h4><p>There are times when you need to pull a value from database but also need a default values if the value for a record is set to NULL. In SQL there is a keyword, <code>COALESCE</code>, for this. web2py has an equivalent <code>coalesce</code> method:</p><pre><code>&gt;&gt;&gt; db.define_table('sysuser',Field('username'),Field('fullname'))
&gt;&gt;&gt; db.sysuser.insert(username='max',fullname='Max Power')
&gt;&gt;&gt; db.sysuser.insert(username='tim',fullname=None)
print db(db.sysuser).select(db.sysuser.fullname.coalesce(db.sysuser.username))
"COALESCE(sysuser.fullname,sysuser.username)"
Max Power
tim</code></pre><p>Other times you need to compute a mathematical expression but some fields have a value set to None while it should be zero. <code>coalesce_zero</code> comes to the rescue by defaulting None to zero in the query:</p><pre><code>&gt;&gt;&gt; db.define_table('sysuser',Field('username'),Field('points'))
&gt;&gt;&gt; db.sysuser.insert(username='max',points=10)
&gt;&gt;&gt; db.sysuser.insert(username='tim',points=None)
&gt;&gt;&gt; print db(db.sysuser).select(db.sysuser.points.coalesce_zero().sum())
"SUM(COALESCE(sysuser.points,0))"
10</code></pre><h3>Generating raw sql</h3><div class="inxx">raw SQL</div><p>Sometimes you need to generate the SQL but not execute it. This is easy to do with web2py since every command that performs database IO has an equivalent command that does not, and simply returns the SQL that would have been executed. These commands have the same names and syntax as the functional ones, but they start with an underscore:</p><p>Here is <code>_insert</code> <div class="inxx">_insert</div></p><pre><code class="code">&gt;&gt;&gt; print db.person._insert(name='Alex')
INSERT INTO person(name) VALUES ('Alex');</code></pre><p>Here is <code>_count</code> <div class="inxx">_count</div></p><pre><code class="code">&gt;&gt;&gt; print db(db.person.name=='Alex')._count()
SELECT count(*) FROM person WHERE person.name='Alex';</code></pre><p>Here is <code>_select</code> <div class="inxx">_select</div></p><pre><code class="code">&gt;&gt;&gt; print db(db.person.name=='Alex')._select()
SELECT person.id, person.name FROM person WHERE person.name='Alex';</code></pre><p>Here is <code>_delete</code> <div class="inxx">_delete</div></p><pre><code class="code">&gt;&gt;&gt; print db(db.person.name=='Alex')._delete()
DELETE FROM person WHERE person.name='Alex';</code></pre><p>And finally, here is <code>_update</code> <div class="inxx">_update</div></p><pre><code class="code">&gt;&gt;&gt; print db(db.person.name=='Alex')._update()
UPDATE person SET  WHERE person.name='Alex';</code></pre><blockquote>Moreover you can always use <code>db._lastsql</code> to return the most recent
SQL code, whether it was executed manually using executesql or was SQL
generated by the DAL.</blockquote><h3>Exporting and importing data</h3><p><div class="inxx">export</div> <div class="inxx">import</div></p><h4>CSV (one Table at a time)</h4><p>When a Rows object is converted to a string it is automatically serialized in CSV:</p><div class="inxx">csv</div><pre><code class="code">&gt;&gt;&gt; rows = db(db.person.id==db.thing.owner_id).select()
&gt;&gt;&gt; print rows
person.id,person.name,thing.id,thing.name,thing.owner_id
1,Alex,1,Boat,1
1,Alex,2,Chair,1
2,Bob,3,Shoes,2</code></pre><p>You can serialize a single table in CSV and store it in a file "test.csv":</p><pre><code class="code">&gt;&gt;&gt; open('test.csv', 'wb').write(str(db(db.person.id).select()))</code></pre><p>This is equivalent to</p><pre><code class="code">&gt;&gt;&gt; rows = db(db.person.id).select()
&gt;&gt;&gt; rows.export_to_csv_file(open('test.csv', 'wb'))</code></pre><p>You can read the CSV file back with:</p><pre><code class="code">&gt;&gt;&gt; db.person.import_from_csv_file(open('test.csv', 'r'))</code></pre><p>When importing, web2py looks for the field names in the CSV header. In this example, it finds two columns: "person.id" and "person.name". It ignores the "person." prefix, and it ignores the "id" fields. Then all records are appended and assigned new ids. Both of these operations can be performed via the appadmin web interface.</p><h4>CSV (all tables at once)</h4><p>In web2py, you can backup/restore an entire database with two commands:</p><p>To export:</p><pre><code class="code">&gt;&gt;&gt; db.export_to_csv_file(open('somefile.csv', 'wb'))</code></pre><p>To import:</p><pre><code class="code">&gt;&gt;&gt; db.import_from_csv_file(open('somefile.csv', 'rb'))</code></pre><p>This mechanism can be used even if the importing database is of a different type than the exporting database. The data is stored in "somefile.csv" as a CSV file where each table starts with one line that indicates the tablename, and another line with the fieldnames:</p><pre><code class="code">TABLE tablename
field1, field2, field3, ...</code></pre><p>Two tables are separated <code>\r\n\r\n</code>. The file ends with the line</p><pre><code class="code">END</code></pre><p>The file does not include uploaded files if these are not stored in the database. In any case it is easy enough to zip the "uploads" folder separately.</p><p>When importing, the new records will be appended to the database if it is not empty. In general the new imported records will not have the same record id as the original (saved) records but web2py will restore references so they are not broken, even if the id values may change.</p><p>If a table contains a field called "uuid", this field will be used to identify duplicates.  Also, if an imported record has the same "uuid" as an existing record, the previous record will be updated.</p><h4>CSV and remote database synchronization</h4><p>Consider the following model:</p><pre><code class="code">db = DAL('sqlite:memory:')
db.define_table('person',
    Field('name'),
    format='%(name)s')
db.define_table('thing',
    Field('owner_id', 'reference person'),
    Field('name'),
    format='%(name)s')

if not db(db.person).count():
    id = db.person.insert(name="Massimo")
    db.thing.insert(owner_id=id, name="Chair")</code></pre><p>Each record is identified by an ID and referenced by that ID. If you have two copies of the database used by distinct web2py installations, the ID is unique only within each database and not across the databases. This is a problem when merging records from different databases.</p><p>In order to make a record uniquely identifiable across databases, they must:</p><ul><li>have a unique id (UUID),</li><li>have an event_time (to figure out which one is more recent if multiple copies),</li><li>reference the UUID instead of the id.</li></ul><p>This can be achieved without modifying web2py. Here is what to do:</p><p>Change the above model into:</p><pre><code class="code">db.define_table('person',
    Field('uuid', length=64, default=lambda:str(uuid.uuid4())),
    Field('modified_on', 'datetime', default=request.now),
    Field('name'),
    format='%(name)s')

db.define_table('thing',
    Field('uuid', length=64, default=lambda:str(uuid.uuid4())),
    Field('modified_on', 'datetime', default=request.now),
    Field('owner_id', length=64),
    Field('name'),
    format='%(name)s')

db.thing.owner_id.requires = IS_IN_DB(db,'person.uuid','%(name)s')

if not db(db.person.id).count():
    id = uuid.uuid4()
    db.person.insert(name="Massimo", uuid=id)
    db.thing.insert(owner_id=id, name="Chair")</code></pre><blockquote>Notice that in the above table definitions, the default value for the two <code>uuid</code> fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</blockquote><p>Create a controller action to export the database:</p><pre><code class="code">def export():
    s = StringIO.StringIO()
    db.export_to_csv_file(s)
    response.headers['Content-Type'] = 'text/csv'
    return s.getvalue()</code></pre><p>Create a controller action to import a saved copy of the other database and sync records:</p><pre><code class="code">def import_and_sync():
    form = FORM(INPUT(_type='file', _name='data'), INPUT(_type='submit'))
    if form.process().accepted:
        db.import_from_csv_file(form.vars.data.file,unique=False)
        # for every table
        for table in db.tables:
            # for every uuid, delete all but the latest
            items = db(db[table]).select(db[table].id,
                       db[table].uuid,
                       orderby=db[table].modified_on,
                       groupby=db[table].uuid)
            for item in items:
                db((db[table].uuid==item.uuid)&amp;                   (db[table].id!=item.id)).delete()
    return dict(form=form)</code></pre><p>Optionally you should create an index manually to make the search by uuid faster.</p><div class="inxx">XML-RPC</div><p>Alternatively, you can use XML-RPC to export/import the file.</p><p>If the records reference uploaded files, you also need to export/import the content of the uploads folder. Notice that files therein are already labeled by UUIDs so you do not need to worry about naming conflicts and references.</p><h4>HTML and XML (one Table at a time)</h4><div class="inxx">Rows objects</div><p>Rows objects also have an <code>xml</code> method (like helpers) that serializes it to XML/HTML:</p><div class="inxx">HTML</div><pre><code class="code">&gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()
&gt;&gt;&gt; print rows.xml()
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;person.id&lt;/th&gt;
      &lt;th&gt;person.name&lt;/th&gt;
      &lt;th&gt;thing.id&lt;/th&gt;
      &lt;th&gt;thing.name&lt;/th&gt;
      &lt;th&gt;thing.owner_id&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr class="even"&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Alex&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Boat&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    ...
  &lt;/tbody&gt;
&lt;/table&gt;</code></pre><div class="inxx">Rows custom tags</div><p>If you need to serialize the Rows in any other XML format with custom tags, you can easily do that using the universal TAG helper and the * notation:</p><div class="inxx">XML</div><pre><code class="code">&gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()
&gt;&gt;&gt; print TAG.result(*[TAG.row(*[TAG.field(r[f], _name=f)           for f in db.person.fields]) for r in rows])
&lt;result&gt;
  &lt;row&gt;
    &lt;field name="id"&gt;1&lt;/field&gt;
    &lt;field name="name"&gt;Alex&lt;/field&gt;
  &lt;/row&gt;
  ...
&lt;/result&gt;</code></pre><h4>Data representation</h4><div class="inxx">export_to_csv_file</div><p>The <code>export_to_csv_file</code> function accepts a keyword argument named <code>represent</code>. When <code>True</code> it will use the columns <code>represent</code> function while exporting the data instead of the raw data.</p><div class="inxx">colnames</div><p>The function also accepts a keyword argument named <code>colnames</code> that should contain a list of column names one wish to export. It defaults to all columns.</p><p>Both <code>export_to_csv_file</code> and <code>import_from_csv_file</code> accept keyword arguments that tell the csv parser the format to save/load the files:</p><ul><li><code>delimiter</code>: delimiter to separate values (default ',')</li><li><code>quotechar</code>: character to use to quote string values (default to double quotes)</li><li><code>quoting</code>: quote system (default <code>csv.QUOTE_MINIMAL</code>)</li></ul><p>Here is some example usage:</p><pre><code class="code">&gt;&gt;&gt; import csv
&gt;&gt;&gt; rows = db(query).select()
&gt;&gt;&gt; rows.export_to_csv_file(open('/tmp/test.txt', 'w'),
        delimiter='|',
        quotechar='"',
        quoting=csv.QUOTE_NONNUMERIC)</code></pre><p>Which would render something similar to</p><pre><code class="code">"hello"|35|"this is the text description"|"2013-03-03"</code></pre><p>For more information consult the official Python documentation <sup>[<a href="/book/default/reference/29/quoteall" target="_blank">quoteall</a>]</sup></p><h3>Caching selects</h3><p>The select method also takes a cache argument, which defaults to None. For caching purposes, it should be set to a tuple where the first element is the cache model (cache.ram, cache.disk, etc.), and the second element is the expiration time in seconds.</p><p>In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</p><div class="inxx">cache select</div><pre><code class="code">def cache_db_select():
    logs = db().select(db.log.ALL, cache=(cache.ram, 60))
    return dict(logs=logs)</code></pre><div class="inxx">cacheable</div><p>The <code>select</code> method has an optional <code>cacheable</code> argument, normally set to <code>False</code>. When <code>cacheable=True</code> the resulting <code>Rows</code> is serializable but The <code>Row</code>s lack <code>update_record</code> and <code>delete_record</code> methods.</p><p>If you do not need these methods you can speed up selects a lot by setting the cacheable attribute:</p><pre><code class="code">rows = db(query).select(cacheable=True)</code></pre><p>When the <code>cache</code> argument is set but <code>cacheable=False</code> (default) only the database results are cached, not the actual Rows object. When the <code>cache</code> argument is used in conjunction with <code>cacheable=True</code> the entire Rows object is cached and this results in much faster caching:</p><pre><code class="code">rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</code></pre><h3>Self-Reference and aliases</h3><div class="inxx">self reference</div><div class="inxx">alias</div><p>It is possible to define tables with fields that refer to themselves, here is an example:</p><div class="inxx">reference table</div><pre><code class="code">db.define_table('person',
    Field('name'),
    Field('father_id', 'reference person'),
    Field('mother_id', 'reference person'))</code></pre><p>Notice that the alternative notation of using a table object as field type will fail in this case, because it uses a variable <code>db.person</code> before it is defined:</p><pre><code class="code">db.define_table('person',
    Field('name'),
    Field('father_id', db.person), # wrong!
    Field('mother_id', db.person)) # wrong!</code></pre><p>In general <code>db.tablename</code> and <code>"reference tablename"</code> are equivalent field types, but the latter is the only one allowed for self.references.</p><div class="inxx">with_alias</div><p>If the table refers to itself, then it is not possible to perform a JOIN to select a person and its parents without use of the SQL "AS" keyword. This is achieved in web2py using the <code>with_alias</code>. Here is an example:</p><pre><code class="code">&gt;&gt;&gt; Father = db.person.with_alias('father')
&gt;&gt;&gt; Mother = db.person.with_alias('mother')
&gt;&gt;&gt; db.person.insert(name='Massimo')
1
&gt;&gt;&gt; db.person.insert(name='Claudia')
2
&gt;&gt;&gt; db.person.insert(name='Marco', father_id=1, mother_id=2)
3
&gt;&gt;&gt; rows = db().select(db.person.name, Father.name, Mother.name,
      left=(Father.on(Father.id==db.person.father_id),
            Mother.on(Mother.id==db.person.mother_id)))
&gt;&gt;&gt; for row in rows:
        print row.person.name, row.father.name, row.mother.name
Massimo None None
Claudia None None
Marco Massimo Claudia</code></pre><p>Notice that we have chosen to make a distinction between:</p><ul><li>"father_id": the field name used in the table "person";</li><li>"father": the alias we want to use for the table referenced by the above field; this is communicated to the database;</li><li>"Father": the variable used by web2py to refer to that alias.</li></ul><p>The difference is subtle, and there is nothing wrong in using the same name for the three of them:</p><pre><code class="code">db.define_table('person',
    Field('name'),
    Field('father', 'reference person'),
    Field('mother', 'reference person'))
&gt;&gt;&gt; father = db.person.with_alias('father')
&gt;&gt;&gt; mother = db.person.with_alias('mother')
&gt;&gt;&gt; db.person.insert(name='Massimo')
1
&gt;&gt;&gt; db.person.insert(name='Claudia')
2
&gt;&gt;&gt; db.person.insert(name='Marco', father=1, mother=2)
3
&gt;&gt;&gt; rows = db().select(db.person.name, father.name, mother.name,
      left=(father.on(father.id==db.person.father),
            mother.on(mother.id==db.person.mother)))
&gt;&gt;&gt; for row in rows:
        print row.person.name, row.father.name, row.mother.name
Massimo None None
Claudia None None
Marco Massimo Claudia</code></pre><p>But it is important to have the distinction clear in order to build correct queries.</p><h3>Advanced features</h3><h4>Table inheritance</h4><div class="inxx">inheritance</div><p>It is possible to create a table that contains all the fields from another table. It is sufficient to pass the other table in place of a field to <code>define_table</code>. For example</p><pre><code class="code">db.define_table('person', Field('name'))
db.define_table('doctor', db.person, Field('specialization'))</code></pre><div class="inxx">dummy table</div><p>It is also possible to define a dummy table that is not stored in a database in order to reuse it in multiple other places. For example:</p><pre><code class="code">signature = db.Table(db, 'signature',
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', db.auth_user, default=auth.user_id),
    Field('updated_on', 'datetime', update=request.now),
    Field('updated_by', db.auth_user, update=auth.user_id))

db.define_table('payment', Field('amount', 'double'), signature)</code></pre><p>This example assumes that standard web2py authentication is enabled.</p><p>Notice that if you use <code>Auth</code> web2py already creates one such table for you:</p><pre><code>auth = Auth(db)
db.define_table('payment', Field('amount', 'double'), auth.signature)</code></pre><p>When using table inheritance, if you want the inheriting table to inherit validators, be sure to define the validators of the parent table before defining the inheriting table.</p><h4><code>filter_in</code> and <code>filter_out</code></h4><p><div class="inxx">filter_in</div> <div class="inxx">filter_out</div></p><p>It is possible to define a filter for each field to be called before a value is inserted into the database for that field and after a value is retrieved from the database.</p><p>Imagine for example that you want to store a serializable Python data structure in a field in the json format. Here is how it could be accomplished:</p><pre><code class="code">&gt;&gt;&gt; from simplejson import loads, dumps
&gt;&gt;&gt; db.define_table('anyobj',Field('name'),Field('data','text'))
&gt;&gt;&gt; db.anyobj.data.filter_in = lambda obj, dumps=dumps: dumps(obj)
&gt;&gt;&gt; db.anyobj.data.filter_out = lambda txt, loads=loads: loads(txt)
&gt;&gt;&gt; myobj = ['hello', 'world', 1, {2: 3}]
&gt;&gt;&gt; id = db.anyobj.insert(name='myobjname', data=myobj)
&gt;&gt;&gt; row = db.anyobj(id)
&gt;&gt;&gt; row.data
['hello', 'world', 1, {2: 3}]</code></pre><p>Another way to accomplish the same is by using a Field of type <code>SQLCustomType</code>, as discussed later.</p><h4>callbacks on record insert, delete and update</h4><div class="inxx">_before_insert</div><div class="inxx">_after_insert</div><div class="inxx">_before_update</div><div class="inxx">_after_update</div><div class="inxx">_before_delete</div><div class="inxx">_after_delete</div><p>Web2py provides a mechanism to register callbacks to be called before and/or after insert, update and delete of records.</p><p>Each table stores six lists of callbacks:</p><pre><code class="code">db.mytable._before_insert
db.mytable._after_insert
db.mytable._before_update
db.mytable._after_update
db.mytable._before_delete
db.mytable._after_delete</code></pre><p>You can register callback function by appending it the corresponding function to one of those lists. The caveat is that depending on the functionality, the callback has different signature.</p><p>This is best explained via some examples.</p><pre><code class="code">&gt;&gt;&gt; db.define_table('person',Field('name'))
&gt;&gt;&gt; def pprint(*args): print args
&gt;&gt;&gt; db.person._before_insert.append(lambda f: pprint(f))
&gt;&gt;&gt; db.person._after_insert.append(lambda f,id: pprint(f,id))
&gt;&gt;&gt; db.person._before_update.append(lambda s,f: pprint(s,f))
&gt;&gt;&gt; db.person._after_update.append(lambda s,f: pprint(s,f))
&gt;&gt;&gt; db.person._before_delete.append(lambda s: pprint(s))
&gt;&gt;&gt; db.person._after_delete.append(lambda s: pprint(s))</code></pre><p>Here <code>f</code> is a dict of fields passed to insert or update, <code>id</code> is the id of the newly inserted record, <code>s</code> is the Set object used for update or delete.</p><pre><code class="code">&gt;&gt;&gt; db.person.insert(name='John')
({'name': 'John'},)
({'name': 'John'}, 1)
&gt;&gt;&gt; db(db.person.id==1).update(name='Tim')
(&lt;Set (person.id = 1)&gt;, {'name': 'Tim'})
(&lt;Set (person.id = 1)&gt;, {'name': 'Tim'})
&gt;&gt;&gt; db(db.person.id==1).delete()
(&lt;Set (person.id = 1)&gt;,)
(&lt;Set (person.id = 1)&gt;,)</code></pre><p>The return values of these callback should be <code>None</code> or <code>False</code>. If any of the <code>_before_*</code> callback returns a <code>True</code> value it will abort the actual insert/update/delete operation.</p><div class="inxx">update_naive</div><p>Some times a callback may need to perform an update in the same or a different table and one wants to avoid callbacks calling themselves recursively.</p><p>For this purpose there the Set objects have an <code>update_naive</code> method that works like <code>update</code> but ignores before and after callbacks.</p><h5>Database cascades</h5><p>Database schema can define relationships which trigger deletions of related records, known as cascading. The DAL is not informed when a record is deleted due to a cascade. So an <code>on_delete</code> trigger will not be called due a cascade-deletion.</p><p><span class="anchor" id="markmin_versioning"></span></p><h4>Record versioning</h4><div class="inxx">_enable_record_versioning</div><p>It is possible to ask web2py to save every copy of a record when the record is individually modified. There are different ways to do it and it can be done for all tables at once using the syntax:</p><pre><code class="code">auth.enable_record_versioning(db)</code></pre><p>this requires Auth and it is discussed in the chapter about authentication. It can also be done for each individual table as discussed below.</p><p>Consider the following table:</p><pre><code class="code">db.define_table('stored_item',
    Field('name'),
    Field('quantity','integer'),
    Field('is_active','boolean',
          writable=False,readable=False,default=True))</code></pre><p>Notice the hidden boolean field called <code>is_active</code> and defaulting to True.</p><p>We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.</p><p>This is done in the following way:</p><pre><code class="code">db.stored_item._enable_record_versioning()</code></pre><p>or in a more verbose syntax:</p><pre><code>db.stored_item._enable_record_versioning(
    archive_db = db,
    archive_name = 'stored_item_archive',
    current_record = 'current_record',
    is_active = 'is_active')</code></pre><p>The <code>archive_db=db</code> tells web2py to store the archive table in the same database as the <code>stored_item</code> table. The <code>archive_name</code> sets the name for the archive table. The archive table has the same fields as the original table <code>stored_item</code> except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by <code>current_record</code> and which is a reference to the current record in the <code>stored_item</code> table.</p><p>When records are deleted, they are not really deleted. A deleted record is copied in the <code>stored_item_archive</code> table (like when it is modified) and the <code>is_active</code> field is set to False. By enabling record versioning web2py sets a <code>custom_filter</code> on this table that hides all records in table <code>stored_item</code> where the <code>is_active</code> field is set to False. The <code>is_active</code> parameter in the <code>_enable_record_versioning</code> method allows to specify the name of the field used by the <code>custom_filter</code> to determine if the field was deleted or not.</p><p><code>custom_filter</code>s are ignored by the appadmin interface.</p><h4>Common fields and multi-tenancy</h4><div class="inxx">common fields</div><div class="inxx">multi tenancy</div><p><code>db._common_fields</code> is a list of fields that should belong to all the tables. This list can also contain tables and it is understood as all fields from the table. For example occasionally you find yourself in need to add a signature to all your tables but the <code>`auth</code> tables. In this case, after you <code>db.define_tables()</code> but before defining any other table, insert</p><pre><code>db._common_fields.append(auth.signature)</code></pre><p>One field is special: "request_tenant". This field does not exist but you can create it and add it to any of your tables (or them all):</p><pre><code>db._common_fields.append(Field('request_tenant',
    default=request.env.http_host,writable=False))</code></pre><p>For every table with a field called <code>db._request_tenant</code>, all records for all queries are always automatically filtered by:</p><pre><code class="code">db.table.request_tenant == db.table.request_tenant.default</code></pre><p>and for every record inserted, this field is set to the default value. In the example above we have chosen</p><pre><code>default = request.env.http_host</code></pre><p>i.e. we have chose to ask our app to filter all tables in all queries with</p><pre><code>db.table.request_tenant == request.env.http_host</code></pre><p>This simple trick allow us to turn any application into a multi-tenant application. i.e. even if we run one instance of the app and we use one single database, if the app is accessed under two or more domains (in the example the domain name is retrieved from <code>request.env.http_host</code>) the visitors will see different data depending on the domain. Think of running multiple web stores under different domains with one app and one database.</p><p>You can turn off multi tenancy filters using: <div class="inxx">ignore_common_filters</div></p><pre><code class="code">rows = db(query, ignore_common_filters=True).select()</code></pre><h4>Common filters</h4><p>A common filter is a generalization of the above multi-tenancy idea. It provides an easy way to prevent repeating of the same query. Consider for example the following table:</p><pre><code>db.define_table('blog_post',
    Field('subject'),
    Field('post_text', 'text'),
    Field('is_public', 'boolean'),
    common_filter = lambda query: db.blog_post.is_public==True
)</code></pre><p>Any select, delete or update in this table, will include only public blog posts. The attribute can also be changed in controllers:</p><pre><code>db.blog_post._common_filter = lambda query: db.blog_post.is_public == True</code></pre><p>It serves both as a way to avoid repeating the "db.blog_post.is_public==True" phrase in each blog post search, and also as a security enhancement, that prevents you from forgetting to disallow viewing of none public posts.</p><p>In case you actually do want items left out by the common filter (for example, allowing the admin to see none public posts), you can either remove the filter:</p><pre><code>db.blog_post._common_filter = None</code></pre><p>or ignore it:</p><pre><code>db(query, ignore_common_filters=True).select(...)</code></pre><h4>Custom <code>Field</code> types (experimental)</h4><div class="inxx">SQLCustomType</div><p>Aside for using <code>filter_in</code> and <code>filter_out</code>, it is possible to define new/custom field types. For example we consider here a field that contains binary data in compressed form:</p><pre><code class="code">from gluon.dal import SQLCustomType
import zlib

compressed = SQLCustomType(
     type ='text',
     native='text',
     encoder =(lambda x: zlib.compress(x or '')),
     decoder = (lambda x: zlib.decompress(x))
)

db.define_table('example', Field('data',type=compressed))</code></pre><p><code>SQLCustomType</code> is a field type factory. Its <code>type</code> argument must be one of the standard web2py types. It tells web2py how to treat the field values at the web2py level. <code>native</code> is the type of the field as far as the database is concerned. Allowed names depend on the database engine. <code>encoder</code> is an optional transformation function applied when the data is stored and <code>decoder</code> is the optional reversed transformation function.</p><p>This feature is marked as experimental. In practice it has been in web2py for a long time and it works but it can make the code not portable, for example when the native type is database specific. It does not work on Google App Engine NoSQL.</p><h4>Using DAL without define tables</h4><p>The DAL can be used from any Python program simply by doing this:</p><pre><code class="code">from gluon import DAL, Field
db = DAL('sqlite://storage.sqlite',folder='path/to/app/databases')</code></pre><p>i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</p><p>To access the data and its attributes we still have to define all the tables we are going to access with <code>db.define_tables(...)</code>.</p><p>If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</p><pre><code class="code">from gluon import DAL, Field
db = DAL('sqlite://storage.sqlite',folder='path/to/app/databases',
         auto_import=True))</code></pre><p>This allows us to access any <code>db.table</code> without need to re-define it.</p><h4>PostGIS, SpatiaLite, and MS Geo (experimental)</h4><p><div class="inxx">PostGIS</div> <div class="inxx">StatiaLite</div> <div class="inxx">Geo Extensions</div> <div class="inxx">geometry</div> <div class="inxx">geoPoint</div> <div class="inxx">geoLine</div> <div class="inxx">geoPolygon</div></p><p>The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was sponsored by the Sahana project and implemented by Denes Lengyel.</p><p>DAL provides geometry and geography fields types and the following functions:</p><p><div class="inxx">st_asgeojson</div> <div class="inxx">st_astext</div> <div class="inxx">st_contains</div> <div class="inxx">st_distance</div> <div class="inxx">st_equals</div> <div class="inxx">st_intersects</div> <div class="inxx">st_overlaps</div> <div class="inxx">st_simplify</div> <div class="inxx">st_touches</div> <div class="inxx">st_within</div></p><pre><code>st_asgeojson (PostGIS only)
st_astext
st_contains
st_distance
st_equals
st_intersects
st_overlaps
st_simplify (PostGIS only)
st_touches
st_within
st_x
st_y</code></pre><p>Here are some examples:</p><pre><code class="code">from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon
db = DAL("mssql://user:pass@host:db")
sp = db.define_table('spatial', Field('loc','geometry()'))</code></pre><p>Below we insert a point, a line, and a polygon:</p><pre><code class="code">sp.insert(loc=geoPoint(1,1))
sp.insert(loc=geoLine((100,100),(20,180),(180,180)))
sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))</code></pre><p>Notice that</p><pre><code class="code">rows = db(sp.id&gt;0).select()</code></pre><p>Always returns the geometry data serialized as text. You can also do the same more explicitly using <code>st_astext()</code>:</p><pre><code class="code">print db(sp.id&gt;0).select(sp.id, sp.loc.st_astext())
spatial.id,spatial.loc.STAsText()
1, "POINT (1 2)"
2, "LINESTRING (100 100, 20 180, 180 180)"
3, "POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))"</code></pre><p>You can ask for the native representation by using <code>st_asgeojson()</code> (in PostGIS only):</p><pre><code class="code">print db(sp.id&gt;0).select(sp.id, sp.loc.st_asgeojson().with_alias('loc'))
spatial.id,loc
1, [1, 2]
2, [[100, 100], [20 180], [180, 180]]
3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]</code></pre><p>(notice an array is a point, an array of arrays is a line, and an array of array of arrays is a polygon).</p><p>Here are example of how to use geographical functions:</p><pre><code class="code">query = sp.loc.st_intersects(geoLine((20,120),(60,160)))
query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))
query = sp.loc.st_contains(geoPoint(1,1))
print db(query).select(sp.id,sp.loc)
spatial.id,spatial.loc
3,"POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))"</code></pre><p>Computed distances can also be retrieved as floating point numbers:</p><pre><code class="code">dist = sp.loc.st_distance(geoPoint(-1,2)).with_alias('dist')
print db(sp.id&gt;0).select(sp.id, dist)
spatial.id, dist
1 2.0
2 140.714249456
3 1.0</code></pre><h4>Copy data from one db into another</h4><p>Consider the situation in which you have been using the following database:</p><pre><code>db = DAL('sqlite://storage.sqlite')</code></pre><p>and you wish to move to another database using a different connection string:</p><pre><code>db = DAL('postgres://username:password@localhost/mydb')</code></pre><p>Before you switch, you want to move the data and rebuild all the metadata for the new database. We assume the new database to exist but we also assume it is empty.</p><p>Web2py provides a script that does this work for you:</p><pre><code>cd web2py
python scripts/cpdb.py \
   -f applications/app/databases \
   -y 'sqlite://storage.sqlite' \
   -Y 'postgres://username:password@localhost/mydb' \
   -d ../gluon</code></pre><p>After running the script you can simply switch the connection string in the model and everything should work out of the box. The new data should be there.</p><p>This script provides various command line options that allows you to move data from one application to another, move all tables or only some tables, clear the data in the tables. For more info try:</p><pre><code>python scripts/cpdb.py -h</code></pre><h4>Note on new DAL and adapters</h4><p>The source code of the Database Abstraction Layer was completely rewritten in 2010. While it stays backward compatible, the rewrite made it more modular and easier to extend. Here we explain the main logic.</p><p>The file "gluon/dal.py" defines, among other, the following classes.</p><pre><code>ConnectionPool
BaseAdapter extends ConnectionPool
Row
DAL
Reference
Table
Expression
Field
Query
Set
Rows</code></pre><p>Their use has been explained in the previous sections, except for <code>BaseAdapter</code>. When the methods of a <code>Table</code> or <code>Set</code> object need to communicate with the database they delegate to methods of the adapter the task to generate the SQL and or the function call.</p><p>For example:</p><pre><code>db.mytable.insert(myfield='myvalue')</code></pre><p>calls</p><pre><code>Table.insert(myfield='myvalue')</code></pre><p>which delegates the adapter by returning:</p><pre><code>db._adapter.insert(db.mytable,db.mytable._listify(dict(myfield='myvalue')))</code></pre><p>Here <code>db.mytable._listify</code> converts the dict of arguments into a list of <code>(field,value)</code> and calls the <code>insert</code> method of the <code>adapter</code>. <code>db._adapter</code> does more or less the following:</p><pre><code>query = db._adapter._insert(db.mytable,list_of_fields)
db._adapter.execute(query)</code></pre><p>where the first line builds the query and the second executes it.</p><p><code>BaseAdapter</code> defines the interface for all adapters.</p><p>"gluon/dal.py" at the moment of writing this book, contains the following adapters:</p><pre><code>SQLiteAdapter extends BaseAdapter
JDBCSQLiteAdapter extends SQLiteAdapter
MySQLAdapter extends BaseAdapter
PostgreSQLAdapter extends BaseAdapter
JDBCPostgreSQLAdapter extends PostgreSQLAdapter
OracleAdapter extends BaseAdapter
MSSQLAdapter extends BaseAdapter
MSSQL2Adapter extends MSSQLAdapter
MSSQL3Adapter extends MSSQLAdapter
MSSQL4Adapter extends MSSQLAdapter
FireBirdAdapter extends BaseAdapter
FireBirdEmbeddedAdapter extends FireBirdAdapter
InformixAdapter extends BaseAdapter
DB2Adapter extends BaseAdapter
IngresAdapter extends BaseAdapter
IngresUnicodeAdapter extends IngresAdapter
GoogleSQLAdapter extends MySQLAdapter
NoSQLAdapter extends BaseAdapter
GoogleDatastoreAdapter extends NoSQLAdapter
CubridAdapter extends MySQLAdapter (experimental)
TeradataAdapter extends DB2Adapter (experimental)
SAPDBAdapter extends BaseAdapter (experimental)
CouchDBAdapter extends NoSQLAdapter (experimental)
IMAPAdapter extends NoSQLAdapter (experimental)
MongoDBAdapter extends NoSQLAdapter (experimental)
VerticaAdapter extends MSSQLAdapter (experimental)
SybaseAdapter extends MSSQLAdapter (experimental)</code></pre><p>which override the behavior of the <code>BaseAdapter</code>.</p><p>Each adapter has more or less this structure:</p><pre><code class="code">class MySQLAdapter(BaseAdapter):

    # specify a diver to use
    driver = globals().get('pymysql',None)

    # map web2py types into database types
    types = {
        'boolean': 'CHAR(1)',
        'string': 'VARCHAR(%(length)s)',
        'text': 'LONGTEXT',
        ...
        }

    # connect to the database using driver
    def __init__(self,db,uri,pool_size=0,folder=None,db_codec ='UTF-8',
                credential_decoder=lambda x:x, driver_args={},
                adapter_args={}):
        # parse uri string and store parameters in driver_args
        ...
        # define a connection function
        def connect(driver_args=driver_args):
            return self.driver.connect(**driver_args)
        # place it in the pool
        self.pool_connection(connect)
        # set optional parameters (after connection)
        self.execute('SET FOREIGN_KEY_CHECKS=1;')
        self.execute("SET sql_mode='NO_BACKSLASH_ESCAPES';")

   # override BaseAdapter methods as needed
   def lastrowid(self,table):
        self.execute('select last_insert_id();')
        return int(self.cursor.fetchone()[0])
</code></pre><p>Looking at the various adapters as example should be easy to write new ones.</p><p>When <code>db</code> instance is created:</p><pre><code>db = DAL('mysql://...')</code></pre><p>the prefix in the uri string defines the adapter. The mapping is defined in the following dictionary also in "gluon/dal.py":</p><pre><code class="code">ADAPTERS = {
    'sqlite': SQLiteAdapter,
    'spatialite': SpatiaLiteAdapter,
    'sqlite:memory': SQLiteAdapter,
    'spatialite:memory': SpatiaLiteAdapter,
    'mysql': MySQLAdapter,
    'postgres': PostgreSQLAdapter,
    'postgres:psycopg2': PostgreSQLAdapter,
    'postgres:pg8000': PostgreSQLAdapter,
    'postgres2:psycopg2': NewPostgreSQLAdapter,
    'postgres2:pg8000': NewPostgreSQLAdapter,
    'oracle': OracleAdapter,
    'mssql': MSSQLAdapter,
    'mssql2': MSSQL2Adapter,
    'mssql3': MSSQL3Adapter,
    'mssql4' : MSSQL4Adapter,
    'vertica': VerticaAdapter,
    'sybase': SybaseAdapter,
    'db2': DB2Adapter,
    'teradata': TeradataAdapter,
    'informix': InformixAdapter,
    'informix-se': InformixSEAdapter,
    'firebird': FireBirdAdapter,
    'firebird_embedded': FireBirdAdapter,
    'ingres': IngresAdapter,
    'ingresu': IngresUnicodeAdapter,
    'sapdb': SAPDBAdapter,
    'cubrid': CubridAdapter,
    'jdbc:sqlite': JDBCSQLiteAdapter,
    'jdbc:sqlite:memory': JDBCSQLiteAdapter,
    'jdbc:postgres': JDBCPostgreSQLAdapter,
    'gae': GoogleDatastoreAdapter, # discouraged, for backward compatibility
    'google:datastore': GoogleDatastoreAdapter,
    'google:datastore+ndb': GoogleDatastoreAdapter,
    'google:sql': GoogleSQLAdapter,
    'couchdb': CouchDBAdapter,
    'mongodb': MongoDBAdapter,
    'imap': IMAPAdapter
}</code></pre><p>the uri string is then parsed in more detail by the adapter itself.</p><p>For any adapter you can replace the driver with a different one:</p><pre><code>import MySQLdb as mysqldb
from gluon.dal import MySQLAdapter
MySQLAdapter.driver = mysqldb</code></pre><p>i.e. <code>mysqldb</code> has to be <em>that module</em> with a .connect() method. You can specify optional driver arguments and adapter arguments:</p><pre><code>db =DAL(..., driver_args={}, adapter_args={})</code></pre><h3>Gotchas</h3><h4>SQLite</h4><p>SQLite does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but will be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set <code>fake_migrate=True</code> so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, <strong>SQLite</strong> is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type "string" with type "integer", SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</p><p>SQLite doesn't have a boolean type. web2py internally maps booleans to a 1 character string, with 'T' and 'F' representing True and False. The DAL handles this completely; the abstraction of a true boolean value works well. But if you are updating the SQLite table with SQL directly, be aware of the web2py implementation, and avoid using 0 and 1 values.</p><h4>MySQL</h4><p>MySQL does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set <code>fake_migrate=True</code> and after the metadata has been rebuilt, set <code>fake_migrate=False</code> and migrate the table again).</p><h4>Google SQL</h4><p>Google SQL has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a read-only file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (by migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (by accessing the database using the Google dashboard and deleting any corrupted entry from the table called <code>web2py_filesystem</code>.</p><h4>MSSQL (Microsoft SQL Server)</h4><div class="inxx">limitby</div><p>MSSQL &lt; 2012 does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a <code>limitby=(a,b)</code> web2py will fetch the first <code>b</code> rows and discard the first <code>a</code>. This may result in a considerable overhead when compared with other database engines. If you're using MSSQL &gt;= 2005, the recommended prefix to use is <code>mssql3://</code> which provides a method to avoid the issue of fetching the entire non-paginated resultset. If you're on MSSQL &gt;= 2012, use <code>mssql4://</code> that uses the <code>OFFSET ... ROWS ... FETCH NEXT ... ROWS ONLY</code> construct to support natively pagination without performance hits like other backends. The <code>mssql://</code> uri also enforces (for historical reasons) the use of <code>text</code> columns, that are superseeded in more recent versions (from 2005 onwards) by <code>varchar(max)</code>. <code>mssql3://</code> and <code>mssql4://</code> should be used if you don't want to face some limitations of the - officially deprecated - <code>text</code> columns</p><p>MSSQL has problems with circular references in tables that have ONDELETE CASCADE. This is an MSSQL bug and you work around it by setting the ondelete attribute for all reference fields to "NO ACTION". You can also do it once and for all before you define tables:</p><pre><code class="code">db = DAL('mssql://....')
for key in ['reference','reference FK']:
    db._adapter.types[key]=db._adapter.types[key].replace(
        '%(on_delete_action)s','NO ACTION')</code></pre><p>MSSQL also has problems with arguments passed to the DISTINCT keyword and therefore while this works,</p><pre><code>db(query).select(distinct=True)</code></pre><p>this does not</p><pre><code>db(query).select(distinct=db.mytable.myfield)</code></pre><h4>Oracle</h4><p>Oracle also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a <code>db(...).select(limitby=(a,b))</code> into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.</p><h4>Google NoSQL (Datastore)</h4><p>Google NoSQL (Datastore) does not allow joins, left joins, aggregates, expression, OR involving more than one table, the â€˜likeâ€™ operator searches in "text" fields.</p><p>Transactions are limited and not provided automatically by web2py (you need to use the Google API <code>run_in_transaction</code> which you can look up in the Google App Engine documentation online).</p><p>Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the "list:string" type is mapped into a "text" type, on the Google Datastore it is mapped into a <code>ListStringProperty</code>. Similarly "list:integer" and "list:reference" are mapped into "ListProperty". This makes searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</p>