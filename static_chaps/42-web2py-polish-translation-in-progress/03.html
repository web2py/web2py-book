<h2>Przegląd</h2><h3>Uruchomienie</h3><p><div class="inxx">Linux</div> <div class="inxx">Mac</div> <div class="inxx">Windows</div></p><p>Platforma web2py dostarczana jest w pakietach binarnych dla Windows i Mac OS X. Zawierają one interpreter Pythona, więc nie trzeba go instalować wcześniej. Istnieje również wersja kodu źródłowego, która działa pod Windows, Mac, Linux i innych systemach uniksowych. Pakiet źródłowy nie posiada interpretera Pythona, więc trzeba go mieć wcześniej zainstalowanego na swoim komputerze.</p><p>Platforma web2py nie wymaga instalacji. Aby rozpocząć wystarczy rozpakować pobrany plik zip dla swojego systemu operacyjnego i wykonać odpowiednio plik <code>web2py</code>.</p><p>Na Unix i Linux (dystrybucja źródłowa) uruchom:</p><pre><code class="code">python web2py.py</code></pre><p>Na OS X (dystrybucja binarna) uruchom:</p><pre><code class="code">open web2py.app</code></pre><p>Na Windows (dystrybucja binarna) uruchom:</p><pre><code class="code">web2py.exe</code></pre><p>Na Windows (dystrybucja źródłowa web2py) uruchom:</p><pre><code class="code">c:/Python27/python.exe web2py.py</code></pre><blockquote>Uwaga, aby uruchomić web2py na Windows z wersji źródłowej, trzeba najpierw
zainstalować rozszerzenia win32 Marka Hammonda ze <a href="http://sourceforge.net/projects/pywin32/">strony projektu pywin32</a>.</blockquote><p>Program web2py obsługuje różne opcje linii poleceń, które zostaną omówione później.</p><p>Domyślnie przy starcie web2py wyświetla okno startowe a następnie wyświetla widżet GUI z prośbą o wybranie:</p><ul><li>jednorazowego hasła administratora,</li><li>adresu IP interfejsu sieciowego, który ma zostać użyty dla serwera internetowego</li><li>numeru portu dla obsługiwanych żądań.</li></ul><p>Domyślnie web2py uruchamia swój serwer pod adresem 127.0.0.1:8000 (port 8000 na localhost), ale można go uruchamiać na dowolnym dostępnym adresie IP i porcie. Można wypytać adres IP swojego interfejsu sieciowego przez otworzenie linii poleceń i wpisanie <code>ipconfig</code> w Windows albo <code>ifconfig</code> na OS X i Linux. Od teraz zakładamy, że web2py jest uruchamiany na localhost (127.0.0.1:8000). Użyj 0.0.0.0:80 aby uruchomić web2py publicznie na dowolnym interfejsie sieciowym.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl400.png" alt="image" style="width:306px" /></p></p><p>Jeśli nie dostarczy się hasła administratora, to interfejs administracyjny będzie niedostępny. Jest to środek bezpieczeństwa, aby publicznie nie ujawniać interfejsu administracyjnego.</p><p>Interfejs administracyjny (aplikacja <strong>admin</strong>) jest dostępny tylko z localhost, chyba że uruchamia się web2py na serwerze Apache z modułem mod_proxy. Jeśli aplikacja <strong>admin</strong> wykryje proxy, ciasteczko sesji zostaje ustawione na tryb bezpieczny a logowanie <strong>admin</strong> nie będzie działało, jeśli komunikacja pomiędzy klientem a proxy nie następuje w trybie HTTPS, jest to środek bezpieczeństwa. Cała komunikacja pomiędzy klientem a aplikacją <strong>admin</strong> zawsze musi być lokalna lub szyfrowana. W przeciwnym razie atakujący będzie w stanie wykonać atak.</p><p>Po ustawieniu hasła administratora, web2py uruchamia przeglądarkę internetową na stronie:</p><pre><code class="code">http://127.0.0.1:8000/</code></pre><p>Jeśli komputer nie posiada domyślnej przeglądarki internetowej, trzeba ręcznie otworzyć przeglądarkę i wprowadzić adres URL.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl500.png" alt="image" style="width:480px" /></p></p><p>Kliknięcie odnośnika "Interfejs administracyjny" przeniesie Cię do strony logowania interfejsu administracyjnego.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl600.png" alt="image" style="width:480px" /></p></p><p>Hasło administratora, to hasło, które wybrało się na starcie. Proszę zauważyć, że jest tylko jeden administrator i dlatego jest tylko jedno hasło administratora. Ze względów bezpieczeństwa, programista jest proszony o wybranie nowego hasła przy każdym uruchomieniu web2py, chyba że  jest określona opcja &lt;recycle&gt;. Różni się to od mechanizmu uwierzytelniania w aplikacjach web2py.</p><p>Po zalogowaniu administratora w web2py, przeglądarka jest przekierowywana do strony głównej (<em>site</em>).</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl700.png" alt="image" style="width:480px" /></p></p><p>Strona ta wykazuje wszystkie zainstalowane aplikacje web2py i umożliwia administratorowi zarządzanie nimi. Platforma web2py dostarczana jest z trzema aplikacjami: <div class="inxx">admin</div> <div class="inxx">examples</div> <div class="inxx">welcome</div> <div class="inxx">szkieletowanie</div></p><ul><li>aplikacją <strong>admin</strong>, to ta która używasz teraz;</li><li>aplikacją <strong>examples</strong> z interaktywną dokumentacją internetową i repliką oficjalnej witryny internetowej web2py;</li><li>aplikacją <strong>welcome</strong>. Jest to podstawowy szablon dowolnej aplikacji web2py.</li></ul><p>Aplikacja <strong>welcome</strong>, to tzw. <em>aplikacja szkieletowa</em>. Jest to też aplikacja witająca użytkowników przy rozpoczęciu web2py.</p><div class="inxx">dodatki aplikacyjne</div><p>Gotowe do użycia aplikacje web2py są nazywane <strong>dodatkami aplikacyjnymi</strong> (<em>ang. appliances</em>). Można pobrać wiele dostępnych za darmo aplikacji ze strony dodatków aplikacyjnych<sup>[<a href="/book/default/reference/42/appliances" target="_blank">appliances</a>]</sup> . Użytkownicy web2py są zachęcani do zgłaszania nowych aplikacji, zarówno w formie otwartego jak i zamkniętego kodu (skomilowanych i spakowanych).</p><p>Ze strony interfejsu administracyjnego (aplikacji <strong>admin</strong>) można wykonać następujące operacje:</p><ul><li><strong>instalować</strong> aplikację wypełniając formularz dostępny poprzez przycisk w prawym dolnym rogu strony. Nadaj nazwę aplikacji, wybierz plik zawierający pakiet aplikacji lub podaj adres URL, gdzie aplikacja jest zlokalizowana i kliknij "Wprowadź";</li><li><strong>odinstalowywać</strong> aplikację, klikając odpowiedni przycisk. Spowoduje to wyświetlenie strony z potwierdzaniem;</li><li><strong>tworzyć</strong> nową aplikację, wybierając nazwę i klikając przycisk "Utwórz";</li><li><strong>pakować</strong> aplikację w celach dystrybucyjnych, klikając odpowiedni przycisk. Aplikacja jest pakowana do pliku archiwum TAR i zawiera on wszystkie elementy aplikacji, łącznie z bazą danych. Nie należy rozpakowywać tego pliku – jest on automatycznie rozpakowywany przez web2py podczas instalacji z poziomu <strong>admin</strong>;</li><li><strong>czyścić</strong> tymczasowe pliki aplikacji, takie jak sesje, pliki błędów i pamięci podręcznej;</li><li><strong>włączać</strong> i <strong>wyłączać</strong> każdą aplikację. Gdy aplikacja jest wyłączona, to nie można wywoływać jej zdalnie, ale jest ona dostępna poprzez localhost. Oznacza to, że aplikacja wyłączona jest stale dostępna za serwerem proxy. Aplikacja jest wyłączana poprzez utworzenie w folderze aplikacji pliku o nazwie "DISABLED". Użytkownicy którzy próbują uzyskać dostęp będą otrzymywać stronę błędu 503 HTTP. Można wykorzystać parametr routes_onerror do dostosowania strony błędu.</li><li><strong>edytować</strong> aplikację.</li></ul><blockquote>Podczas tworzenia nowej aplikacji przy użyciu <strong>admin</strong>, zaczyna się od sklonowania
aplikacji szkieletowej "welcome" w "models/db.py", co tworzy bazę danych SQLite,
podłącza do niej nową aplikację, tworzy instancję Auth, Crud i Service oraz je
konfiguruje. Dostarcza również "controller/default.py", który udostępnia akcje
"index", "download", "user" dla zarządzania użytkownikami oraz "call" dla usług.
W dalszej części rozdziału założono, że te pliki zostały usunięte – będziemy tworzyć
aplikacje od podstaw.</blockquote><p>Platforma web2py dostarczana jest również z <strong>kreatorem</strong>, opisanym w dalszej części rozdziału, który może pisać alternatywny kod szkieletowy na podstawie układów i wtyczek dostępnych w sieci i na podstawie opisu wysokiego poziomu modeli.</p><h3>Proste przykłady</h3><h4>Przywitaj się</h4><div class="inxx">index</div><p>Oto, na przykład, możemy utworzyć prostą aplikację wyświetlającą użytkownikówi komunikat "Hello from MyApp". Będziemy mogli wywołać tą aplikacje przez "myapp". Dodamy również licznik zliczający ile razy ten sam użytkownik odwiedził tą stronę.</p><p>Nową aplikacje można utworzyć wpisując po prostu jej nazwę w formularzu w prawej górnej części strony głównej w interfejsie administracyjnym.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl800.png" alt="image" style="width:447px" /></p></p><p>Po naciśnięciu przycisku <em>Utwórz</em>, zostanie utworzona aplikacja jako kopia wbudowanej aplikacji powitalnej.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl900.png" alt="image" style="width:480px" /></p></p><p>Aby uruchomić tą aplikację, odwiedź:</p><pre><code class="code">http://127.0.0.1:8000/myapp</code></pre><p>Teraz mamy już utworzoną kopię aplikacji powitalnej.</p><p>W celu edytowania aplikacji kliknij przycisk <em>edytuj</em> dla nowo tworzonej aplikacji.</p><p>Strona <strong>Edycja aplikacji</strong> informuje o tym, co jest wewnątrz aplikacji. Każda aplikacja web2py składa się z określonych plików, które w większości należą do jednej z sześciu kategorii:</p><ul><li><strong>modele</strong>: opisują reprezentację danych;</li><li><strong>kontrolery</strong>: opisują logikę aplikacji i przetwarzanie;</li><li><strong>widoki</strong>: opisują prezentację danych;</li><li><strong>języki</strong>: opisują jak przetłumaczyć prezentacje aplikacji na inne języki;</li><li><strong>moduły</strong>: moduły Pythona, które należą do tej aplikacji;</li><li><strong>pliki statyczne</strong>: statyczne obrazy, pliki CSS<sup>[<a href="/book/default/reference/42/css-w" target="_blank">css-w</a>]</sup> <sup>[<a href="/book/default/reference/42/css-o" target="_blank">css-o</a>]</sup> <sup>[<a href="/book/default/reference/42/css-school" target="_blank">css-school</a>]</sup> , pliki JavaScript<sup>[<a href="/book/default/reference/42/js-w" target="_blank">js-w</a>]</sup> <sup>[<a href="/book/default/reference/42/js-b" target="_blank">js-b</a>]</sup> itd.;</li><li><strong>wtyczki</strong>: grupy plików zaprojektowane do wspólnego działania.</li></ul><p>Wszystko jest zorganizowane według wzorca Model-Widok-Kontroler. Każda sekcja na stronie <em>Edycja aplikacji</em> odnosi się do podfolderu w folderze aplikacji.</p><p>Zwróć uwagę, że klikając na nagłówki sekcji przełącza się ich treść. Nazwy folderów dla plików statycznych są również rozwijane.</p><blockquote>Każdy plik wykazany w sekcji odpowiada fizycznemu plikowi umieszczonemu w podfolderze.
Każda operacja wykonywana na pliku poprzez interfejs <strong>admin</strong> (tworzenie, edytowanie,
usuwanie) może być wykonana bezpośrednio z powłoki przy użyciu ulubionego edytora.</blockquote><p>Aplikacja zawiera też inne rodzaje plików (bazę danych, pliki sesji, pliki błędów itd.), ale nie są one wykazane na stronie <em>Edycja aplikacji</em>, ponieważ nie są tworzone lub modyfikowane przez administratora – są one tworzone i modyfikowane przez samą aplikację.</p><p>Kontrolery zawierają logikę i przetwarzanie aplikacji. Każdy adres URL zostaje odwzorowany na wywołanie jednej z funkcji w kontrolerach (akcji). Są dwa domyślne kontrolery: "appadmin.py" i "default.py". Kontroler <strong>appadmin</strong> dostarcza interfejs administracyjny bazy danych – nie potrzebujemy go teraz. Plik "default.py" jest kontrolerem, który potrzebujemy edytować i jest tym, który jest domyślnie wywoływany, gdy żaden kontroler nie jest określony w adresie URL. Edytujmy funkcję "index" w następujący sposób:</p><pre><code class="code">def index():
    return "Hello from MyApp"</code></pre><p>Oto jak wygląda to w edytorze internetowym:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1000.png" alt="image" style="width:480px" /></p></p><p>Zapisz to i wróć do strony <em>Edycja aplikacji</em>. Kliknij na odnośnik index dla kontrolera <em>defaul.py</em>, aby odwiedzić nowo utworzoną stronę.</p><p>Gdy odwiedzisz adres URL</p><pre><code class="code">http://127.0.0.1:8000/myapp/default/index</code></pre><p>wywołana zostaje akcja index w domyślnym kontrolerze aplikacji. Zwracany jest ciąg znaków, który zostaje wyświetlony przez przeglądarkę. Wygląda to podobnie do tego:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1100.png" alt="image" style="width:480px" /></p></p><p>Teraz edytuj "default.py" i zmień funkcję "index" w następujący sposób:</p><pre><code class="code">def index():
    return dict(message="Hello from MyApp")</code></pre><p>Również na stronie <em>Edycja aplikacji</em> edytuj widok "default/index.html" (plik widoku związany z akcją) i całkowicie wymień istniejącą zawartość tego pliku na to:</p><pre><code class="code">&lt;html&gt;
   &lt;head&gt;&lt;/head&gt;
   &lt;body&gt;
      &lt;h1&gt;{{=message}}&lt;/h1&gt;
   &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Nasza akcja zwraca słownik definiujący <code>message</code> a gdy akcja zwraca słownik, web2py wyszukuje widok o nazwie</p><pre><code class="code">[controller]/[function].[extension]</code></pre><p>i wykonuje go. Tutaj <code>[extension]</code> jest żądanym rozszerzeniem. Jeśli żadne rozszerzenie nie zostanie określone, to domyślnie przyjęte zostanie rozszerzenie ".html" i tak założyliśmy tutaj. Przy tym założeniu widok jest plikiem HTML, który osadza kod Pythona przy użyciu specjalnych znaczników {{ }}. W szczególności, w tym przykładzie, wyrażenie <code>{{=message}}</code> instruuje web2py aby wymienił ten kod na wartość <code>message</code> zwracaną przez akcję. Proszę zwrócić uwagę, że <code>message</code> nie jest tutaj słowem kluczowym web2py, ale jest zmienną zdefiniowaną w akcji. Do tej pory nie korzystaliśmy z żadnych słów kluczowych web2py.</p><p>Jeśli web2py nie znajdzie żadnego żądanego widoku, to stosuje widok "generic.html", który jest dostarczany w każdej aplikacji.</p><blockquote><div class="inxx">Mac Mail</div> <div class="inxx">Google Maps</div> <div class="inxx">jsonp</div>
Jeśli określone jest inne rozszerzenie niż "html" (na przykład "json") i plik widoku
"[controller]/[function].json" nie zostanie znaleziony, to web2py wyszuka widok
"generic.json". Platforma web2py dostarczana jest z widokami generic.html,
generic.json, generic.jsonp, generic.xml, generic.rss, generic.ics (dla Mac Mail
Calendar), generic.map (do osadzania w Google Maps) i generic.pdf (opartym na fpdf).
Te ogólne widoki mogą być indywidualnie modyfikowane w każdej aplikacji i łatwo
mogą być dodawane dodatkowe widoki.</blockquote><blockquote>Widoki ogólne są narzędziem programistycznym. W środowisku produkcyjnym każda
akcja powinna mieć swój własny widok. W rzeczywistości, widoki ogólne
są domyślnie dostępne tylko na localhost.</blockquote><blockquote>Można również określić widok stosując <code>response.view = 'default/something.html'</code></blockquote><p>Czytaj wiecej na ten temat w rozdziale 10.</p><p>Jeśli powrócisz do "Edycja aplikacji" i klikniesz na <code>index</code>, to zobaczysz następującą stronę HTML:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1200.png" alt="image" style="width:480px" /></p></p><h4>Pasek narzędziowy debugowania</h4><div class="inxx">pasek narzędziowy</div><p>W celach debugowania można wstawić do kodu widoku</p><pre><code class="code">{{=response.toolbar()}}</code></pre><p>a pokaże się kilka użytecznych informacji, łącznie z żądaniem, odpowiedzią i obiektami sesji oraz listą wszystkich zapytań do bazy danych z ich wykazem czasowym.</p><h4>Policzmy</h4><div class="inxx">sesja</div><p>Dodajmy teraz do naszej strony licznik, który będzie zliczał ile razy ten sam odwiedzający odwiedził ta stronę.</p><p>Platforma web2py automatycznie i przejrzyście śledzi odwiedzających wykorzystując sesje i ciasteczka. Dla każdego nowego odwiedzającego jest tworzona sesja i przypisywana jest jej unikalna wartość "session_id". Sesja jest kontenerem dla zmiennych, które są zapisywane po stronie serwera. Ta unikalna wartość identyfikatora jest przypisywana do przeglądarki poprzez ciasteczko. Gdy odwiedzający zażąda innej strony z tej samej aplikacji, przeglądarka odsyła ciasteczko z powrotem, co jest przechwytywane przez web2py i przywracana jest odpowiednia sesja.</p><p>Aby wykorzystać sesję, zmodyfikujmy domyślny kontroler:</p><pre><code class="code">def index():
    if not session.counter:
        session.counter = 1
    else:
        session.counter += 1
    return dict(message="Hello from MyApp", counter=session.counter)</code></pre><p>Trzeba mieć na uwadze, że <code>counter</code> nie jest słowem kluczowym web2py, ale <code>session</code> jest. Pytamy web2py aby sprawdził czy istnieje zmienna <code>counter</code> w obiekcie sesji i jeśli nie, to ją tworzymy i ustawiamy na 1. Jeśli <code>counter</code> istnieje, to polecamy web2py aby zwiększył wartość counter o 1. Na koniec przekazujemy tą wartość do widoku.</p><p>Bardziej krótszym sposobem na zakodowanie tej samej funkcji jest:</p><pre><code class="code">def index():
    session.counter = (session.counter or 0) + 1
    return dict(message="Hello from MyApp", counter=session.counter)</code></pre><p>Zmodyfikujmy teraz widok, dodając linię, która wyświetla wartość licznika:</p><pre><code class="code">&lt;html&gt;
   &lt;head&gt;&lt;/head&gt;
   &lt;body&gt;
      &lt;h1&gt;{{=message}}&lt;/h1&gt;
      &lt;h2&gt;Number of visits: {{=counter}}&lt;/h2&gt;
   &lt;/body&gt;
&lt;/html&gt;</code></pre><p>Gdy ponownie odwiedzisz stronę index (i jeszcze raz), to zobaczysz stronę HTML podobną do tej:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1300.png" alt="image" style="width:480px" /></p></p><p>Licznik jest związany z indywidualnym odwiedzającym i jest zwiększany za każdym razem,gdy użytkownik ten odwiedzi stronę. Różni odwiedzający zobaczą inny licznik.</p><h4>Wypowiedz moje imię</h4><p><div class="inxx">formularz</div> <div class="inxx">request.vars</div></p><p>Teraz utworzymy dwie strony (first i second), gdzie pierwsza strona zawiera formularz pytający odwiedzającego o imię i przekierowujący do drugiej strony, która wita odwiedzających po imieniu.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1400.png" alt="yUML diagram" style="width:200px" /></p></p><p>Napiszmy odpowiednie akcje w domyślnym kontrolerze:</p><pre><code class="code">def first():
    return dict()

def second():
    return dict()</code></pre><p>Następnie utwórzmy widok "default/first.html" dla pierwszej akcji i wprowadźmy tam ten kod:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Jak masz na imię?&lt;/h1&gt;
&lt;form action="second"&gt;
  &lt;input name="visitor_name" /&gt;
  &lt;input type="submit" /&gt;
&lt;/form&gt;</code></pre><p>Na koniec, tworzymy widok "default/second.html" dla drugiej akcji:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Witaj {{=request.vars.visitor_name}}&lt;/h1&gt;</code></pre><div class="inxx">układ strony</div><p>W obu widokach dokonaliśmy ich rozszerzenia o bazowy widok "layout.html", który dostarczany jest wraz z web2py. Widok układu zachowuje zgodny wygląd obydwu stron. Plik układu można łatwo edytować i wymieniać, ponieważ zawiera kod HTML.</p><p>Jeśli teraz odwiedzisz pierwszą stronę, to wpisz swoje imię:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1500.png" alt="image" style="width:480px" /></p></p><p>i wyślij formularz, a dostaniesz powitanie:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1600.png" alt="image" style="width:480px" /></p></p><h4>Zgłoszenia zwrotne</h4><p><div class="inxx">przekierowanie</div> <div class="inxx">URL</div> <div class="inxx">postback</div> <div class="inxx">zgłoszenie zwrotne</div></p><p>Mechanizm wysyłania formularzy, który kiedyś był powszechny, nie jest dobrą praktyką. Wszystkie dane wejściowe powinny być sprawdzane i w powyższym przykładzie ciężar walidacji spadnie na akcję second. Zatem akcja, która wykonuje  walidację jest różna od akcji generującej formularz. To zwykle powoduje nadmiarowość kodu.</p><p>Lepszym wzorcem wysyłania formularzy jest przesyłanie formularza do tej samej akcji, która go wygenerowała, w naszym przykładzie akcji "first". Akcja "first" powinna otrzymać zmienne, przetworzyć je, zapisać je po stronie serwera i przekierować odwiedzającego do strony "second", która pobierze zmienne. Mechanizm ten nazywany jest <strong>zgłoszeniem zwrotnym</strong> (<em>ang. postback</em>).</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1700.png" alt="yUML diagram" style="width:200px" /></p></p><p>Zmodyfikujmy domyślny kontroler, tak aby implementował samo zgłoszenie:</p><pre><code class="code">def first():
    if request.vars.visitor_name:
        session.visitor_name = request.vars.visitor_name
        redirect(URL('second'))
    return dict()

def second():
    return dict()</code></pre><p>Następnie zmodyfikujmy widok "default/first.html":</p><pre><code class="code">{{extend 'layout.html'}}
What is your name?
&lt;form&gt;
  &lt;input name="visitor_name" /&gt;
  &lt;input type="submit" /&gt;
&lt;/form&gt;</code></pre><p>oraz widok "default/second.html" potrzebny do pobierania danych z <code>session</code> zamiast z <code>request.vars</code>:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Hello {{=session.visitor_name or "anonymous"}}&lt;/h1&gt;</code></pre><p>Z punktu widzenie odwiedzającego, samoskładanie działa dokladnie tak samo jak poprzednia implemetacja. Nie dodaliśmy jeszcze walidacji, ale teraz jest już jasne, że walidacja powinna się odbyć w pierwszej akcji.</p><p>To podejście jest lepsze, również dlatego, że nazwa odwiedzającego pozostaje w sesji i może być dostępna dla wszystkich akcji i widoków w aplikacji bez konieczności jawnego jej przekazywania w kółko.</p><p>Proszę zauważyć, że jeśli akcja "second" jest zawsze wywoływana przed ustawieniem nazwy odwiedzającego, to zostanie wyświetlone "Witaj anonymous" ponieważ <code>session.visitor_name</code> zwraca <code>None</code>. Alternatywnie możemy dodać następujący kod do kontrolera (wewnatrz funkcji <code>second</code>):</p><pre><code class="code">if not request.function=='first' and not session.visitor_name:
    redirect(URL('first'))</code></pre><p>Jest to mechanizm <em>ad hoc</em>, który można użyć do wymuszenia uwierzytelniania w kontrolerach, choć są lepsze metodu omówione w rozdziale 9.</p><p><div class="inxx">FORM</div> <div class="inxx">INPUT</div> <div class="inxx">requires</div> <div class="inxx">IS_NOT_EMPTY</div> <div class="inxx">accepts</div></p><p>Z web2py możemy pójść krok dalej i poprosić web2py aby wygenerował formularz za nas, łącznie z walidacją. Platforma web2py dostarcza helpery (FORM, INPUT, TEXTAREA i SELECT/OPTION) z tą samą nazwą co równoważny znacznik HTML. Moga być one wykorzystane do budowy formularzy zarówno w kontrolerze jak i w widoku.</p><p>Na przykład, oto jeden z możliwych sposobów na przepisanie pierwszej akcji:</p><pre><code class="code">def first():
    form = FORM(INPUT(_name='visitor_name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)</code></pre><p>gdzie widzimy znacznik FORM zawierający dwa znaczniki INPUT. Atrybuty znaczników input są określone przez nazwane argumenty rozpoczynające się znakiem podkreślenia. Argument <code>requires</code> nie jest argumentem znacznika (ponieważ nie rozpoczyna się znakiem podkreślenia) ale ustawia walidator dla wartości nazwy odwiedzającego.</p><p>Oto jeszcze lepszy sposób na utworzenie takiego formularza:</p><pre><code class="code">def first():
    form = SQLFORM.factory(Field('visitor_name',
                                 label='what is your name?',
                                 requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)</code></pre><p>Obiekt <code>form</code> można łatwo serializować do HTML przez osadzenie go w widoku "default/first.html".</p><pre><code class="code">{{extend 'layout.html'}}
{{=form}}</code></pre><p>Metoda <code>form.process()</code> stosuje walidatory i zwraca formularz. Zmienna <code>form.accepted</code> zostaje ustawiona na True, jeśli formularz został przetworzony i przeszedł walidację. Jeśli samo zgłaszający się formularz przechodzi walidację, to zmienne zostają zapisane w sesji a odwiedzający zostaje zostaje przekierowany, jak miało to miejsce wcześniej. Jeśli formularz nie przechodzi walidacji, to wyświetlane są komunikaty umieszczone w formularzu, jak niżej:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1800.png" alt="image" style="width:480px" /></p></p><p>W następnym rozdziale pokażemy, jak może być automatycznie wygenerowany formularz z modelu.</p><p>We wszystkich naszych przykładach wykorzystaliśmy sesję do przekazania imienia użytkownika z pierwszej akcji do drugiej. Moglibyśmy użyć innego mechanizmu i przekazać dane jako część adresu URL przekierowania:</p><pre><code class="code">def first():
    form = SQLFORM.factory(Field('visitor_name', requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        name = form.vars.visitor_name
        redirect(URL('second',vars=dict(name=name)))
    return dict(form=form)

def second():
    name = request.vars.visitor_name or redirect(URL('first'))
    return dict(name=name)</code></pre><p>Trzeba mieć na uwadze, że ogólnie nie jest dobrym pomysłem przekazywanie danych z jednej akcji do drugiej przy użyciu adresu URL. To sprawia, że trudno jest zabezpieczyć aplikację. Bezpieczniej jest przechowywać dane w sesji.</p><h4>Umiędzynarodowienie</h4><p>Kod może zawierać sztywne ciągi znakowe, takie jak "Jak masz na imię?". Powinno się być w stanie dostosować ciągi znakowe bez edytowania kodu a w szczególności wstawić tłumaczenia dla różnych wersji językowych. W ten sposób, jeśli odwiedzający ma ustawiony w przeglądarce preferowany język, na przykład na   "włoski", to web2py zastosuje włoskie tłumacze ciągów znakowych, jeśli jest ono dostępne. Ta funkcjonalność web2py nosi nazwę "umiędzynarodowienia" i jest szczegółowo opisana w następnym rozdziale.</p><p>Tutaj po prostu widzimy, że w celu użycia tej funkcjonalności trzeba oznaczyć ciąg znaków, który wymaga tłumaczenia. Odbywa się to przez opakowanie cytowanego ciągu znaków, taki jak ten:</p><pre><code class="code">"Jak masz na imię?"</code></pre><p>w operator <code>T</code>:</p><pre><code class="code">T("Jak masz na imię?")</code></pre><p>Można również oznakować do tłumaczenia sztywny ciąg znakowy w widokach. Na przykład</p><pre><code class="code">&lt;h1&gt;Jam masz na imie?&lt;/h1&gt;</code></pre><p>zmienić na:</p><pre><code class="code">&lt;h1&gt;{{=T("Jak masz na imię?")}}&lt;/h1&gt;</code></pre><p>Dobrą praktyką jest robić to dla każdego ciągu znakowego w kodzie (etykiet pól, komunikatów fleszowych itd.) z wyjątkiem tabel i nazw pól.</p><p>Po tym jak ciągi zostaną zidentyfikowane i oznaczone, web2py zajmie się prawie wszystkim. Interfejs administracyjny dostarcza również stronę, na której można przetłumaczyć każdy ciąg znakowy na języki, które chce się obsługiwać.</p><blockquote>Platforma web2py zawiera również zaawansowany motor liczby mnogiej, opisany
w następnym rozdziale. Jest on zintegrowany zarówno z motorem umiędzynarodowienia
jak i z renderowaniem markmin.</blockquote><h3>Blog fotograficzny</h3><div class="inxx">przysyłanie plików</div><p>Tutaj, jako kolejny przykład, utworzymy aplikację internetową, która umożliwia administratorowi zamieszczanie zdjęć i nadawanie im nazwy oraz umożliwia odwiedzającym oglądanie obrazów z nazwami i komentowanie wpisów.</p><p>Tak jak poprzednio, z poziomu strony głównej (<em>site</em>) w interfejsie administracyjnym, utwórzmy nową aplikację o nazwie <strong>images</strong> i przejdźmy do strony <em>Edycja aplikacji</em>:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl1900.png" alt="image" style="width:480px" /></p></p><p>Rozpocznijmy od utworzenia modelu, reprezentacji trwałych danych w aplikacji (załadowane pliki zdjęć, ich nazwy i komentarze). Po pierwsze, trzeba utworzyć i edytować plik modelu, który z braku wyobraźni, nazwiemy "db.py". Zakładamy, że nowy kod zastąpi całkowicie istniejący kod w "db.py". Modele i kontrolery muszą mieć rozszerzenie <code>.py</code> ponieważ zawierają kod Pythona. Jeśli rozszerzenie nie zostanie podane, to zostanie dodane przez web2py. Widoki natomiast maja rozszerzenie <code>.html</code>, gdyż zawierają kod HTML.</p><p>Edytuj plik "db.py" klikając na odpowiedni przycisk:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2000.png" alt="image" style="width:480px" /></p></p><p>i wprowadź następujący kod:</p><p><div class="inxx">IS_EMAIL</div> <div class="inxx">IS_NOT_EMPTY</div> <div class="inxx">IS_IN_DB</div></p><pre><code class="code">db = DAL("sqlite://storage.sqlite")

db.define_table('image',
   Field('title', unique=True),
   Field('file', 'upload'),
   format = '%(title)s')

db.define_table('post',
   Field('image_id', 'reference image'),
   Field('author'),
   Field('email'),
   Field('body', 'text'))

db.image.title.requires = IS_NOT_IN_DB(db, db.image.title)
db.post.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
db.post.author.requires = IS_NOT_EMPTY()
db.post.email.requires = IS_EMAIL()
db.post.body.requires = IS_NOT_EMPTY()

db.post.image_id.writable = db.post.image_id.readable = False</code></pre><p>Przeanalizujmy ten kod linia po linii.</p><p>Linia 1 definiuje zmienną o nazwie <code>db</code>, która reprezentuje połączenie z bazą danych. W tym przypadku jest to połączenie z bazą danych SQLite zlokalizowaną w pliku "applications/images/databases/storage.sqlite". Podczas korzystania z bazy danych SQLite, jeśli plik bazy danych nie istnieje, to zostanie utworzony. Można zmienić nazwę pliku, jak również nazwę zmiennej globalnej <code>db</code>, ale konwencją jest nadawanie tej samej nazwy zmiennej co bazie danych – łatwiej się to pamięta.</p><p>Linie 3-6 definiują tabelę "image". <code>define_table</code> jest metodą obiektu <code>db</code>. Pierwszy argument, "image", jest nazwą tabeli, która definiujemy. Pozostałe argumenty definiują pola należące do tabeli. Tabela ta ma pola o nazwach "title", "file" i "id". Pole "id" ma przypisany klucz podstawowy ("id" nie jest deklarowane jawnie, ponieważ wszystkie tabele mają domyślnie pole id). Pole "title" jest typu łańcuchowego (string) a pole "file" jest typu "upload". Typ "upload" jest specjalnym typem pola używanym w web2py przez warstwę abstrakcji bazy danych (DAL) do przechowywania nazw załadowanych plików. Platforma web2py wie jak ładować pliki (poprzez strumieniowanie jeśli są duże), zmieniać ich nazwę w celach bezpieczeństwa i przechowywać je.</p><p>Gdy tabela jest zdefiniowana, web2py podejmuje jedną z kilku możliwych akcji:</p><ul><li>jeśli tabela nie istnieje, to jest tworzona;</li><li>jeśli tabela istnieje ale nie zgadza się z definicją, to tabela jest zmieniana zgodnie z definicją, a jeżeli jakieś pole jest innego typu niż określono to w definicji, to web2py próbuje przekształcić dane w tym polu;</li><li>jeśli tabela istnieje i zgadza się z definicja, web2py nic nie robi.</li></ul><p>To zachowanie nazywa się "migracją". W web2py migracje są automatyczne, ale mogą zostać wyłączone dla poszczególnych tabel przez przekazanie <code>migrate=False</code> jako ostatniego argumentu <code>define_table</code>.</p><p>Linia 6 definiuje ciąg formatowy dla tabeli. Ciąg ten określa, jak powinien być reprezentowany rekord jako ciąg znakowy. Proszę zwrócić uwagę, że argument <code>format</code> może być  również funkcją pobierającą rekord i zwracającą ciąg znakowy. Na przykład:</p><pre><code class="code">format=lambda row: row.title</code></pre><p>Linie 8-12 definiują inną tabelę o nazwie "post". Tabela post ma pola "author" i "email" (mamy zamiar zapisać adres email autora wpisu), "body" typu "text" (mamy zamiar użyć go do zapisywania aktualnego komentarza wpisanego przez autora) i pole "image_id" typu odniesienie, które wskazuje <code>db.image</code> poprzez pole "id".</p><p>W linii 14 <code>db.image.title</code> reprezentuje pole "title" tabeli "image". Atrybut <code>requires</code> umożliwia ustawienie wymagań i ograniczeń, które będą wymuszane przez formularz web2py. Tutaj wymagamy, aby "title" było obowiązkowe:</p><code class="code">IS_NOT_IN_DB(db, db.image.title)</code><p><em>Proszę zauważyć, że jest to opcjonalne, ponieważ jest ustawione automatycznie gdyż <code>Field('title', unique=True)</code></em>.</p><p>Obiekty reprezentujące te ograniczenia nazywane są walidatorami. Można grupować walidatory na liście. Walidatory są wykonywane w kolejności ich występowania. Walidator <code>IS_NOT_IN_DB(a, b)</code> to specjalny walidator, który sprawdza czy wartość pola <code>b</code> dla nowego rekordu nie jest już w <code>a</code>.</p><p>Linia 15 wymaga, aby pole "image_id" tabeli "post" było w <code>db.image.id</code>. O ile chodzi o bazę danych, już deklarowaliśmy to podczas definiowania tabeli "post". Teraz wyraźnie powiadamiamy model, że ten warunek powinien być egzekwowany przez web2py także na poziomie przetwarzania formularza gdy wysyłany jest nowy komentarz, tak więc nieprawidłowa wartość nie jest wprowadzana z pola wejściowego formularza do bazy danych. Wymagamy również, aby "image_id" było reprezentowane przez "title", <code>'%(title)s'</code> odpowiedniego rekordu.</p><p>Linia 20 wskazuje, że pole "image_id" tabeli "post" nie powinno być pokazywane w formularzu, ani jako pole mogące być zapisywanym (<code>writable=False</code>) i ani jako pole mogące być odczytywanym (<code>readable=False</code>).</p><p>Znaczenie walidatorów w liniach 17-18 powinno być oczywiste.</p><div class="inxx">format</div><p>Proszę zauważyć, że walidator</p><pre><code class="code">db.post.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')</code></pre><p>można pominąć (będzie ustawiany automatycznie) jeśli określimy format dla wskazanej tabeli:</p><pre><code class="code">db.define_table('image', ..., format='%(title)s')</code></pre><p>gdzie format może być ciągiem znakowym lub funkcją, która pobiera rekord i zwraca ciąg znakowy.</p><div class="inxx">appadmin</div><p>Gdy model jest zdefiniowany, jeśli nie ma błędów, web2py tworzy interfejs administracyjny aplikacji do zarządzania bazą danych. Można uzyskać do niego dostęp poprzez odnośnik "administracja bazą danych" na stronie <em>Edycja aplikacji</em> lub bezpośrednio:</p><pre><code class="code">http://127.0.0.1:8000/images/appadmin</code></pre><p>Oto zrzut ekranu z widokiem interfejsu <strong>appadmin</strong>:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2100.png" alt="image" style="width:480px" /></p></p><p>Interfejs ten jest zakodowany w kontrolerze o nazwie "appadmin.py" i odpowiadającym mu widoku "appadmin.html". Od teraz będziemy odnosić się do tego interfejsu po prostu jako do <strong>appadmin</strong>. Pozwala on administratorowi wstawić nowe rekordy do bazy danych, edytować i usuwać istniejące rekordy, przeglądać tabele i dokonywać złączeń w bazie danych.</p><p>Przy pierwszym dostępie do interfejsu <strong>appadmin</strong> wykonywany jest model i tworzone są tabele bazy danych. DAL web2py tłumaczy kod Pythona na wyrażenia SQL, które są specyficzne dla wybranego typu bazy danych (w naszym przykładzie SQLite). Można również generować SQL z poziomu strony <em>Edycja aplikacji</em> klikając na odnośnik "sql.log" w grupie "models". Trzeba pamiętać, że ten odnośnik nie jest dostępny dopóki nie zostaną utworzone tabele.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2200.png" alt="image" style="width:480px" /></p></p><p>Jeśli model został ponownie edytowany i dokonamy dostępu do <strong>appadmin</strong>, web2py wygeneruje SQL do zmiany istniejących tabel. Generowany SQL jest rejestrowany w pliku "sql.log".</p><p>Teraz powróćmy do <strong>appadmin</strong> i spróbujmy wstawić nowy rekord obrazu:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2300.png" alt="image" style="width:480px" /></p></p><p>Kod web2py transformuje pole "upload" tabeli <code>db.image.file</code> na formularz pobierania dla określonego pliku. Po wysłaniu formularza i przesłaniu pliku, zmieniana jest nazwa pliku, w bezpieczny sposób, zachowując dotychczasowe rozszerzenie. Plik ten zapisywany jest z nową nazwą w folderze "uploads" i ta nowa nazwa jest zapisywana w polu <code>db.image.file</code>. Proces ten ma na celu zapobieżenie atakom typu <em>directory traversal</em>.</p><p>Trzeba pamiętać, że każdy typ pola jest renderowany przez <em>widżet</em>. Domyślne widżety można przesłaniać.</p><p>Po kliknięciu na nazwę tabeli w <strong>appadmin</strong>, web2py wykona instrukcję <code>select</code> na wszystkich rekordach bieżącej tabeli, pokreślonych w zapytaniu DAL</p><pre><code class="code">db.image.id &gt; 0</code></pre><p>i wyrenderuje wynik.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2400.png" alt="image" style="width:480px" /></p></p><p>Można wybrać inny zestaw rekordów edytując zapytanie DAL i wciskając przycisk [Submit].</p><p>Aby edytować lub skasować pojedynczy rekord, wystarczy kliknąć na numer id rekordu.</p><p>Ponieważ walidator <code>IS_IN_DB</code> odwołuje się do pola "image_id", jest to wykorzystywane do renderowania rozwijanego menu. Pozycje rozwijanej listy są przechowywane jako klucze (<code>db.image.id</code>), ale są reprezentowane przez wartość <code>db.image.title</code>, w sposób określony przez walidator.</p><p>Walidatory są zaawansowanymi obiektami, które wiedzą jak reprezentować pola, filtrować wartości pól, generować błędy i formatować wartości wyekstrahowane z pól.</p><p>Poniższy rysunek pokazuje, co się dzieje, gdy formularz nie przechodzi walidacji:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2500.png" alt="image" style="width:480px" /></p></p><p>Ten sam formularz, który jest generowany automatycznie przez <strong>appadmin</strong> może również być generowany programowo przez helper <code>SQLFORM</code> i osadzany w aplikacjach. Formularze te są przyjazne dla CSS i mogą być dostosowywane.</p><p>Każda aplikacja ma swój własny interfejs <strong>appadmin</strong>. Dlatego można modyfikować <strong>appadmin</strong> bez wpływu na inne aplikacje.</p><p>Dotychczas poznaliśmy, jak aplikacja przechowuje dane i zobaczyliśmy, jak uzyskać dostęp do bazy danych poprzez interfejs <strong>appadmin</strong>. Dostęp do <strong>appadmin</strong> jest zastrzeżony tylko dla administratora, ale nie jest to internetowy interfejs produkcyjny aplikacji – stąd następna część naszego działania. W szczególności potrzebujemy:</p><ul><li>Stronę "index", która wykazuje wszystkie dostępne obrazy posortowane według tytułu i odnośniki do stron poszczeglnych obrazów.</li><li>Stronę "show/[id]", która wyświetla żądany obraz i umożliwia odwiedzającemu oglądać i wprowadzać komentarze.</li><li>Akcję "download/[name]" do pobierania przesyłanych obrazów.</li></ul><p>Przedstawiono to schematycznie tutaj:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2600.png" alt="yUML diagram" style="width:480px" /></p></p><p>Powróć do strony <em>Edycja aplikacji</em> i edytuj kontroler "default.py", zamieniając jego zawartość na to:</p><div class="inxx">select</div><pre><code class="code">def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)</code></pre><p>Akcja ta zwraca słownik. Klucze elementów słownika są interpretowane jak zmienne przekazywane do widoku związanego z akcją. W czasie programowania, jeśli brakuje takiego widoku, to akcja jest renderowana przez widok "generic.html", który dostarczany jest przez aplikację web2py.</p><p>Akcja index wykonuje instrukcję select wszystkich pól (<code>db.image.ALL</code>) z tabeli image, sortując według pola <code>db.image.title</code>. Wynikiem instrukcji select jest obiekt <code>Rows</code> zawierający rekordy. Przypisujemy go do zmiennej o nazwie <code>images</code> zwracanej przez akcję do widoku. Zmienna <code>images</code>  jest iterowalna i jej elementy są wybranymi wierszami. Dla każdego wiersza kolumny elementy te mogą być dostępne jako słowniki: <code>images[0]['title']</code> lub równoważnie jako <code>images[0].title</code>.</p><p>Jeśli nie napisze się widoku, słownik będzie renderowany przez widok "views/generic.html" a wywołanie akcji index wyglądać będzie tak:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2700.png" alt="image" style="width:480px" /></p></p><p>Nie stworzyliśmy jeszcze widoku dla tej akcji, więc web2py renderuje zestaw rekordów jako zwykły formularz tabelaryczny.</p><p>Przystąpmy do utworzenia widoku dla akcji index. Powróć do interfejsu admin, edytuj "default/index.html" i wymień istniejąca zawartość na tą:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Bieżący obraz&lt;/h1&gt;
&lt;ul&gt;
{{for image in images:}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
&lt;/ul&gt;</code></pre><p>Pierwszą rzeczą, która zauważamy, jest to, że widok jest czystym HTML ze specjalnymi znacznikami <code>{{...}}</code>. Kod osadzony w znacznikach <code>{{...}}</code> jest czystym kodem Pythona z jednym zastrzeżeniem: wcięcia nie mają znaczenia. Bloki kodu rozpoczynają się liniami zakończonymi dwukropkiem (:) a kończą liniami ze słowem kluczowym <code>pass</code>. W pewnych przypadkach koniec bloku jest oczywisty i użycie słowa <code>pass</code> nie jest wymagane.</p><p>Linie 5-7 wykonują pętlę na wierszach <code>images</code> i dla każdego wiersza wyświetlają <code>image</code>:</p><pre><code class="code">LI(A(image.title, _href=URL('show', args=image.id))</code></pre><p>Jest to znacznik <code>&lt;li&gt;...&lt;/li&gt;</code> zawierający znacznik <code>&lt;a href="..."&gt;...&lt;/a&gt;</code>, który z kolei zawiera wartość <code>image.title</code>. Wartością odniesienia hipertekstowego (atrybutu <code>href</code>) jest:</p><pre><code class="code">URL('show', args=image.id)</code></pre><p>tj. adres URL w tej samej aplikacji i kontroler jako bieżące żądanie wywołujące funkcję o nazwie "show". Funkcja ta przekazuje pojedynczy argument <code>args=image.id</code> do funkcji URL. Obiekty <code>LI</code>, <code>A</code> itd. są helperami odwzorowującymi odpowiednie znaczniki HTML. Ich nienazwane argumenty są interpretowane jako obiekty do serializacji i osadzenia w innerHTML znacznika. Nazwane argumenty rozpoczynające się znakiem pokreślenia (na przykład <code>_href</code>) są interpretowane jako atrybuty znacznika, ale bez znaku podkreślenia. Na przyklad <code>_href</code> jest atrybutem <code>href</code>, <code>_class</code> jest atrybutem <code>class</code> itd.</p><p>Dla przykładu, następujące wyrażenie:</p><pre><code class="code">{{=LI(A('coś tam', _href=URL('show', args=123))}}</code></pre><p>jest renderowane jako:</p><pre><code class="code">&lt;li&gt;&lt;a href="/images/default/show/123"&gt;coś tam&lt;/a&gt;&lt;/li&gt;</code></pre><p>Kilka helperów (<code>INPUT</code>, <code>TEXTAREA</code>, <code>OPTION</code> i <code>SELECT</code>) obsługuje również kilka specjalnych nazwanych atrybutów nie rozpoczynających się znakiem podkreślenia (<code>value</code> i <code>requires</code>). Są one ważne dla budowania własnych formularzy i zostaną omówione dalej.</p><p>Powróćmy do strony <em>Edycja aplikacji</em>. Widzimy tam, że przy pliku <em>default.py</em> jest eksponowany odnośnik <em>index</em>. Klikając na <em>index</em> odwiedzisz nowo utworzoną stronę:</p><pre><code class="code">http://127.0.0.1:8000/images/default/index</code></pre><p>która wygląda podobnie do tego:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2800.png" alt="image" style="width:480px" /></p></p><p>Jeśli kliknie się na odnośnik z nazwą obrazu, zostanie sie przekierowanym do:</p><pre><code class="code">http://127.0.0.1:8000/images/default/show/1</code></pre><p>i w rezultacie otrzyma się błąd, ponieważ nie została utworzona akcja o nazwie "show" w kontrolerze "default.py".</p><p>Edytujmy kontroler "default.py" i zastąpmy jego zawartość na to:</p><p><div class="inxx">SQLFORM</div> <div class="inxx">accepts</div> <div class="inxx">response.flash</div> <div class="inxx">request.args</div></p><div class="inxx">response.download</div><pre><code class="code">def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)

def show():
    image = db.image(request.args(0,cast=int)) or redirect(URL('index'))
    db.post.image_id.default = image.id
    form = SQLFORM(db.post)
    if form.process().accepted:
        response.flash = 'your comment is posted'
    comments = db(db.post.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)

def download():
    return response.download(request, db)</code></pre><p>Kontroler składa się z dwóch akcji: "show" i "download". Akcja "show" wybiera obraz z określonym <code>id</code> z argumentów żądania i wszystkie komentarze związane z obrazem. Następnie akcja "show" przekazuje to wszystko do widoku "default/show.html".</p><p>Do identyfikatora obrazu odwołujemy w "default/index.html" się przez:</p><pre><code class="code">URL('show', args=image.id)</code></pre><p>Może być on dostępny w akcji "show" jako <code>request.args(0,cast=int)</code>.</p><p>Argument <code>cast=int</code> jest opcjonalny, ale bardzo ważny. Próbuje on zrzucić wartość ciągu znakowego przekazanego w zmiennej PATH_INFO do liczby całkowitej. W przypadku błędu wywołać wyjątek zamiast powodować wystawienie biletu. Można również określić przekierowanie w przypadku braku zrzutu:</p><pre><code class="code">request.args(0,cast=int,otherwise=URL('error'))</code></pre><p>Ponadto <code>db.image(...)</code> jest skrótem dla</p><pre><code class="code">db(db.image.id==...).select().first()</code></pre><p>Akcja "download" oczekuje nazwy pliku w <code>request.args(0)</code>, buduje  ścieżkę do lokalizacji w której ma być plik i odsyła ją z powrotem do klienta. Jeśli plik jest za duży, to następuje jego strumieniowanie, bez żadnego narzutu pamięci.</p><p>Przyjrzyjmy się następującym wyrażeniom:</p><ul><li>Linia 7 ustawia wartość dla przywoływanego pola, które nie jest częścią pola wejściowego w formularzu, gdyż nie jest na liście pól określonych powyżej.</li><li>Linia 8 tworzy formularz wstawiania SQLFORM dla tabeli <code>db.post</code> wykorzystując tylko określone pola.</li><li>Linia 9 przetwarza wysłany formularz (zmienne wysłanego formularza znajdują się w <code>request.vars</code>) w bieżącej sesji (sesja jest wykorzystywana do zapobieżenia podwójnemu zgłoszeniu i wymuszeniu nawigacji). Jeśli zmienne zgłoszonego formularza są poprawne, to do tabeli <code>db.post</code> wstawiany jest nowy komentarz. W przeciwnym wypadku formularz jest modyfikowany w celu wyświetlenia komunikatów błędów (na przykład, jeśli adres email autora jest nieprawidłowy). To wszystko odbywa się w linii 9!.</li><li>Linia 10 jest wykonywana tylko wtedy, gdy formularz jest akceptowany, po tym jak rekord zostanie wstawiony do tabeli bazy danych. <code>response.flash</code> jest zmienną web2py, która jest wyświetlana w widokach i wykorzystywana jest do powiadamiania odwiedzającego o tym co się stało.</li><li>Linia 11 wybiera wszystkie komentarze, które odwołują się do bieżącego obrazu.</li></ul><blockquote>Akcja "download" jest już zdefiniowana w kontrolerze "default.py" aplikacji szkieletowej.</blockquote><p>Akcja "download" nie zwraca słownika, więc nie potrzeba tworzyć widoku. Akcja "show" jednak powinna mieć widok, więc powróć do <strong>admin</strong> i utwórz nowy widok o nazwie "default/show.html".</p><p>Edytuj tej nowy plik i wymień jego zwartość na następującą:</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Obraz: {{=image.title}}&lt;/h1&gt;
&lt;center&gt;
&lt;img width="200px"
     src="{{=URL('download', args=image.file)}}" /&gt;
&lt;/center&gt;
{{if len(comments):}}
  &lt;h2&gt;Komentarze&lt;/h2&gt;&lt;br /&gt;&lt;p&gt;
  {{for post in comments:}}
    &lt;p&gt;{{=post.author}} says &lt;i&gt;{{=post.body}}&lt;/i&gt;&lt;/p&gt;
  {{pass}}&lt;/p&gt;
{{else:}}
  &lt;h2&gt;Nie ma jeszcze żadnego komentarza&lt;/h2&gt;
{{pass}}
&lt;h2&gt;Skomentuj&lt;/h2&gt;
{{=form}}</code></pre><p>Widok ten wyświetla <strong>image.file</strong> przez wywołanie akcji "download" wewnątrz znacznika <code>&lt;img ... /&gt;</code>. Jeśli są jakieś komentarze, to wykonywana jest na nich pętla i wyświetlany jest każdy z nich.</p><p>Oto jak to wszystko pojawi się odwiedzającemu.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl2900.png" alt="image" style="width:480px" /></p></p><p>Gdy użytkownik wysyła komentarz ze strony, to komentarz jest zapisywany do bazy danych i dołącza go w dole strony.</p><h4>Dodawanie uwierzytelniania</h4><p>API web2py dla kontroli dostępu opartej na rolach jest dość skomplikowane, ale na razie zajmiemy się tylko ograniczeniem dostępu do akcji show dla uwierzytelnionych użytkowników, odraczając szczegółowsze omówienie tego tematu do rozdziału 9.</p><p>Aby ograniczyć dostęp do użytkowników uwierzytelnionych, musimy wykonać trzy kroki. W modelu, na przykład w "db.py", musimy dodać:</p><pre><code class="code">from gluon.tools import Auth
auth = Auth(db)
auth.define_tables(username=True)</code></pre><p>W naszym kontrolerze musimy dodać jedną akcję:</p><pre><code class="code">def user():
    return dict(form=auth())</code></pre><p>Jest to wystarczające do udostępniania logowania, rejestracji i wylogowania na stronach. Domyślny układ wyświetla także odpowiednie opcje w prawym górnym rogu strony.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3000.png" alt="image" style="width:300px" /></p></p><p>Teraz możemy udekorować funkcje, które chcemy ograniczyć, na przykład:</p><pre><code class="code">@auth.requires_login()
def show():
    ...</code></pre><p>Każda próba dostępu</p><pre><code class="code">http://127.0.0.1:8000/images/default/show/[image_id]</code></pre><p>będzie wymagała logowania. Jeżeli użytkownik nie jest zalogowany, to zostanie przekierowany do</p><pre><code class="code">http://127.0.0.1:8000/images/default/user/login</code></pre><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3100.png" alt="image" style="width:480px" /></p></p><p>Funkcja <code>user</code> udostępnia między innymi następujące akcje:</p><pre><code class="code">http://127.0.0.1:8000/images/default/user/logout
http://127.0.0.1:8000/images/default/user/register
http://127.0.0.1:8000/images/default/user/profile
http://127.0.0.1:8000/images/default/user/change_password
http://127.0.0.1:8000/images/default/user/request_reset_password
http://127.0.0.1:8000/images/default/user/retrieve_username
http://127.0.0.1:8000/images/default/user/retrieve_password
http://127.0.0.1:8000/images/default/user/verify_email
http://127.0.0.1:8000/images/default/user/impersonate
http://127.0.0.1:8000/images/default/user/not_authorized</code></pre><p>Teraz, za pierwszym razem użytkownik musi się zarejestrować, aby móc się zalogować i czytać komentarze.</p><blockquote>Zarówno obiekt <code>auth</code> jak i funkcja <code>user</code> są już zdefiniowane w aplikacji
szkieletowej. Obiekt <code>auth</code> jest wysoce konfigurowalny i może sobie radzić z
weryfikacją email, zezwoleniami rejestracyjnymi, CAPTCHA i alternatywnymi metodami
logowania poprzez wtyczki.</blockquote><h4>Dodawanie siatki</h4><p>Możemy poprawić stworzoną funkcjonalność wykorzystując gadżety <code>SQLFORM.grid</code> i <code>SQLFORM.smartgrid</code>, tworząc w ten sposób interfejs zarządzania dla naszej aplikacji. W kontrolerze default.py dodaj:</p><pre><code class="code">@auth.requires_membership('manager')
def manage():
    grid = SQLFORM.smartgrid(db.image,linked_tables=['post'])
    return dict(grid=grid)</code></pre><p>a w odpowiednim dla tej akcji widoku "views/default/manage.html":</p><pre><code>{{extend 'layout.html'}}
&lt;h2&gt;Interfejs zarządznia&lt;/h2&gt;
{{=grid}}</code></pre><p>Korzystając z appadmin utwórz grupę "manager" i dodaj jakichś członków tej grupy. Będą oni mogli uzyskiwać dostęp</p><pre><code>http://127.0.0.1:8000/images/default/manage</code></pre><p>oraz przeglądać i wyszukiwać:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3200.png" alt="image" style="width:480px" /></p></p><p>tworzyć, aktualizować i usuwać obrazy i ich komentarze:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3300.png" alt="image" style="width:480px" /></p></p><h4>Konfigurowanie układu</h4><p>Można skonfigurować domyślny układ edytując "views/layout.html" ale można skonfigurować go również bez edytowania kodu HTML. W rzeczywistości arkusz stylów "static/base.css" jest bardzo dobrze udokumentowany i opisany w rozdziale 5. Można zmienić kolor, kolumny, wielkość, obramowania i tło bez edytowania kodu HTML. Jeśli chce się edytować menu, tytuł lub podtytuł, można to zrobić w dowolnym pliku modelu. Aplikacja szkieletowa ustawia domyślne wartości tych parametrów w pliku "models/menu.py":</p><pre><code class="code">response.title = request.application
response.subtitle = 'dcustomize me!'
response.meta.author = 'you'
response.meta.description = 'describe your app'
response.meta.keywords = 'bla bla bla'
response.menu = [ [ 'Index', False, URL('index') ] ]</code></pre><h3>Proste wiki</h3><p><div class="inxx">wiki</div> <div class="inxx">RSS</div> <div class="inxx">Ajax</div> <div class="inxx">XMLRPC</div></p><p>W tym rozdziale zbudujemy od podstaw proste wiki wykorzystując tylko interfejsy API niskiego poziomu (w przeciwieństwie do wykorzystywania wbudowanej w web2py funkcjonalności wiki zademonstrowanej w następnym rozdziale). Odwiedzający będzie mógł tworzyć strony, przeszukiwać (wg tytułu) i edytować je. Odwiedzający będzie również mógł wprowadzać komentarze (dokładnie tak, jak w poprzedniej aplikacji) oraz wprowadzać dokumenty (jako załączniki do stron) i linkować je ze stronami. Dla składni naszego wiki, zgodnie z konwencją, adaptujemy składnię Markmin. Wdrożymy również stronę wyszukiwania w Ajax, kanał RSS dla stron i obsługę przeszukiwania stron poprzez XML-RPC<sup>[<a href="/book/default/reference/42/xmlrpc" target="_blank">xmlrpc</a>]</sup> . Poniższy diagram zawiera listę akcji, które musimy zaimplementować i odnośniki jakie zamierzamy w nie wbudować.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3400.png" alt="yUML diagram" style="width:200px" /></p></p><p>Rozpocznijmy od utworzenia nowego szkieletu aplikacji o nazwie "mywiki".</p><p>Model musi zawierać trzy tabele: page, comment i document. Zarówno comment jak i document odwołują się do page, ponieważ należą do strony. Tabela document zawiera pole file typu upload, tak jak w poprzedniej aplikacji images.</p><p>Oto kompletny model:</p><pre><code class="code">db = DAL('sqlite://storage.sqlite')

from gluon.tools import *
auth = Auth(db)
auth.define_tables()
crud = Crud(db)

db.define_table('page',
    Field('title'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id),
    format='%(title)s')

db.define_table('post',
    Field('page_id', 'reference page'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id))

db.define_table('document',
    Field('page_id', 'reference page'),
    Field('name'),
    Field('file', 'upload'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id),
    format='%(name)s')

db.page.title.requires = IS_NOT_IN_DB(db, 'page.title')
db.page.body.requires = IS_NOT_EMPTY()
db.page.created_by.readable = db.page.created_by.writable = False
db.page.created_on.readable = db.page.created_on.writable = False

db.post.body.requires = IS_NOT_EMPTY()
db.post.page_id.readable = db.post.page_id.writable = False
db.post.created_by.readable = db.post.created_by.writable = False
db.post.created_on.readable = db.post.created_on.writable = False

db.document.name.requires = IS_NOT_IN_DB(db, 'document.name')
db.document.page_id.readable = db.document.page_id.writable = False
db.document.created_by.readable = db.document.created_by.writable = False
db.document.created_on.readable = db.document.created_on.writable = False</code></pre><p>Edytuj kontroler "default.py" i stwórz następujące akcje:</p><ul><li>index: wykazuje wszystkie strony wiki</li><li>create: dodawanie nowej strony wiki</li><li>show: wyświetla stronę wiki i jej komentarze oraz umożliwia dodawanie nowych komentarzy</li><li>edit: edytowanie istniejącej strony</li><li>documents: zarządzanie dokumentami załączonymi do strony</li><li>download: pobiera dokument (tak jak w przykładzie images)</li><li>search: wyświetla okno wyszukiwania i poprzez wywołanie zwrotne Ajax zwraca wszystkie dopasowane tytuły jakie wpisał odwiedzający</li><li>callback: funkcja wywołania zwrotnego Ajax. Zwraca kod HTML, który zostaje osadzony na stronie wyszukiwania podczas wpisywania przez odwiedzającego.</li></ul><p>Oto kontroler "default.py":</p><pre><code class="code">def index():
     """ this controller returns a dictionary rendered by the view
         it lists all wiki pages
     &gt;&gt;&gt; index().has_key('pages')
     True
     """
     pages = db().select(db.page.id,db.page.title,orderby=db.page.title)
     return dict(pages=pages)

@auth.requires_login()
def create():
     """creates a new empty wiki page"""
     form = SQLFORM(db.page).process(next=URL('index'))
     return dict(form=form)

def show():
     """shows a wiki page"""
     this_page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     db.post.page_id.default = this_page.id
     form = SQLFORM(db.post).process() if auth.user else None
     pagecomments = db(db.post.page_id==this_page.id).select()
     return dict(page=this_page, comments=pagecomments, form=form)

@auth.requires_login()
def edit():
     """edit an existing wiki page"""
     this_page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     form = SQLFORM(db.page, this_page).process(
         next = URL('show',args=request.args))
     return dict(form=form)

@auth.requires_login()
def documents():
     """browser, edit all documents attached to a certain page"""
     page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     db.document.page_id.default = page.id
     db.document.page_id.writable = False
     grid = SQLFORM.grid(db.document.page_id==page.id,args=[page.id])
     return dict(page=page, grid=grid)

def user():
     return dict(form=auth())

def download():
     """allows downloading of documents"""
     return response.download(request, db)

def search():
     """an ajax wiki search page"""
     return dict(form=FORM(INPUT(_id='keyword',_name='keyword',
              _onkeyup="ajax('callback', ['keyword'], 'target');")),
              target_div=DIV(_id='target'))

def callback():
     """an ajax callback that returns a &lt;ul&gt; of links to wiki pages"""
     query = db.page.title.contains(request.vars.keyword)
     pages = db(query).select(orderby=db.page.title)
     links = [A(p.title, _href=URL('show',args=p.id)) for p in pages]
     return UL(*links)</code></pre><p>Linie 2-6 stanowią komentarz dla akcji index. Linie 4-5 wewnątrz komentarza są interpretowane przez Python jako kod testowy (doctest). Testy mogą być uruchamiane poprzez interfejs administracyjny. W tym przypadku testy weryfikują, czy akcja index uruchamia się bez błędów.</p><p>Linie 18, 27 i 35 próbują pobrać rekord <code>page</code> o określonym id z <code>request.args(0)</code>.</p><p>Linie 13, 20 definiują i przetwarzają tworzony formularz dla nowej strony i nowego komentarza, natomiast</p><p>linia 28 definiuje i przetwarza zaktualizowany formularz dla strony wiki.</p><p>Linia 38 tworzy obiekt <code>grid</code>, który umożliwia przeglądanie, dodawanie i aktualizowanie komentarzy powiązanych ze stroną.</p><p>W linii 51 dzieje się jakaś magia. Ustawiany jest atrybut <code>onkeyup</code> w znaczniku INPUT o id "keyword". Za każdym razem, jak odwiedzający zwolni klawisz podczas wypełniania pola, wykonywany jest kod JavaScript wewnątrz atrybutu <code>onkeyup</code> po stronie klienta. Oto ten kod JavaScript:</p><pre><code class="code">ajax('callback', ['keyword'], 'target');</code></pre><p><code>ajax</code> jest funkcją JavaScript zdefiniowana w pliku "web2py.js", który jest domyślnie dołączany przez "layout.html". Pobiera on trzy parametry: adres URL akcji wykonującej synchroniczne wywołanie zwrotne, listę identyfikatorów ID zmiennych, które mają być przesłane w wywołaniu zwrotnym (["keyword"]) i identyfikator ID dla którego odpowiedź ma być osadzona ("target").</p><p>Jak tylko wpiszesz coś w polu wyszukiwania i zwolnisz klawisz, klient wywołuje serwer i przesyła zawartość pola 'keyword' i gdy serwer odpowie, odpowiedź jest osadzana na tej samej stronie jako innerHTML znacznika 'target'.</p><p>Znacznik 'target' jest elementem DIV zdefiniowanym w linii 52. Można to równie dobrze zdefiniować w widoku.</p><p>Oto kod dla widoku "default/create.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Tworzenie nowej strony wiki&lt;/h1&gt;
{{=form}}</code></pre><p>Po zarejestrowaniu się i zalogowaniu, jeśli odwiedzisz stronę <strong>create</strong>, zobaczysz następujący ekran:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3500.png" alt="image" style="width:480px" /></p></p><p>Oto kod widoku "default/index.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Dostępne strony wiki&lt;/h1&gt;
[ {{=A('search', _href=URL('search'))}} ]&lt;br /&gt;
&lt;ul&gt;{{for page in pages:}}
     {{=LI(A(page.title, _href=URL('show', args=page.id)))}}
{{pass}}&lt;/ul&gt;
[ {{=A('create page', _href=URL('create'))}} ]</code></pre><p>Generuje on następująca stronę:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3600.png" alt="image" style="width:480px" /></p></p><p>Oto kod dla widoku "default/show.html":</p><p><div class="inxx">markdown</div> <div class="inxx">MARKMIN</div></p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;{{=page.title}}&lt;/h1&gt;
[ {{=A('edit', _href=URL('edit', args=request.args))}}
| {{=A('documents', _href=URL('documents', args=request.args))}} ]&lt;br /&gt;
{{=MARKMIN(page.body)}}
&lt;h2&gt;Komentarze&lt;/h2&gt;
{{for post in comments:}}
  &lt;p&gt;{{=db.auth_user[post.created_by].first_name}} on {{=post.created_on}}
     says &lt;i&gt;{{=post.body}}&lt;/i&gt;&lt;/p&gt;
{{pass}}
&lt;h2&gt;Wpis komentarza&lt;/h2&gt;
{{=form}}</code></pre><p>Jeśli chcesz użyć składni markdown zamiast składni markmin zaimportuj:</p><pre><code class="code">from gluon.contrib.markdown import WIKI as MARKDOWN</code></pre><p>i zastosuj helper <code>MARKDOWN</code> zamiast helpera <code>MARKMIN</code>. Alternatywnie można wybrać akceptowanie surowego HTML zamiast składni markmin. W takim przypadki zamień:</p><pre><code class="code">{{=MARKMIN(page.body)}}</code></pre><p>na:</p><pre><code class="code">{{=XML(page.body)}}</code></pre><div class="inxx">sanitize</div><p>(ale XML nie został tu zabezpieczony sekwencjami ucieczki, co web2py zwykle dokonuje tego domyślnie w celach bezpieczeństwa).</p><p>Można to zrobić lepiej:</p><pre><code class="code">{{=XML(page.body, sanitize=True)}}</code></pre><p>Ustawiając <code>sanitize=True</code> powiadamiamy web2py aby zabezpieczył niebezpieczne znaczniki XML znakami ucieczki, takie jak "&lt;script&gt;", a tym samym zabezpieczył kod przed atakami XSS.</p><p>Teraz jeśli z poziomu strony index kliknie się na tytuł strony, zobaczy się stronę, która została utworzona:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3700.png" alt="image" style="width:480px" /></p></p><p>Oto kod dla widoku "default/edit.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Edytuj stronę wiki&lt;/h1&gt;
[ {{=A('show', _href=URL('show', args=request.args))}} ]&lt;br /&gt;
{{=form}}</code></pre><p>Generuje to stronę wyglądającą niemal identycznie jak tworzona strona.</p><p>Oto kod dla widoku "default/documents.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Dokumenty dla strony: {{=page.title}}&lt;/h1&gt;
[ {{=A('show', _href=URL('show', args=request.args))}} ]&lt;br /&gt;
&lt;h2&gt;Dokumenty&lt;/h2&gt;
{{=grid}}</code></pre><p>Jeśli na stronie "show" kliknie się na dokumentach, będzie można teraz zarządzać dokumentami załączonymi do strony.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3800.png" alt="image" style="width:480px" /></p></p><p>Na koniec trzeba jeszcze wprowadzić kod dla widoku "default/search.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h1&gt;Wyszukiwanie na stronach wiki&lt;/h1&gt;
[ {{=A('listall', _href=URL('index'))}}]&lt;br /&gt;
{{=form}}&lt;br /&gt;{{=target_div}}</code></pre><p>który generuje następujący formularz Ajax:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl3900.png" alt="image" style="width:480px" /></p></p><p>Można również wypróbować bezpośrednio akcję callback odwiedzając, na przykład, następujący adres URL:</p><pre><code class="code">http://127.0.0.1:8000/mywiki/default/callback?keyword=wiki</code></pre><p>Jeśli spojrzysz na źródło strony, zobaczysz następpujący kod zwracany przez wywołanie zwrotne:</p><pre><code class="code">&lt;ul&gt;&lt;li&gt;&lt;a href="/mywiki/default/show/4"&gt;Wykonałem Wiki&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><div class="inxx">rss</div><p>Generowanie kanału RSS stron wiki przy użyciu web2py jest łatwe, ponieważ web2py zawiera <code>gluon.contrib.rss2</code>. Wystarczy dołączyć następującą akcję do domyślnego kontrolera:</p><pre><code class="code">def news():
    """generates rss feed from the wiki pages"""
    response.generic_patterns = ['.rss']
    pages = db().select(db.page.ALL, orderby=db.page.title)
    return dict(
       title = 'mywiki rss feed',
       link = 'http://127.0.0.1:8000/mywiki/default/index',
       description = 'mywiki news',
       created_on = request.now,
       items = [
          dict(title = row.title,
               link = URL('show', args=row.id, scheme=True, 
	                  host=True, extension=False),
               description = MARKMIN(row.body).xml(),
               created_on = row.created_on
               ) for row in pages])</code></pre><p>a kiedy odwiedzi się stronę</p><pre><code class="code">http://127.0.0.1:8000/mywiki/default/news.rss</code></pre><p>zobaczy się kanał RSS (wyjście zależy od czytnika). Proszę zwrócić uwagę, że słownik zostaje automatycznie przekształcany do RSS, dzięki rozszerzeniu .rss w adresie URL.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4000.png" alt="image" style="width:480px" /></p></p><p>web2py również zawiera parser kanałów informacyjnych do czytania kanałów z kodem firm trzecich.</p><p>Zwróćmy uwagę na linię:</p><pre><code class="code">response.generic_patterns = ['.rss']</code></pre><p>która instruuje web2py aby wykorzystał ogólny widok (w naszym przypadku"views/generic.rss"), gdy adres URL kończy się w globalnym wzorcu rozszerzeniem ".rss". Domyślnie, ogólne widoki dostępne są tylko z poziomu localhost dla celów programistycznych.</p><div class="inxx">XMLRPC</div><p>Na koniec, dodaj obsługę XML-RPC, która umożliwia przeszukiwanie wiki programowo:</p><pre><code class="code">service = Service()

@service.xmlrpc
def find_by(keyword):
     """finds pages that contain keyword for XML-RPC"""
     return db(db.page.title.contains(keyword)).select().as_list()

def call():
    """exposes all registered services, including XML-RPC"""
    return service()</code></pre><p>Tutaj akcja handlera po prostu publikuje (poprzez XML-RPC) funkcje określone na liście, w tym przypadku, <code>find_by</code>. Funkcja <code>find_by</code> nie jest akcją (ponieważ pobiera argument). Wysyła ona zapytanie do bazy danych z instrukcją <code>.select()</code>, a następnie ekstrahuje rekordy jako listę z <code>.response</code> i zwraca listę.</p><p>Oto przykład, jak uzyskać dostęp do obsługi XML-RPC z zewnętrznego programu Pythona.</p><pre><code class="code">&gt;&gt;&gt; import xmlrpclib
&gt;&gt;&gt; server = xmlrpclib.ServerProxy(
    'http://127.0.0.1:8000/mywiki/default/call/xmlrpc')
&gt;&gt;&gt; for item in server.find_by('wiki'):
        print item['created_on'], item['title']</code></pre><p>Handler może uzyskać dostęp z poziomu wielu języków programowania, które obsługują XML-RPC, w tym C, C++, C# i Java.</p><h4>O formatach <code>date</code>, <code>datetime</code> i <code>time</code></h4><p>Istnieją trzy różne reprezentacje dla każdego pola typu <code>date</code>, <code>datetime</code> i <code>time</code>:</p><ul><li>reprezentacja bazy danych,</li><li>wewnętrzna reprezentacja web2py,</li><li>reprezentacja łańcuchowa w formularzu i tabelach.</li></ul><p>Reprezentacja bazy danych jest sprawą wewnętrzną i nie wpływa na kod. Wewnętrznie, na poziomie web2py, są one przechowywane odpowiednio jako obiekty <code>datetime.date</code>, <code>datetime.datetime</code> i <code>datetime.time</code> i można nimi manipulować w ten sposób:</p><pre><code class="code">for page in db(db.page).select():
    print page.title, page.day, page.month, page.year</code></pre><p>Gdy daty są przekształcane do ciągów w formularzach,  to przekształcane są zgodnie reprezentacją ISO, <code>%Y-%m-%d %H:%M:%S</code>, ale reprezentacja ta jest internacjonalizowana i można wykorzystać stronę tłumaczeń w interfejsie administracyjnym w celu zmiany formatu danych. Na przykład, <code>%m/%d/%Y %H:%M:%S</code>.</p><p>Należy pamiętać, że domyślny język angielski nie jest tłumaczony, ponieważ web2py zakłada, że aplikacja jest pisana w języku angielskim. Jeśli chce się umiędzynarodowić aplikację do pracy z językiem angielskim, to trzeba utworzyć plik tłumaczenia (wykorzystując interfejs administracyjny) i trzeba zadeklarować, że bieżącym językiem aplikacji jest inny język niż angielski, na przykład:</p><pre><code>T.current_languages = ['null']</code></pre><h3>Wiki wbudowane w web2py</h3><p>Teraz możemy zapomnieć kod, który zbudowaliśmy w poprzednim rozdziale (nie to co dowiedzieliśmy się o interfejsach API web2py, ale kod specyficzny dla tego rozdziału) jako że przerobimy przykład wiki wbudowanego w web2py.</p><p>W rzeczywistości web2py dostarczany jest z funkcjonalnością wiki, łącznie z załącznikami multimedialnymi, tagami, chmurą tagów, uprawnieniami strony i obsługą formatu oembed<sup>[<a href="/book/default/reference/42/oembed" target="_blank">oembed</a>]</sup> i komponentów (rozdział 14). Ten kod wiki to może być stosowany z dowolną aplikacją web2py.</p><blockquote>Proszę mieć na względzie, że wbudowane wiki jest nadal uważane za eksperymentalne
i małe zmiany są możliwe.</blockquote><p>Tutaj zakładamy, że zaczynamy od zera, od prostego klonu aplikacji "welcome" o nazwie "wikidemo". Edytuj kontroler i wymień kod akcji "index" na następujący:</p><pre><code class="code">def index(): return auth.wiki()</code></pre><p>Gotowe! Masz w pełni funkcjonalne wiki. W tym momencie nie została jeszcze utworzona żadna strona i w tym celu konieczne jest zalogowanie się oraz członkostwo w grupie o nazwie "wiki_editor" lub "wiki_author". Jeśli jest się zalogowanym jako administrator, to grupa "wiki_editor" zostaje utworzona automatycznie i zostaje się przydzielonym do tej grupy. Różnica w uprawnieniach redaktora (wiki_editor) a autora (wiki_author) jest taka, że redaktor może tworzyć strony, edytować i usuwać każdą stronę, gdy autor może tylko tworzyć strony (z pewnymi ograniczeniami) i może tylko edytować i usuwać strony przez siebie stworzone.</p><p>Funkcja <code>auth.wiki()</code> zwraca słownik z kluczem <code>content</code>, który jest zrozumiały dla widoku "views/default/index.html". Dla tej akcji można wykonać własny widok:</p><pre><code class="code">{{extend 'layout.html'}}
{{=content}}</code></pre><p>i w razie potrzeby dodać dodatkowy kod. Nie trzeba korzystać z akcji "index" aby udostępnić wiki. Można w tym celu wykorzystać akcję i innej nazwie.</p><p>Aby wypróbować wiki, wystarczy zalogować się do interfejsu administracyjnego i odwiedzić stronę</p><pre><code>http://127.0.0.1:8000/wikidemo/default/index</code></pre><p>Następnie trzeba wybrać krótka nazwę (<em>ang. slug</em>) (w publikacjach biznesowych krótką nazwę przypisuje się do artykułu w celu wykorzystania w przyjaznych adresach) i zostanie się przeniesionym, do pustej strony, którą będzie można edytować stosując składnię MARKMIN. Dodane zostanie nowe menu o nazwie "[wiki]", które pozwala tworzyć, wyszukiwać i edytować strony. Strony Wiki maja adresy URL podobne do tego:</p><pre><code>http://127.0.0.1:8000/wikidemo/default/index/[slug]</code></pre><p>Strony usług mają nazwy, które rozpoczynają się znakiem podkreślenia:</p><pre><code>http://127.0.0.1:8000/wikidemo/default/index/_create
http://127.0.0.1:8000/wikidemo/default/index/_search
http://127.0.0.1:8000/wikidemo/default/index/_could
http://127.0.0.1:8000/wikidemo/default/index/_recent
http://127.0.0.1:8000/wikidemo/default/index/_edit/...
http://127.0.0.1:8000/wikidemo/default/index/_editmedia/...
http://127.0.0.1:8000/wikidemo/default/index/_preview/...</code></pre><p>Spróbuj utworzyć więcej stron takich jak "index", "aboutus" czy "contactus". Spróbuj je edytować.</p><p>Metoda <code>wiki</code> ma następującą sygnaturę:</p><pre><code class="code">def wiki(self, slug=None, env=None, render='markmin',
         manage_permissions=False, force_prefix='',
         restrict_search=False, resolve=True,
         extra=None, menugroups=None)</code></pre><p>Pobiera następujące argumenty:</p><ul><li><code>render</code> ma domyślną wartość <code>'markmin'</code>, ale może być również ustalony na<code>'html'</code>. Określa składnię wiki. Znaczniki markmin wiki omówimy później. Jeśli zmieni się to na HTML, można użyć edytor wysiwyg javascript taki jak TinyMCE lub NicEdit;</li><li><code>manage_permissions</code>. Jest ustawiony domyślnie na <code>False</code> i tylko rozpoznaje uprawnienia dla "wiki_editor" i "wiki_author". Jeśli zmieni się to na <code>True</code>, to prawo do tworzenia i edytowania strony będzie mogło być ustalone przez określenie nazwy grup, których członkowie mają prawo do odczytywania i edytowania strony. Istnieje grupa "everybody", która zawiera wszystkich użytkowników;</li><li><code>force_prefix</code>. Jeśli jest ustawiony na coś podobnego do <code>'%(id)s-'</code>, to powodować będzie ograniczenie praw autorów (nie redaktorów) do tworzenia tylko stron z przyrostkiem takim jak "[user id]-[page name]". Przyrostek może zawierać identyfikator (<code>%(id)s</code>) lub nazwę użytkownik (<code>%(username)s</code>) lub jakiegokolwiek inne pole z tabeli auth_user, o ile odpowiednia kolumna zawiera prawidłowy ciąg, przechodzący walidację adresu URL;</li><li><code>restrict_search</code>. Domyślnie ma wartość <code>False</code> przy którym każdy zalogowany użytkownik może przeszukiwać wszystkie strony wiki (choć nie koniecznie ma ma prawo do ich odczytywania i edytowania). Jeśli zostanie ustawiony na <code>True</code>, autorzy będą mogli przeszukiwać tylko własne strony, redaktorzy będą mogli przeszukiwać wszystkie strony, inni użytkownicy nie będą mogli przeszukiwać niczego;</li><li><code>menu_groups</code>. Domyślnie ustawiony na <code>None</code> i wskazuje, że menu zarządzania wiki (wyszukiwanie, tworzenie, edytowanie itd.) jest zawsze wyświetlane. Argument ten może być ustawiony na nazwy grup, której członkowie są uprawnieni jako jedyni do oglądania i dostępu do menu wiki, na przykład <code>['wiki_editor','wiki_author']</code>. Proszę zauważyć, że nawet jeśli menu jest dostępne dla każdego, to nie oznacza to, że  każdy może wykonywać działania ujęte w menu, bo dostęp do tych działań jest regulowany w systemie kontroli dostępu.</li></ul><p>Metoda <code>wiki</code> ma kilka dodatkowych parametrów, które zostaną wyjaśnione dalej, takie jak <code>slug</code>, <code>env</code> i <code>extra</code>.</p><h4>Podstawy MARKMIN</h4><p>Składnia MARKMIN pozwala na zaznaczanie tekstu <strong>pogrubionego</strong> przy użyciu <code>**znacznika bold**</code>, <em>kursywy</em> przy użyciu <code>''znacznika italic''</code> oraz <code>kodu</code> po ujęciu tekstu kodu w lewe apostrofy. Tytuły muszą być poprzedzone znakiem #, rozdziały znakami ## a podtytuły przez ###. Użycie znaku minus(-) poprzedza element listy nieuporządkowanej a znaku plus(+) element listy uporządkowanej. Adresy URL są automatycznie przekształcane w odnośniki. Oto przykład tekstu markmin:</p><pre><code class="code"># To jest tytuł
## to jest tytuł rozdziału
### to jest tytuł podrozdziału

Tekst może być **pogrubiony**, ''kursywą'', ``kodem`` itd.
Więcej nformacji znajdziesz na:

http://web2py.com</code></pre><p>Można użyć parametr <code>extra</code> w metodzie <code>auth.wiki</code>, aby przekaza do helpera MARKMIN dodatkowe zasady renderowania.</p><p>Więcej informacji o składni MARKMIN znajdziesz w rozdziale 5.</p><p>Metoda <code>auth.wiki</code> jest mocniejsza niż szkielet helperów MARKMIN, obsługując protokół  oembed i komponenty.</p><p>Można użyć parametr <code>env</code> metody <code>auth.wiki</code> do udostępnienia funkcji swojego wiki. Na przykład:</p><pre><code>auth.wiki(env=dict(join=lambda a,b,c:"%s-%s-%s" % (a,b,c)))</code></pre><p>umożliwi wykorzystywanie składni znacznika:</p><pre><code>@(join:1,2,3)</code></pre><p>Wywoła to funkcję join przekazującą dodatkowe parametry <code>a,b,c=1,2,3</code> i zrenderuje je jako <code>1-2-3</code>.</p><h4>Protokół oembed</h4><p>W tekście strony wiki można wpisać (lub wyciąć i wkleić) dowolny adres URL, który zostanie zrenderowany jako odnośnik do tego adresu URL. Istnieją pewne wyjątki:</p><ul><li>Jeśli adres URL kończy sie rozszerzeniem wskazującym na plik obrazu, odnośnik jest osadzany jako znacznik obrazu <code>&lt;img/&gt;</code>.</li><li>Jeśli adres URL kończy sie rozszerzeniem wskazującym na plik audio, odnośnik jest osadzany jako znacznik audio HTML5 <code>&lt;audio/&gt;</code>.</li><li>Jeśli adres URL kończy sie rozszerzeniem wskazującym na plik wideo, odnośnik jest osadzany jako znacznik video HTML5 <code>&lt;video/&gt;</code>.</li><li>Jeśli adres URL kończy sie rozszerzeniem pliku Office lub PDF, osadzany jest Google Doc Viewer wyświetlający treść tego dokumentu (działa tylko na publicznych dokumentach).</li><li>Jeśli adres URL wskazuje na stronę YouTube, Vimeo lub Flickr, web2py kontaktuje się z odpowiednim serwisem internetowym i pyta o prawidłowy sposób osadzenia treści. Wykonywane jest to przy wykorzystaniu protokołu <code>oembed</code>.</li></ul><p>Oto kompletny wykaz wspieranych formatów:</p><pre><code>Image (.PNG, .GIF, .JPG, .JPEG)
Audio (.WAV, .OGG, .MP3)
Video (.MOV, .MPE, .MP4, .MPG, .MPG2, .MPEG, .MPEG4, .MOVIE)</code></pre><p>Obsługiwane przez Google Doc Viewer:</p><pre><code class="code">Microsoft Excel (.XLS and .XLSX)
Microsoft PowerPoint 2007 / 2010 (.PPTX)
Apple Pages (.PAGES)
Adobe PDF (.PDF)
Adobe Illustrator (.AI)
Adobe Photoshop (.PSD)
Autodesk AutoCad (.DXF)
Scalable Vector Graphics (.SVG)
PostScript (.EPS, .PS)
TrueType (.TTF)
xml Paper Specification (.XPS)</code></pre><p>Obsługiwane przez oembed:</p><pre><code class="code">flickr.com
youtube.com
hulu.com
vimeo.com
slideshare.net
qik.com
polleverywhere.com
wordpress.com
revision3.com
viddler.com</code></pre><p>Jest to zaimplementowane w pliku web2py <code>gluon.contrib.autolinks</code> a konkretniej w funkcji <code>expand_one</code>. Można rozszerzyć obsługę oembed rejestrując więcej usług. Odbywa się to przez dodanie wpisu do listy<code>EMBED_MAPS</code>:</p><pre><code class="code">from gluon.contrib.autolinks import EMBED_MAPS
EMBED_MAPS.append((re.compile('http://vimeo.com/\S*'),
                   'http://vimeo.com/api/oembed.json'))</code></pre><h4>Odwoływanie się do treści wiki</h4><p>Jeśli utworzyło się stronę z krótką nazwą "contactus", to można się do niej odwołać tak:</p><pre><code class="code">@////contactus</code></pre><p>Tutaj @//// oznacza</p><pre><code class="code">@/app/controller/function/</code></pre><p>ale "app", "controller" i "function" są pomijane, gdyż z założenia są domyślne.</p><p>Podobnie można użyć menu wiki do ładowania plików mediów (na przykład obrazów) zlinkowanych ze stroną. Strona "Zarządzanie mediami" pokazuje wszystkie pliki, które zostały przesłane i pokaże właściwe wyrażenie do zlinkowanego pliku. Jeśli, na przykład, przesłany będzie plik o nazwie "test.jpg" o tytule "Plaża", to wyrażenie odnośnika będzie podobne do tego:</p><pre><code class="code">@////15/Plaża.jpg</code></pre><p><code>@////</code> jest tym samym przedrostkiem opisanym wcześniej. <code>15</code> to id rekordu przechowującego plik zdjęcia. <code>Plaża</code> to tytuł. <code>.jpg</code> jest rozszerzeniem oryginalnego pliku.</p><p>Jeśli wytnie się i osadzi <code>@////15/Plaża.jpg</code> na stronie wiki, to osadzi się obraz.</p><p>Trzeba pamiętać, że pliki mediów są linkowane do stron i dziedziczą uprawnienia dostępu ze stron.</p><h4>Menu wiki</h4><p>Jeśli utworzy się stronę o krótkiej nazwie "wiki-menu", to będzie ona interpretowana jako opis menu. Oto przykład:</p><pre><code>- Start &gt; @////index
- Info &gt; @////info
- web2py &gt; http://www.web2py.com
- - O nas &gt; @////aboutus
- - Kontakt z nami &gt; @////contactus</code></pre><p>Każda linia jest elementem menu. Używamy podwójnych myślników do zagnieżdżania menu. Symbol <code>&gt;</code> oddziela tytuł elementu menu od odnośnika elementu menu.</p><p>Trzeba pamiętać, że menu jest dołączone do <code>response.menu</code>. Nie należy tego zamieniać. Element <code>[wiki]</code> menu z funkcjami serwisowymi jest dodawany automatycznie.</p><h4>Funkcje serwisowe</h4><p>Jeśli, na przykład, chce się wykorzystać wiki do tworzenia edytowalnego paska bocznego, to można utworzyć stronę z <code>slug="sidebar"</code> i osadzić ją w layout.html stosując:</p><pre><code class="code">{{=auth.wiki(slug='sidebar')}}</code></pre><p>Proszę zwrócić uwagę, że tu nie ma nic specjalnego ze słowem "sidebar". Każda strona wiki może być pobierana i osadzana w każdym punkcie kodu. Pozwala to łączyć funkcjonalność wiki ze zwykłą funkcjonalnością web2py.</p><blockquote>Należy również pamietać, że <code class="code">auth.wiki('sidebar')</code> jest tym samym,
co <code class="code">auth.wiki(slug='sidebar')</code>, ponieważ argument slug jest pierwszym w
sygnaturze metody. Poprzednie wyrażenie ma trochę prostszą składnię.</blockquote><p>Można również osadzać specjalne funkcje wiki, takie jak wyszukiwanie wg tagów:</p><pre><code class="code">{{=auth.wiki('_search')}}</code></pre><p>lub chmurę tagów:</p><pre><code class="code">{{=auth.wiki('_cloud')}}</code></pre><h4>Rozszerzanie możliwości auth.wiki</h4><p>Gdy aplikacja udostępniająca wiki jest bardziej skomplikowana, być może trzeba dostosować rekordy bazy danych wiki zarządzane przez interfejs Auth lub udostępnić własny formularz dla zadań CRUD wiki. Na przykład, można chcieć dostosować reprezentację rekordu tablicy wiki lub dodać nowy walidator pola. Nie jest to dostępne domyślnie, ponieważ model wiki jest definiowany dopiero po tym, jak interfejs wiki jest wywoływany przez metodę auth.wiki(). Aby umożliwić dostęp do specyficznych ustawień bazy danych wiki w modelu aplikacji (tj. db.py) trzeba dodać następujące wyrażenie:</p><pre><code class="code"># Upewnij się, że to jest wywoływane po tym, jak utworzona została instancja auth
# i przed jakąkolwiek zmianą tabel wiki
auth.wiki(resolve=False)</code></pre><p>Przy użyciu powyższej linii kodu w modelu dostępne będą tabele wiki (tj. <code>wiki_page</code>) dla indywidualnego CRUD lub innych zadań bazy danych.</p><blockquote>Trzeba jeszcze wywołać auth.wiki() w kontrolerze lub widoku
w celu udostępnienia interfejsu wiki, ponieważ parametr <code>resolve=False</code> nakazuje,
aby obiekt auth po prostu zbudował model wiki bez jakiegokolwiek ustawiania interfejsu.</blockquote><p>Również przez ustawienie parametru resolve na <code>False</code> w wywołaniu metody, tabele wiki będą teraz dostępne za pośrednictwem domyślnego w aplikacji interfejsu bazy danych na <code>&lt;app&gt;/appadmin</code> do zarządzania rekordami wiki.</p><p>Innym możliwym dostosowaniem jest dodanie dodatkowych pól do standardowych tabel wiki (w ten sam sposób jak w tabelach <code>auth_user</code>, co opisano w rozdziale 9). Oto jak:</p><pre><code class="code"># Umieść to po inicjowaniu obiektu auth
auth.settings.extra_fields["wiki_page"] = [Field("ablob", "blob"),]</code></pre><p>Powyższa linia dodaje pole <code>blob</code> do tabeli <code>wiki_page</code>. Nie ma potrzeby wywoływania <code class="code">auth.wiki(resolve=False)</code> dla tej opcji, jeśli nie potrzebuje się dostępu do modelu wiki dla innych dostosowań.</p><h4>Komponenty</h4><p>Jedna z najmocniejszych funkcji nowego web2py polega na możłiwości osadzaniq akcji wewnątrz innych akcji. Taka osadzoną akcję nazywamy to <strong>komponentem</strong>.</p><p>Rozważmy następujący model:</p><pre><code class="code">db.define_table('thing',Field('name',requires=IS_NOT_EMPTY()))</code></pre><p>i następującą akcję:</p><pre><code class="code">@auth.requires_login()
def manage_things():
    return SQLFORM.grid(db.thing)</code></pre><p>Akcja ta jest szczególna, ponieważ zwraca widżet (helper) a nie słownik obiektów. Teraz możemy osadzić akcję <code>manage_things</code> w jakimś widoku, stosując:</p><pre><code class="code">{{=LOAD('default','manage_things',ajax=True)}}</code></pre><p>Pozwala to odwiedzającym wchodzić w interakcję z komponentem poprzez Ajax bez przeładowywania strony hosta na której osadzony jest widżet. Akcja jest wywoływana poprzez Ajax, dziedziczy style ze strony hosta i przechwytuje wszystkie zgłoszenia formularzy oraz wiadomości fleszowe, tak że są one obsługiwane na bieżącej stronie. Na szczycie <code>SQLFORM.grid</code> widżet wykorzystuje podpisane cyfrowo adresy URL w celu ograniczenia dostępu. Więcej informacji można znaleźć w rozdziale 13.</p><p>Komponenty, takie jak powyższy, mogą być osadzane na stronach wiki przy użyciu składni MARKMIN:</p><pre><code>@{component:default/manage_things}</code></pre><p>To po prostu informuje web2py, że chcemy dołączyć akcję "manage_things" zdefiniowaną w kontrolerze "default" jako "component" Ajax.</p><blockquote>Większość użytkowników jest w stanie zbudować względnie złożoną aplikację po prostu
stosując <code>auth.wiki</code> do tworzenia stron i menu oraz osadzania własnych komponentów
na stronach wiki. Wiki można traktować jako mechanizm do umożliwienia członkom grupy
tworzenia stron, ale można również traktować jako sposób na tworzenie aplikacji
w modułowy sposób.</blockquote><h3>Więcej o aplikacji <em>admin</em></h3><p><div class="inxx">admin</div> <div class="inxx">interfejs administracyjny</div> <div class="inxx">aplikacja admin</div></p><p>Aplikacja <em>admin</em> dostarcza dodatkowe możliwości, które krótko tutaj omawiamy.</p><h4>Strona 'site'</h4><div class="inxx">strona 'site'</div><p>Strona <em>site</em> jest stroną główną interfejsu administracyjnego w web2py. Po lewej stronie ekranu wykazuje wszystkie zainstalowane aplikacje , a po prawej znajduje się kilka formularzy specjalnych procedur.</p><p>Pierwszy z tych formularzy wyświetla wersję web2py i proponuje aktualizację, jeśli jest dostępna nowsza wersja. Oczywiście przed dokonaniem aktualizacji należy wykonać kopię zapasową! Następne dwa formularze pozwalają na utworzenie nowej aplikacji (prostą lub przez wykorzystanie kreatora online) przez określenie jej nazwy.</p><p><div class="inxx">Instant Press</div> <div class="inxx">Movuca</div> Kolejny formularz umożliwia przesyłanie istniejącej aplikacji z innego lokalnego pliku lub zdalnego adresu URL. Po przesłaniu aplikacji należy określić jej nazwę (używając różnych nazw można instalować wiele kopii tej samej aplikacji). Możesz spróbować, na przykład, przesłać aplikację Movuca Social Networking stworzoną przez Bruno Rocha:</p><pre><code>https://github.com/rochacbruno/Movuca</code></pre><p>lub CMS Instant Press stworzony przez Martina Mulone:</p><pre><code>http://code.google.com/p/instant-press/</code></pre><p>lub jedną z wielu przykładowych aplikacji dostępnych na:</p><pre><code>http://web2py.com/appliances</code></pre><blockquote>Pliki web2py są pakietami takimi jak pliki <code>.w2p</code>. Są plikami archiwów TAR
skompresowanymi przy użyciu gzip. Web2py używa rozszerzenia <code>.w2p</code> zamiast
<code>.tgz</code> w celu zapobieżenia przed rozpakowywaniem tych plików przez przeglądarkę.
Można je rozpakować ręcznie stosując polecenie <code>tar zxvf [filename]</code>, choć nie
jest to konieczne.</blockquote><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4100.png" alt="image" style="width:444px" /></p></p><p>Po pomyślnym przesłaniu, web2py wyświetla sumę kontrolną MD5 przesłanych plików. Można to wykorzystać do sprawdzenia, czy plik nie został uszkodzony podczas przesyłania. Nazwa InstantPress pojawi się na wykazie zainstalowanych aplikacji.</p><p>Jeśli ma się uruchomiony web2py ze źródła i ma się zainstalowany program <code>gitpython</code> (jeśli to konieczne, ustaw go z 'easy_install gitpython'), można instalować aplikacje bezpośrednio z repozytoriów, używając adresu URL <code>.git</code>. W tym przypadku będzie można mieć możliwość korzystania z interfejsu administracyjnego do wypychania zmian z powrotem do repozytorium, ale jest to funkcja eksperymentalna.</p><p>Na przykład można lokalnie zainstalować aplikację, która wyświetla tą książkę na witrynie web2py pod tym adresem URL:</p><pre><code>https://github.com/mdipierro/web2py-book.git</code></pre><blockquote>Repozytorium to hostuje bieżącą, zaktualizowaną wersją tej książki (która może
różnić się ze stabilną wersją, jaką można zobaczyć na witrynie internetowej web2py).
Serdecznie zachęcamy do składania ulepszeń, poprawek i korekt w formie żądań aktualizacji
(<em>ang. pull request</em>).</blockquote><p>Dla każdej zainstalowanej aplikacji można wykorzystać stronę <em>site</em> do:</p><ul><li>Bezpośredniego przechodzenia do aplikacji przez kliknięcie na jej nazwę.</li><li>Odinstalowywania aplikacji.</li><li>Odwiedzania strony <em>O aplikacji</em> (czytaj niżej).</li><li>Odwiedzania strony <em>Edycja aplikacji</em> (czytaj niżej).</li><li>Odwiedzania do strony <em>Błędy</em> (czytaj niżej).</li><li>Czyszczenia plików tymczasowych (sesje, błędy i pliki cache.disk).</li><li>Pakowania wszystkiego. Zwraca to plik tar zawierający kompletna kopię aplikacji. Sugerujemy, aby przed pakowaniem aplikacji wyczyścić wszystkie pliki tymczasowe.</li><li>Kompilowania aplikacji. Jeśli nie ma błędów, to opcja ta skompiluje do kodu bajtowego wszystkie modele, kontrolery i widoki. Ponieważ widoki mogą rozszerzać lub dołączać inne widoki w drzewie, przed kompilacją, widoki dla każdego kontrolera są zwijane do pojedynczego pliku. Sieciowym efektem bajtowej kompilacji kodu jest to, że aplikacje takie są szybsze, ponieważ nie wymagają dalszego parsowania szablonów lub zamiany ciągów znakowych w czasie wykonania.</li><li>Pakowania skompilowanego. Opcja ta jest tylko dostępna dla aplikacji z kodem skompilowanym bajtowo. Umożliwia pakowanie aplikacji bez kodu źródłowego dla dystrybucji o zamkniętym kodzie. Proszę pamiętać, że Python (tak jak inne języki programowania) może technicznie być dekompilowany, dlatego kompilacja nie zapewnia pełnej ochrony kodu źródłowego. Niemniej jednak dekompilacja może być trudna i jest nielegalna.</li><li>Usuwać pliki skompilowane. Po prostu usuwa z aplikacji skompilowane do kodu bajtowego modele, widoki i kontrolery. Jeśli aplikacja została zapakowana wraz z kodem źródłowym lub jest edytowana lokalnie, to nie ma nic złego w usunięciu plików z kodem skompilowanym i aplikacja nadal będzie działać. Jeśli natomiast została zainstalowana z pakietu z plikami skompilowanymi, to nie jest to bezpieczne, ponieważ nie ma kodu źródłowego, który mógłby przywrócić działanie aplikacji.</li></ul><div class="inxx">admin.py</div><blockquote>Wszystkie funkcje dostępne na stronie głównej interfejsu administracyjnego web2py,
są również dostępne programowo poprzez API zdefiniowane w module <code>gluon/admin.py</code>.
Wystarczy otworzyć powłokę Pythona i zaimportować ten moduł.</blockquote><p>Jeśli jest zainstalowany Google App Engine SDK, to strona główna interfejsu administracyjnego wyświetla przycisk do wypychania aplikacji na GAE. Jeśli zainstalowany jest <code>python-git</code>, to wyświetlany jest przycisk do wypychania aplikacji na Open Shift. Aby zainstalować aplikację na <code>Heroku</code> lub innym systemie hostingowym należy w tym celu odnaleźć odpowiedni skryptu w folderze "scripts".</p><h4>Strona 'O aplikacji'</h4><p><div class="inxx">O aplikacji</div> <div class="inxx">licencja</div></p><p>Karta <em>O aplikacji</em> umożliwia edytowanie opisu aplikacji i jej licencji. Są one zapisywane odpowiednio w plikach ABOUT i LICENSE w folderze aplikacji.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4300.png" alt="image" style="width:480px" /></p></p><p>Można wykorzystać składnię <code>MARKMIN</code> lub <code>gluon.contrib.markdown.WIKI</code>, tak jak opisano to w ref.<sup>[<a href="/book/default/reference/42/markdown2" target="_blank">markdown2</a>]</sup> .</p><h4>Projekt</h4><div class="inxx">EDIT</div><p>W tym rozdziale już używaliśmy stronę <em>Edycja aplikacji</em>. Tutaj chcemy wskazać jeszcze kilka możliwości tej strony:</p><ul><li>Jeśli kliknie się na nazwę pliku, to będzie można zobaczyć zawartość tego pliku z podświetleniem składni.</li><li>Jeśli kliknie się na odnośnik <em>edytuj</em>, będzie można edytować plik w interfejsie internetowym.</li><li>Jeśli kliknie się na odnośnik <em>usuń</em>, to można usunąć plik (całkowicie).</li><li>Jeśli kliknie się na odnośnik <em>testuj</em>, to web2py uruchomi testy. Testy są napisane przez programistę z użyciem doctest Pythona i każda funkcja może mieć swoje własne testy.</li><li>Można dodawać pliki językowe, skanować aplikacje w celu odkrycia wszystkich ciągów znakowych i edytować tłumaczenia łańcuchów tekstowych poprzez interfejs internetowy.</li><li>Jeśli pliki statyczne są zorganizowane w foldery i podfolder, to taki hierarchiczny folder może być przełączany przez klikniecie na nazwę folderu.</li></ul><p>Poniższy obraz przedstawia wyjście strony testowej dla aplikacji powitalnej.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4400.png" alt="image" style="width:480px" /></p></p><p>Następny obraz przedstawia kartę języków dla aplikacji powitalnej.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4500.png" alt="image" style="width:480px" /></p></p><p>Natomiast na tym obrazie pokazani edytowanie pliku językowego, w tym przypadku języka "it" (włoskiego) dla aplikacji powitalnej.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4600.png" alt="image" style="width:480px" /></p></p><h4>Zintegrowany debugger internetowy</h4><p><em>(requires Python 2.6 or later)</em></p><p>Intefejs administracyjny web2py zawiera debugger internetowy.</p><div class="inxx">debugger</div><p>Stosując dostarczany edytor internetowy można z poziomu powiązanej konsoli debuggera dodawać w kodzie Pythona punkty przerwania oraz można sprawdzać zmienne systemowe w tych punktach przerwań i wznowić wykonanie. ta jak obrazuje to poniższy zrzut ekranu:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/debugger.png" alt="image" style="width:480px" /></p></p><p>Funkcjonalność ta oparta jest na debuggerze Qdb stworzonym przez Mariano Reingarta. Wykorzystuje ona multiprocessing.connection do komunikacji pomiędzy zapleczem a częścią frontową , z protokołem strumieniowym  <sup>[<a href="/book/default/reference/42/qdb" target="_blank">qdb</a>]</sup>, podobnym do JSON-RPC.</p><h5>Ustawianie punktów przerwań w kodzie</h5><div class="inxx">punkty przerwań</div><p>Dołącz ten kod do debuggera:</p><pre><code class="code">from gluon.debug import dbg</code></pre><p>a ten w wybranym miejscu kodu:</p><pre><code class="code">dbg.set_trace() </code></pre><p>Aplikacja debuggera ma menadżera punktów przerwań.</p><code>Uwagi:
web2py nie wie, czy aktualnie ma się otwarte okno debugowania w swojej przeglądarce – mimo wszystko wykonanie zawiesi się.

Platformy IDE zazwyczaj mają własne debuggery międzyprocesowe, np. PyCharm lub PyDev.
Mogą one zgłaszać problemy, gdy dołączy się bibliotekę gluon.</code><h4>Internetowa powłoka Pythona</h4><p>Jeśli kliknie się na odnośnik "powłoka" w zakładce kontrolerów na stronie <em>Edycja aplikacji</em>, web2py otworzy internetową powłokę Pythona i będzie wykonywał modele dla bieżącej aplikacji. Pozwala to na interaktywny dialog z aplikacja.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4700.png" alt="image" style="width:480px" /></p></p><blockquote>Bądź ostrożny korzystając z internetowej powłoki – ponieważ odmienne żądania powłoki
będą wykonywane w różnych wątkach. To łatwo daje błędy, jeśli realizuje się tworzenie
i połączenia z bazą danych. Do działań takich jak te (tj. jeśli potrzeba wytrwałości)
lepiej jest używać linii poleceń Pythona.</blockquote><p>Interaktywna konsola obsługuje również notatnik Pythona.</p><h4>Crontab</h4><p>W zakładce kontrolerów na stronie <em>Edycja aplikacji</em> znajduje się również odnośnik "crontab". Klikając na ten odnośnik będzie można edytować plik crontab web2py. Wykorzystuje on ta sama składnię, co crontab uniksowy, ale nie jest uzależniony od systemu Unix. W rzeczywistości, wymaga tylko web2py i działa na Windows. Pozwala na zarejestrowanie akcji, które mają być wykonane w tle o wyznaczonych godzinach. Więcej informacji o tym znajdziesz w następnym rozdziale.</p><h4>Błędy</h4><div class="inxx">błędy</div><p>Podczas programowania web2py, będziesz nieuchronnie popełniać błędy i wprowadzać poprawki. web2py pomaga na dwa sposoby: 1) pozwala tworzyć testy dla dla każdej funkcji, którą można uruchomić w przeglądarce z poziomu strony <em>Edycja aplikacji</em> i 2) podczas pojawienia się błędu, wystawiany jest odwiedzającemu bilet a błąd jest rejestrowany.</p><p>Celowo wprowadźmy błąd w aplikacji images aby zobaczyć jak to działa:</p><pre><code class="code">def index():
    images = db().select(db.image.ALL,orderby=db.image.title)
    1/0
    return dict(images=images)</code></pre><p>Jeśli teraz uruchomisz akcję index, otrzymasz następujący bilet:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4800.png" alt="image" style="width:480px" /></p></p><p>Dostęp do biletu może uzyskać tylko administrator:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl4900.png" alt="image" style="width:480px" /></p></p><p>Bilet pokazuje komunikat z ostaniego wywołania (<em>ang. traceback</em>)  i zawartość pliku, który spowodował problem oraz kompletny stan systemu (zmienne, żądania, sesje itd.). Jeśli w widoku pojawi się  błąd, web2py wyświetli widok przekształcony z kodu HTML do Pythona. Pozwala to na łatwą identyfikację logicznej struktury pliku.</p><p>Domyślnie bilety są przechowywane w systemie plików i wyświetlane są w grupach przez komunikat dotyczacy ostatniej transakcji (traceback). Interfejs administracyjny dostarcza widoki zagregowane (typ komunikatu z ostatniej transakcji i liczbę występowania) i widoki szczegółowe (wykazywane są wszystkie bilety wg id). Administrator może przełączać się pomiędzy tymi widokami.</p><p>Proszę zwrócić uwagę, że interfejs administracyny wyświetla wszędzie kod z podświetlaniem składni (na przykład, w raportach błędów słowa kluczowe web2py są wyświetlane na pomarańczowo). Jeśli kliknie się na słowo kluczowe web2py, to zostaje się przekierowanym do strony dokumentacji o słowach kluczowych.</p><p>Jeśli naprawisz błąd dzielenia przez zero w akcji index i wprowadzisz ten kod w widoku index:</p><pre><code class="code">{{extend 'layout.html'}}

&lt;h1&gt;Bieżace obrazy&lt;/h1&gt;
&lt;ul&gt;
{{for image in images:}}
{{1/0}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
&lt;/ul&gt;</code></pre><p>to otrzymasz następujacy bilet:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5000.png" alt="image" style="width:480px" /></p></p><p>Trzeba mieć na uwadze, że web2py przekształca widok z HTML do pliku Pythona, a błąd opisany w bilecie odnosi się do wygenerowanego kodu Pythona na NIE do oryginalnego pliku widoku:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5100.png" alt="image" style="width:480px" /></p></p><p>Może to wydawać się na początku mylące, ale w praktyce sprawia, ze debugowanie jest prostsze, ponieważ wcięcia Pythona podświetlają strukturę logiczną kodu, która osadza się w widokach.</p><p>Kod ten jest wyświetlany na dole tej samej strony.</p><p>Wszystkie bilety są wykazywane w interfejsie administracyjnym na stronie <em>Błędy</em> dla każdej aplikacji:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5200.png" alt="image" style="width:480px" /></p></p><h4>Mercurial</h4><div class="inxx">Mercurial</div><p>Jeśli platforma web2py została uruchomiona z kodu źródłowego, to interfejs administracyjny wyświetla jeszcze jeden element menu o nazwie "Wersjonowanie".</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5300.png" alt="images" style="width:480px" /></p></p><p>Wprowadzając komentarz i wciskając przycisk "commit" wynikowa strona zostanie zapisana w bieżącej aplikacji. Przy pierwszym zapisie zostanie utworzone lokalne repozytorium Mercurial dla określonej aplikacji. Mercurial zapisuje, w tle, informacje o dokonanych zmianach kodu w ukrytym folderze ".hg" podfolderu aplikacji. Każda aplikacja ma swój własny folder ".hg" i swój własny plik ".hgignore" file (informuje on Mercurial, które pliki mają być ignorowane). Aby móc wykorzystać ta funkcjonalność, trzeba mieć zainstalowany system kontroli wersji  Mercurial (ostatnia wersja, to 1.9):</p><pre><code class="code">easy_install mercurial</code></pre><p>Interfejs internetowy Mercurial umożliwia przeglądanie poprzednich rewizji i różnic w plikach, ale zalecamy bezpośrednie stosowanie systemu Mercurial z poziomu powłoki lub jednego z wielu klientów Mercurial z interfejsem GUI, ponieważ mają więcej możliwości. Na przykład, pozwalają na synchronizowanie aplikacji ze zdalnym repozytorium.</p><p>O Mercurialu możesz przeczytać więcej tutaj:</p><pre><code>http://mercurial.selenic.com/</code></pre><h4>Integracja z Git</h4><div class="inxx">git</div><p>Aplikacja interfejsu administracyjnego zawiera również integrację z git. Wymagane są biblioteki git Pythona, np.</p><pre><code class="code">pip install gitpython</code></pre><p>A następnie dla każdej aplikacji musi się sklonować lub inaczej skonfigurować repozytorium git.</p><p>Po tych krokach, zostanie wyświetlone menu Manage dla każdej aplikacji zarządzanej, z opcjami <code>git push</code> i <code>git pull</code>. Aplikacje, które nie są zarządzane przez przez git są ignorowane. Można ściagać i wypychać aplikacje na zdalne domyślne repozytorium.</p><h4>Kreator aplikacji (eksperymantalnie)</h4><p>Interfejs administracyjny zawiera kreatora, który pomaga w tworzeniu aplikacji. Do kreatora tego można uzyskać dostęp ze strony "Witryny", tak jak pokazano to niżej.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5400.png" alt="image" style="width:480px" /></p></p><p>Kreator poprowadzi Cię przez serię kroków tworzenia nowej aplikacji:</p><ul><li>Wybierz nazwę aplikacji;</li><li>Skonfigurujaplikację i wybierz niebedne wtyczki;</li><li>Zbuduj niezbędne modele (utworzy to strony CRUD dla każdego modelu);</li><li>Edytuj widoki tych stron przy użyciu składni MARKMIN.</li></ul><p>Poniższy obraz pokazuje drugi krok procedury.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5500.png" alt="image" style="width:480px" /></p></p><p>Widoczna jest rozwijana lista, gdzie można wybrać wtyczkę układu (z <code>web2py.com/layouts</code>), rozwijana lista wielokrotnego wyboru do zaznaczenia innych wtyczek (z <code>web2py.com/plugins</code>) oraz pole "login config" do umieszczania Janrain "domain:key".</p><p>Pozostałe kroki są oczywiste.</p><p>Kreator działa dobrze w swoim zakresie, ale dalej jest uważany za funkcję <em>eksperymentalną</em> z dwóch powodów:</p><ul><li>Aplikacje utworzone przez kreator i edytowane później ręcznie nie mogą być później modyfikowane przez kreator.</li><li>Interfejs kreatora będzie zmieniany stopniowo i powiększany o nowe funkcje oraz ułatwienia wizualnego programowania.</li></ul><p>W każdym bądź razie, kreator jest poręcznym narzędziem dla szybkiego prototypowania i może być stosowany do zapoczątkowywania nowych aplikacji z alternatywnymi układami i opcjonalnymi wtyczkami.</p><h4>Konfigurowanie interfejsu administracyjnego</h4><p>Zwykle nie ma potrzeby wykonywania jakiejkolwiek konfiguracji interfejsu administracyjnego, ale jest możliwych kilka modyfikacji. Po zalogowaniu się do zaplecza administracyjnego, można edytować plik konfiguracyjny interfejsu administracyjnego poprzez adres URL:</p><pre><code>http://127.0.0.1:8000/admin/default/edit/admin/models/0.py</code></pre><p>Proszę zauważyć, że interfejs administracyjny może być wykorzystywany do edytowania samego siebie. W rzeczywistości intefejs administracyjny jest aplikacją, jak każda inna.</p><p>Plik "0.py" jest mniej więcej udokumentowany, tak czy inaczej, opisujemy tutaj kilka ważniejszych możliwości dostosowań:</p><pre><code>GAE_APPCFG = os.path.abspath(os.path.join('/usr/local/bin/appcfg.py'))</code></pre><p>Powinno to wskazywać lokalizację pliku "appcfg.py", który jest dostarczany wraz z Google App Engine SDK. Jeśli masz SDK, to musisz zmienić ustawienie tego parametru do wartości prawidłowej. Pozwoli to na wdrożenie GAE z poziomu interfejsu administracyjnego.</p><div class="inxx">DEMO_MODE</div><p>Można również ustawić interfejs administracyjny web2py do trybu demo:</p><pre><code>DEMO_MODE = True
FILTER_APPS = ['welcome']</code></pre><p>Wówczas dostępne będą tylko aplikacje wymienione w FILTER_APPS i to tylko w trybie do odczytu.</p><div class="inxx">MULTI_USER_MODE</div><div class="inxx">virtual laboratory</div><p>Jeśli jesteś nauczycielem i chcesz udostępnić interfejs administracyjny studentom, to możesz  udostępnić ten interfejs dla ich projektów (myślę o wirtualnym laboratorium), poprzez ustawienie:</p><pre><code>MULTI_USER_MODE = True</code></pre><p>W ten sposób studenci będą mogli zalogować się i uzyskać dostęp tylko do swoich aplikacji w interfejsie administracyjnym. Ty, jako pierwszy użytkownik (nauczyciel) uzyskasz dostęp do wszystkiego.</p><p>W trybie wielodostępu, można rejestrować studentów wykorzystując odnośnik "bulk register" dostępny w interfejsie administracyjnym i zarządzać nimi poprzez odnośnik "manage students". System śledzi czy studenci są zalogowani i jak wiele linii kodu oni dodali lub usunęli. Dane te są prezentowane na wykresie dostępnym na stronie "O aplikacji".</p><p>Trzeba pamiętać, że ten mechanizm zakłada, że wszyscy użytkownicy są zaufani. Wszystkie aplikacje utworzone z poziomu interfejsu administracyjnego uruchamiane są z takim samym poświadczeniem na tym samym systemie plików. Jest więc możliwe uzyskanie dostępu do aplikacji stworzonej przez jednego studenta do aplikacji innego studenta. Jest też możliwe utworzenie przez studenta aplikacji blokującej serwer.</p><h4>Interfejs administracyjny dla urządzeń mobilnych</h4><p>Proszę zwrócić uwagę, że aplikacja interfejsu administracyjnego zawiera "plugin_jqmobile", który ma zapakowana bibliotekę jQuery Mobile. Gdy interfejs administracyjny jest dostępny z urządzenia mobilnego, jest to wykrywane przez web2py i wyświetlany jest interfejs wykorzystujący układ przyjazny dla urządzeń mobilnych:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/mobile.png" alt="image" style="width:306px" /></p></p><h3>Więcej na temat interejsu administracyjnego aplikacji</h3><p><div class="inxx">appadmin</div> <div class="inxx">interfejs administracyjny aplikacji</div></p><p>Interfejs administracyjny aplikacji (w skrócie <em>appadmin</em>) nie jest przeznaczony do publicznego udostępniania. Został zaprojektowany aby pomóc w łatwym dostępie do bazy danych. Składa się tylko z dwóch plików: kontrolera "appadmin.py" i widoku "appadmin.html", który są używany przez wszystkie akcje w kontrolerze.</p><p>Kontroler appadmin jest względnie mały i czytelny. Dostarcza przykład z projektowaniem interfejsu bazy danych.</p><p>Interfejs administracyjny aplikacji pokazuje, które bazy danych są dostępne i jakie tabele istnieją w każdej bazie danych. Można wstawiać rekordy oraz listować indywidualnie wszystkie rekordy dla poszczególnych tabel. Stronicowanie interfejsu <strong>appadmin</strong> wyprowadza jednorazowo 100 rekordów.</p><p>Po wybraniu zestawu rekordów, nagłówek strony zmienia się, umożliwiając aktualizowanie lub usuwanie wybranych rekordów.</p><p>W celu zaktualizowania rekordów, wprowadź zapytanie SQL przypisane w polu tekstowym Query:</p><pre><code class="code">title = 'test'</code></pre><p>gdzie wartości ciągu znakowego muszą być ujęte w znaki apostrofu. Można specyfikować wiele pól, oddzielając je przecinkami.</p><p>Aby usunąć rekord, kliknij na odpowiednie pole wyboru w celu potwierdzenia, że na pewno chcesz to zrobić.</p><p>Interfejs administracyjny aplikacji może również dokonywać złączeń tabel, jeśli SQL FILTER zawiera warunek SQL, który ma dwie lub więcej tabel. Na przykład spróbuj:</p><pre><code class="code">db.image.id == db.post.image_id</code></pre><p>web2py przekazuje to wraz z DAL i traktuje to jako kwerendę łączącą dwie tabele. Dlatego obydwie tabele wybrane są wyrażeniem INNER JOIN. Oto wyjście:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5600.png" alt="image" style="width:480px" /></p></p><p>Jeśli kliknie się na numer id pola, otrzymuje się stronę edycji dla rekordu z odpowiednim id.</p><p>Jeśli kliknie się na numer odnośnego pola, wyświetli się strona edycji odnośnego rekordu.</p><p>Nie można zaktualizować lub usunąć wskazanych w złączeniu rekordów, ponieważ dotyczy to rekordów z wielu tabel i byłoby nie jednoznaczne.</p><p>Dodatkowo, możliwości zarządzania bazą danych przez interfejs <strong>appadmin</strong> obejmują wyświetlanie szczegółowych informacji o zawartości obiektu <code>cache</code> aplikacji (w <code>/yourapp/appadmin/cache</code>) jak również zawartości bieżących obiektów <code>request</code>, <code>response</code> i <code>session</code> (w <code>/yourapp/appadmin/state</code>).</p><p>Interfejs <strong>appadmin</strong> zamienia <code>response.menu</code> na swoje własne menu,które udostępnia odnośniki do stron <strong>edit</strong> aplikacji w interfejsie <strong>admin</strong>, stronę <strong>db</strong> (zarządzania bazą danych), stronę <strong>state</strong>  i stronę <strong>cache</strong>. Jeśli układ aplikacji nie generuje menu przy użyciu <code>response.menu</code>, to nie zobaczy się menu <strong>appadmin</strong>. W takim przypadku trzeba zmodyfikować plik appadmin.html i dodać <code>{{=MENU(response.menu)}}</code> w celu wyświetlania menu.</p>